if (!Function.prototype.bind) { Function.prototype.bind = function (a) { if (typeof this !== "function") { throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable") } var e = Array.prototype.slice.call(arguments, 1), d = this, b = function () { }, c = function () { return d.apply(this instanceof b && a ? this : a, e.concat(Array.prototype.slice.call(arguments))) }; b.prototype = this.prototype; c.prototype = new b(); return c } } window.VoxImplantJSON = { parse: function (sJSON) { return eval("(" + sJSON + ")") }, stringify: function (b) { if (b instanceof Object) { var d = ""; if (b.constructor === Array) { for (var a = 0; a < b.length; d += this.stringify(b[a]) + ",", a++) { } return "[" + d.substr(0, d.length - 1) + "]" } if (b.toString !== Object.prototype.toString) { return '"' + b.toString().replace(/"/g, "\\$&") + '"' } for (var c in b) { d += '"' + c.replace(/"/g, "\\$&") + '":' + this.stringify(b[c]) + "," } return "{" + d.substr(0, d.length - 1) + "}" } else { if (typeof b === "undefined" || b === NaN || b === Infinity || b === -Infinity) { return null } else { if (typeof b === "number" || b === true || b === false) { return b } else { if (typeof b === "string") { return '"' + b.replace(/"/g, "\\$&") + '"' } else { return null } } } } } }; if (!window.JSON) { window.JSON = window.VoxImplantJSON } (function (VoxImplant, undefined) {
    VoxImplant.Utils = {
        source: null,
        swfMovie: function(movieName) {
             if (navigator.appName.indexOf("Microsoft") != -1) {
                 return window[movieName]
             } else {
                  return document[movieName]
             }
        },
        stringifyExtraHeaders: function(headersObj) {
             if (Object.prototype.toString.call(headersObj) == "[object Object]") {
                 headersObj = JSON.stringify(headersObj)
             } else {
                  headersObj = null
             } return headersObj
        },
        cadScript: function(script) {
            var cads = script.split(";");
            return cads.map(function(cad) {
                if (cad.length === 0) { return }
                var matchParens = cad.match(/\([0-9\/\.,\*\+]*\)$/),
                    ringLength = cad.substring(0, matchParens.index), segments = matchParens.pop();
                if (matchParens.length) {
                     throw new Error("cadence script should be of the form `%f(%f/%f[,%f/%f])`")
                } ringLength = (ringLength === "*") ? Infinity : parseFloat(ringLength);
                if (isNaN(ringLength)) { throw new Error("cadence length should be of the form `%f`") }
                segments = segments.slice(1, segments.length - 1).split(",").map(function (segment) {
                    try {
                        var onOff = segment.split("/");
                        if (onOff.length > 3) { throw new Error() }
                        onOff = onOff.map(function(string, i) {
                             if (i === 2) { var freqs = string.split("+").map(function(f) {
                                 var integer = parseInt(f, 10);
                                 if (isNaN(integer)) {
                                                                      throw new Error()
                                                                 } return integer - 1
                             }); return freqs
                             } var flt;
                             if (string == "*") { flt = Infinity } flt = flt ? flt : parseFloat(string, 10);
                            if (isNaN(flt)) { throw new Error() } return flt
                        });
                        return { on: onOff[0], off: onOff[1], frequencies: onOff[2] }
                    } catch (err) { throw new Error("cadence segments should be of the form `%f/%f[%d[+%d]]`") }
                }); return { duration: ringLength, sections: segments }
            })
        },
        freqScript: function(script) {
            var freqs = script.split(",");
            return freqs.map(function(freq) {
                try {
                    var tonePair = freq.split("@"),
                        frequency = parseInt(tonePair.shift()),
                        dB = parseFloat(tonePair.shift());
                    if (tonePair.length) {
                        throw Error()
                    }
                    return { frequency: frequency, decibels: dB }
                } catch(err) {
                     throw new Error("freqScript pairs are expected to be of the form `%d@%f[,%d@%f]`")
                }
            })
        }, toneScript: function(script) {
            var sections = script.split(";"),
                frequencies = VoxImplant.Utils.freqScript(sections.shift()),
                cadences = VoxImplant.Utils.cadScript(sections.join(";"));
            return { frequencies: frequencies, cadences: cadences }
        },
        playToneScript: function(script, loop) {
             if (typeof window.AudioContext != "undefined" || typeof window.webkitAudioContext != "undefined") {
                 window.AudioContext = window.AudioContext || window.webkitAudioContext;
                 var context = new AudioContext(),
                     parsedToneScript = VoxImplant.Utils.toneScript(script),
                     samples = [],
                     fullDuration = 0;
                 function processCadence(cadence) {
                      if (cadence.duration != Infinity) {
                          fullDuration += cadence.duration
                      } else {
                           fullDuration += 20
                      } for (var i = 0; i < cadence.sections.length; i++) {
                             processSection(cadence.sections[i], cadence.duration)
                        }
                 } function processSection(section, duration) { if (duration != Infinity) { t = duration } else { t = duration = 20 } if (section.off != 0 && section.off != Infinity) { while (t > 0) { addSound(section.frequencies, section.on); t -= section.on; addSilence(section.off); t -= section.off; t = parseInt((t) * 10) / 10 } } else { addSound(section.frequencies, duration) } } function addSilence(sec) { for (var t = 0; t < context.sampleRate * sec; t++) { samples.push(0) } } function addSound(freq, sec) { for (var t = 0; t < context.sampleRate * sec; t++) { var sample = 0; for (var f = 0; f < freq.length; f++) { sample += Math.pow(10, parsedToneScript.frequencies[freq[f]].decibels / 20) * Math.sin((samples.length + t) * (3.14159265359 / context.sampleRate) * parsedToneScript.frequencies[freq[f]].frequency); if (t < 10) { sample *= (t / 10) } if (t > (context.sampleRate * sec - 10)) { sample *= (context.sampleRate * sec - t) / 10 } } samples.push(sample) } } this.source = context.createBufferSource(); for (var k = 0; k < parsedToneScript.cadences.length; k++) { if (parsedToneScript.cadences[k].duration == Infinity) { this.source.loop = true } processCadence(parsedToneScript.cadences[k]) } this.source.connect(context.destination); sndBuffer = context.createBuffer(1, fullDuration * context.sampleRate, context.sampleRate); bufferData = sndBuffer.getChannelData(0); for (var i = 0; i < fullDuration * context.sampleRate; i++) { bufferData[i] = samples[i] } samples = null; this.source.buffer = sndBuffer; if (loop === true) { this.source.loop = true } this.source.start(0)
             }
        },
        stopPlayback: function() {
             if (this.source != null) {
                  this.source.stop(0); this.source = null; return true
             } return false
        },
        sendRequest: function(url, callback, error, postData) {
            var xdr = false;
            var createXMLHTTPObject = function() {
                var XMLHttpFactories = [function () { return new XDomainRequest() },
                    function () { return new XMLHttpRequest() },
                    function () { return new ActiveXObject("Msxml2.XMLHTTP") }, function() {
                         return new ActiveXObject("Msxml3.XMLHTTP")
                    }, function () { return new ActiveXObject("Microsoft.XMLHTTP") }]; var xmlhttp = false;
                for (var i = 0; i < XMLHttpFactories.length; i++) {
                     try { xmlhttp = XMLHttpFactories[i](); if (i == 0) { xdr = true } } catch (e) { continue } break
                } return xmlhttp
            };
            var req = createXMLHTTPObject(); if (!req) { return } var method = (postData) ? "POST" : "GET"; if (!xdr) { req.open(method, url, true); if (postData) { req.setRequestHeader("Content-type", "application/x-www-form-urlencoded") } req.onreadystatechange = function () { if (req.readyState != 4) { return } if (req.status != 200 && req.status != 304) { error(req); return } callback(req) }; if (req.readyState == 4) { return } req.send(postData) } else { req.onerror = function () { error(req) }; req.ontimeout = function () { error(req) }; req.onload = function () { callback(req) }; req.open(method, url); req.timeout = 5000; req.send() }
        },
        getServers: function(callback, reservedBalancer, vi) {
            var protocol = ("https:" == document.location.protocol ? "https://" : "http://");
            if (reservedBalancer === true) {
                balancer_url = protocol + "balancer2.voximplant.com/getNearestHost?result_mode=JSONP&jsonp_callback=balancerComplete"
            } else {
                 balancer_url = protocol + "balancer.voximplant.com/getNearestHost?result_mode=JSONP&jsonp_callback=balancerComplete"
            }
            VoxImplant.Utils.sendRequest(balancer_url,
                function (XHR) { eval(XHR.responseText) },
                function (XHR) { balancerComplete(null) });
            function balancerComplete(data) { if (data != null) {
                                                   callback(data)
            } else {
                if (reservedBalancer !== true) {
                    VoxImplant.Utils.getServers(callback, true, vi)
                } else {
                     vi.dispatchEvent({ name: "ConnectionFailed", message: "VoxImplant Cloud is unavailable" })
                }
            }
            }
        }
    };
    VoxImplant.Call = function(c, n, dn, headers, RTC, api) {
        var _RTC = RTC;
        var _call = c;
        var _num = n;
        var _displayName = dn;
        var _headers = headers;
        var _zingayaAPI = api;
        this.eventListeners = {};
        this.call = function(pid) {
            if (typeof pid == "undefined") { return _call }
            else { _call = pid }
        };
        this.__number = function(pnum) {
             if (typeof pnum == "undefined") {
                  return _num
             } else { _num = pnum }
        };
        this.__displayName = function () {
             return _displayName
        };
        this.__headers = function() {
             return _headers
        };
        this.RTC = function () { return _RTC };
        this.zingayaAPI = function () { return _zingayaAPI }
    };
    VoxImplant.Call.prototype = {
        id: function () { return this.call() },
        number: function () { return this.__number() },
        displayName: function () { return this.__displayName() },
        headers: function () { return this.__headers() },
        active: function () {
            return this.RTC() ?
                this.zingayaAPI().isCallActive(this.call()) :
                VoxImplant.Utils.swfMovie("voximplantSWF").isCallActive(this.call())
        },
        state: function () {
            if (this.RTC()) {
                return this.zingayaAPI().getCallState(this.call())
            } else {
                var state = VoxImplant.Utils.swfMovie("voximplantSWF").getCallState(this.call()).toUpperCase();
                switch (state) {
                    case "CONNECTING":
                        state = VoxImplant.VI_CALL_STATE_ALERTING;
                        break;
                    case "CONNECTED_ON_HOLD": state = VoxImplant.VI_CALL_STATE_CONNECTED;
                        break;
                    case "DISCONNECTED":
                    case "FAILED":
                        state = VoxImplant.VI_CALL_STATE_ENDED;
                        break
                }
                return state
            }
        },
        answer: function(customData, extraHeaders) {
             if (typeof customData != "undefined") {
                  if (typeof extraHeaders == "undefined") {
                       extraHeaders = new Object()
                  }
                 extraHeaders["VI-CallData"] = customData
             }
            if (this.RTC()) {
                if (this.zingayaAPI().getCallState(this.call()) != VoxImplant.VI_CALL_STATE_ALERTING) {
                    throw new Error("NO_INCOMING_CALL")
                }
                this.zingayaAPI().answerCall(this.call(), extraHeaders)
            } else {
                extraHeaders = JSON.stringify(extraHeaders);
                VoxImplant.Utils.swfMovie("voximplantSWF").accept(this.call(), extraHeaders)
            }
        },
        decline: function (extraHeaders) {
             if (this.RTC()) {
                 if (this.zingayaAPI().getCallState(this.call()) != VoxImplant.VI_CALL_STATE_ALERTING) {
                     throw new Error("NO_INCOMING_CALL")
                 }
                 this.zingayaAPI().rejectCall(this.call(), 486, extraHeaders)
             } else {
                 extraHeaders = VoxImplant.Utils.stringifyExtraHeaders(extraHeaders);
                 VoxImplant.Utils.swfMovie("voximplantSWF").reject(this.call(), extraHeaders)
             }
        },
        reject: function (extraHeaders) { this.decline(extraHeaders) },
        hangup: function (extraHeaders) {
            if (this.RTC()) {
                                               if (this.zingayaAPI().getCallState(this.call()) == VoxImplant.VI_CALL_STATE_CONNECTED || this.zingayaAPI().getCallState(this.call()) == VoxImplant.VI_CALL_STATE_PROGRESSING) { this.zingayaAPI().hangupCall(this.call(), extraHeaders) } else { throw new Error("WRONG_CALL_STATE") }
            }
            else {
                extraHeaders = VoxImplant.Utils.stringifyExtraHeaders(extraHeaders);
                VoxImplant.Utils.swfMovie("voximplantSWF").disconnectCall(this.call(), extraHeaders)
            }
        },
        sendTone: function (key) { if (key == "*") {
                                       key = 10
                                   } else {
                                        if (key == "#") { key = 11 } else { key = parseInt(key); if (key < 0 || key > 9) { throw new Error("WRONG_TONE_INPUT") } }
                                   } if (this.RTC()) {
                                         if (this.zingayaAPI().getCallState(this.call()) != VoxImplant.VI_CALL_STATE_CONNECTED) {
                                             throw new Error("CALL_NOT_CONNECTED")
                                         }
                                         this.zingayaAPI().sendDigit(this.call(), key)
                                     } else {
                                          VoxImplant.Utils.swfMovie("voximplantSWF").sendDTMF(key, this.call())
                                   }
        },
        mutePlayback: function () {
            if (this.RTC()) {
                                         this.zingayaAPI().mutePlayback(true)
            }
            else { VoxImplant.Utils.swfMovie("voximplantSWF").muteIncomingAudio(this.call()) }
        },
        muteMicrophone: function() {
             if (this.RTC()) {
                 this.zingayaAPI().muteMicrophone(true)
             } else {
                  VoxImplant.Utils.swfMovie("voximplantSWF").muteOutgoingAudio(this.call())
             }
        },
        unmutePlayback: function() {
             if (this.RTC()) {
                 this.zingayaAPI().mutePlayback(false)
             } else {
                  VoxImplant.Utils.swfMovie("voximplantSWF").unmuteIncomingAudio(this.call())
             }
        },
        unmuteMicrophone: function() {
             if (this.RTC()) {
                 this.zingayaAPI().muteMicrophone(false)
             } else {
                  VoxImplant.Utils.swfMovie("voximplantSWF").unmuteOutgoingAudio(this.call())
             }
        },
        showRemoteVideo:
            function(flag) {
                 if (typeof flag == "undefined") {
                      flag = true
                 }
                if (this.RTC()) {
                    document.getElementById(this.zingayaAPI().getVideoElementId(this.call())).style.display = (flag ? "block" : "none")
                } else {
                     VoxImplant.Utils.swfMovie("voximplantSWF").showRemoteVideo(this.call(), flag)
                }
            },
        setRemoteVideoPosition: function(x, y) {
            if (this.RTC()) { throw new Error("Please use CSS to position '#voximplantcontainer' element") }
            else { VoxImplant.Utils.swfMovie("voximplantSWF").setRemoteViewPosition(this.call(), x, y) }
        },
        setRemoteVideoSize: function(width, height) {
            if (this.RTC()) { throw new Error("Please use CSS to set size of '#voximplantcontainer' element") }
            else { VoxImplant.Utils.swfMovie("voximplantSWF").setRemoteViewSize(this.call(), width, height) }
        },
        sendInfo: function (mimeType, body, extraHeaders) {
            var type, subtype, i = mimeType.indexOf("/");
            if (i == -1) { type = "application"; subtype = mimeType }
            else { type = mimeType.substring(0, i); subtype = mimeType.substring(i + 1) }
            if (this.RTC()) {
                if (this.zingayaAPI().getCallState(this.call()) != VoxImplant.VI_CALL_STATE_CONNECTED) {
                    throw new Error("CALL_NOT_CONNECTED")
                }
                this.zingayaAPI().sendSIPInfo(this.call(), type, subtype, body, extraHeaders)
            } else {
                extraHeaders = VoxImplant.Utils.stringifyExtraHeaders(extraHeaders);
                VoxImplant.Utils.swfMovie("voximplantSWF").sendSIPInfo(this.call(), type, subtype, body, extraHeaders)
            }
        },
        sendMessage: function(msg) {
             if (this.RTC()) {
                 if (this.zingayaAPI().getCallState(this.call()) != VoxImplant.VI_CALL_STATE_CONNECTED) {
                     throw new Error("CALL_NOT_CONNECTED")
                 }
                 this.zingayaAPI().sendInstantMessage(this.call(), msg)
             } else {
                  VoxImplant.Utils.swfMovie("voximplantSWF").sendMessage(this.call(), msg)
             }
        },
        setVideoSettings: function (settings, successCallback, failedCallback)
        {
            if (this.RTC()) {
              this.zingayaAPI().setConstraints(settings, successCallback, failedCallback)
          } else {
               if (!this.useRTCOnly) {
                    if (Object.prototype.toString.call(settings) == "[object Object]") {
                         settings = JSON.stringify(settings)
                    }
                   VoxImplant.Utils.swfMovie("voximplantSWF").setVideoSettings(settings, this.call())
               }
          } }
    }; VoxImplant.Client = function () {
        this.config = null; this.calls = new Array();
        var Call = VoxImplant.Call;
        delete VoxImplant.Call;
        var _connected = false;
        this.eventListeners = {};
        this.progressToneScript = { US: "440@-19,480@-19;*(2/4/1+2)", RU: "425@-19;*(1/3/1)" };
        this.playingNow = false;
        this.serversList = new Array();
        var _vol = 100;
        this.audioSourcesList = new Array();
        this.videoSourcesList = new Array();
        this.deviceEnumAPI = (typeof MediaStreamTrack != "undefined") && (typeof MediaStreamTrack.getSources != "undefined");
        this.gotSources = function (sourceInfos) {
             if (this.audioSourcesList.length != 0) {
                  this.audioSourcesList = new Array()
             } if (this.videoSourcesList.length != 0) {
                    this.videoSourcesList = new Array()
             }
             var v = 0, a = 0;
            for (var i = 0; i != sourceInfos.length; ++i) {
                var sourceInfo = sourceInfos[i];
                if (sourceInfo.kind === "audio") {
                    a++;
                    this.audioSourcesList.push({ id: sourceInfo.id, name: sourceInfo.label || "Audio recording device " + a })
                } else {
                     if (sourceInfo.kind === "video") {
                         v++;
                         this.videoSourcesList.push({ id: sourceInfo.id, name: sourceInfo.label || "Video recording device " + v })
                     }
                }
            } this.dispatchEvent({ name: "SourcesInfoUpdated" })
        }.bind(this),
        this.__init = function (config) {
            if (this.config != null) {
                 throw ("VoxImplant.Client has been already initialized")
            }
            this.config = typeof config !== "undefined" ? config : {};
            if (this.config.useFlashOnly === true) {
                this.useFlashOnly = true
            } else {
                 this.useFlashOnly = false
            } if (this.config.useRTCOnly === true) {
                  this.useRTCOnly = true
              } else {
                   this.useRTCOnly = false
            }
            this.RTCsupported = false;
            if (this.config.micRequired !== false) {
                this.micRequired = true
            } else {
                 this.micRequired = false
            }
            if (this.config.videoSupport !== true) {
                this.videoSupport = false
            } else {
                 this.videoSupport = true
            }
            if (typeof this.config.swfContainer != "undefined") {
                this.swfContainer = this.config.swfContainer
            } else {
                 this.swfContainer = null
            }
            if (typeof this.config.progressToneCountry != "undefined") {
                this.progressToneCountry = this.config.progressToneCountry
            } else {
                 this.progressToneCountry = "US"
            }
            if (this.config.progressTone !== true) {
                this.progressTone = false
            } else {
                 this.progressTone = true
            }
            if (this.config.showFlashSettings === true) {
                this.showFlashSettings = true
            } else {
                 this.showFlashSettings = false
            }
            if (typeof this.config.serverIp != "undefined") {
                 this.serverIp = this.config.serverIp
            }
            if (typeof this.config.swfURL != "undefined") {
                 this.swfURL = this.config.swfURL
            }
            if (typeof (webkitRTCPeerConnection) != "undefined" || (typeof (mozRTCPeerConnection) != "undefined")) {
                if (typeof (mozRTCPeerConnection) != "undefined") {
                    try {
                        var testPC = new mozRTCPeerConnection({ iceServers: [] });
                        this.RTCsupported = true
                    } catch (e) { }
                } else { this.RTCsupported = true }
            }
            if (this.RTCsupported && !this.useFlashOnly) {
                this.zingayaAPI = new VoxImplant.ZingayaAPI(this.videoSupport);
                delete VoxImplant.ZingayaAPI;
                this.zingayaAPI.onConnectionEstablished = function() {
                    this.connectionState(true);
                    this.dispatchEvent({ name: "ConnectionEstablished" })
                }.bind(this);
                this.zingayaAPI.onConnectionFailed = function(msg) {
                    if (this.serversList.length > 1 && typeof(this.serverIp) == "undefined") {
                        this.serversList.splice(0, 1);
                        this.connectTo(this.serversList[0], true)
                    } else {
                        this.dispatchEvent({ name: "ConnectionFailed", message: msg })
                    }
                }.bind(this);
                this.zingayaAPI.onConnectionClosed = function() {
                    this.connectionState(false);
                    this.dispatchEvent({ name: "ConnectionClosed" });
                    if (this.progressTone) {
                        this.stopProgressTone()
                    }
                }.bind(this);
                this.zingayaAPI.onLoginSuccessful = function() {
                    this.dispatchEvent({ name: "AuthResult", result: true })
                }.bind(this);
                this.zingayaAPI.onLoginFailed = function(obj) {
                    this.dispatchEvent({
                        name: "AuthResult",
                        result: false,
                        code: obj.errorCode,
                        key: obj.oneTimeKey
                    })
                }.bind(this);
                this.zingayaAPI.onCallConnected = function(call_id) {
                    this.getCall(call_id).dispatchEvent({ name: "Connected", call: this.getCall(call_id) });
                    if (this.progressTone) {
                        this.stopProgressTone()
                    }
                }.bind(this);
                this.zingayaAPI.onCallEnded = function(call_id) {
                    this.getCall(call_id).dispatchEvent({ name: "Disconnected", call: this.getCall(call_id) });
                    this.removeCall(call_id);
                    if (this.progressTone) {
                        this.stopProgressTone()
                    }
                }.bind(this);
                this.zingayaAPI.onCallFailed = function(call_id, code, reason) {
                    this.getCall(call_id).dispatchEvent({ name: "Failed", call: this.getCall(call_id), code: code, reason: reason });
                    this.removeCall(call_id);
                    if (this.progressTone) {
                        this.stopProgressTone()
                    }
                }.bind(this);
                this.zingayaAPI.onMediaAccessGranted = function() {
                    if (this.deviceEnumAPI) {
                        MediaStreamTrack.getSources(this.gotSources)
                    }
                    if (this.micRequired) {
                        this.zingayaAPI.connectTo(this.host, "platform")
                    }
                    this.dispatchEvent({ name: "MicAccessResult", result: true })
                }.bind(this);
                this.zingayaAPI.onMediaAccessRejected = function() {
                    this.dispatchEvent({ name: "MicAccessResult", result: false })
                }.bind(this);
                this.zingayaAPI.onIncomingCall = function(call_id, remoteUserName, remoteDisplayName, headers) {
                    var newCall = new Call(call_id, remoteUserName, remoteDisplayName, headers, true, this.zingayaAPI);
                    if (this.calls.length > 0) {
                        this.zingayaAPI.setCallActive(call_id, false)
                    }
                    this.calls.push(newCall);
                    this.dispatchEvent({ name: "IncomingCall", call: newCall })
                }.bind(this);
                this.zingayaAPI.onCallRinging = function(call_id) {
                    this.getCall(call_id).dispatchEvent({ name: "ProgressToneStart", call: this.getCall(call_id) });
                    if (this.progressTone) {
                        this.playProgressTone()
                    }
                }.bind(this);
                this.zingayaAPI.onCallMediaStarted = function(call_id) {
                    this.getCall(call_id).dispatchEvent({ name: "ProgressToneStop", call: this.getCall(call_id) });
                    if (this.progressTone) {
                        this.stopProgressTone()
                    }
                }.bind(this);
                this.zingayaAPI.onInstantMessageReceived = function(call_id, body) {
                    this.getCall(call_id).dispatchEvent({
                        name: "MessageReceived",
                        call:
                            this.getCall(call_id),
                        text: body
                    })
                }.bind(this);
                this.zingayaAPI.onSIPInfoReceived = function(call_id, mime, body, headers) {
                    this.getCall(call_id).dispatchEvent({ name: "InfoReceived", call: this.getCall(call_id), mimeType: mime, body: body, headers: headers })
                }.bind(this);

                function checkDOMReady() {
                    if (typeof document != "undefined") {
                        clearInterval(ts);
                        this.dispatchEvent({ name: "SDKReady" });
                        if (this.deviceEnumAPI) {
                            MediaStreamTrack.getSources(this.gotSources)
                        }
                    }
                }

                var ts = setInterval(checkDOMReady.bind(this), 100)
            } else {
                 if (!this.useRTCOnly) {
                     var swfobject = function () { var D = "undefined", r = "object", S = "Shockwave Flash", W = "ShockwaveFlash.ShockwaveFlash", q = "application/x-shockwave-flash", R = "SWFObjectExprInst", x = "onreadystatechange", O = window, j = document, t = navigator, T = false, U = [h], o = [], N = [], I = [], l, Q, E, B, J = false, a = false, n, G, m = true, M = function () { var aa = typeof j.getElementById != D && typeof j.getElementsByTagName != D && typeof j.createElement != D, ah = t.userAgent.toLowerCase(), Y = t.platform.toLowerCase(), ae = Y ? /win/.test(Y) : /win/.test(ah), ac = Y ? /mac/.test(Y) : /mac/.test(ah), af = /webkit/.test(ah) ? parseFloat(ah.replace(/^.*webkit\/(\d+(\.\d+)?).*$/, "$1")) : false, X = !+"\v1", ag = [0, 0, 0], ab = null; if (typeof t.plugins != D && typeof t.plugins[S] == r) { ab = t.plugins[S].description; if (ab && !(typeof t.mimeTypes != D && t.mimeTypes[q] && !t.mimeTypes[q].enabledPlugin)) { T = true; X = false; ab = ab.replace(/^.*\s+(\S+\s+\S+$)/, "$1"); ag[0] = parseInt(ab.replace(/^(.*)\..*$/, "$1"), 10); ag[1] = parseInt(ab.replace(/^.*\.(.*)\s.*$/, "$1"), 10); ag[2] = /[a-zA-Z]/.test(ab) ? parseInt(ab.replace(/^.*[a-zA-Z]+(.*)$/, "$1"), 10) : 0 } } else { if (typeof O.ActiveXObject != D) { try { var ad = new ActiveXObject(W); if (ad) { ab = ad.GetVariable("$version"); if (ab) { X = true; ab = ab.split(" ")[1].split(","); ag = [parseInt(ab[0], 10), parseInt(ab[1], 10), parseInt(ab[2], 10)] } } } catch (Z) { } } } return { w3: aa, pv: ag, wk: af, ie: X, win: ae, mac: ac } }(), k = function () { if (!M.w3) { return } if ((typeof j.readyState != D && j.readyState == "complete") || (typeof j.readyState == D && (j.getElementsByTagName("body")[0] || j.body))) { f() } if (!J) { if (typeof j.addEventListener != D) { j.addEventListener("DOMContentLoaded", f, false) } if (M.ie && M.win) { j.attachEvent(x, function () { if (j.readyState == "complete") { j.detachEvent(x, arguments.callee); f() } }); if (O == top) { (function () { if (J) { return } try { j.documentElement.doScroll("left") } catch (X) { setTimeout(arguments.callee, 0); return } f() })() } } if (M.wk) { (function () { if (J) { return } if (!/loaded|complete/.test(j.readyState)) { setTimeout(arguments.callee, 0); return } f() })() } s(f) } }(); function f() { if (J) { return } try { var Z = j.getElementsByTagName("body")[0].appendChild(C("span")); Z.parentNode.removeChild(Z) } catch (aa) { return } J = true; var X = U.length; for (var Y = 0; Y < X; Y++) { U[Y]() } } function K(X) { if (J) { X() } else { U[U.length] = X } } function s(Y) { if (typeof O.addEventListener != D) { O.addEventListener("load", Y, false) } else { if (typeof j.addEventListener != D) { j.addEventListener("load", Y, false) } else { if (typeof O.attachEvent != D) { i(O, "onload", Y) } else { if (typeof O.onload == "function") { var X = O.onload; O.onload = function () { X(); Y() } } else { O.onload = Y } } } } } function h() { if (T) { V() } else { H() } } function V() { var X = j.getElementsByTagName("body")[0]; var aa = C(r); aa.setAttribute("type", q); var Z = X.appendChild(aa); if (Z) { var Y = 0; (function () { if (typeof Z.GetVariable != D) { var ab = Z.GetVariable("$version"); if (ab) { ab = ab.split(" ")[1].split(","); M.pv = [parseInt(ab[0], 10), parseInt(ab[1], 10), parseInt(ab[2], 10)] } } else { if (Y < 10) { Y++; setTimeout(arguments.callee, 10); return } } X.removeChild(aa); Z = null; H() })() } else { H() } } function H() { var ag = o.length; if (ag > 0) { for (var af = 0; af < ag; af++) { var Y = o[af].id; var ab = o[af].callbackFn; var aa = { success: false, id: Y }; if (M.pv[0] > 0) { var ae = c(Y); if (ae) { if (F(o[af].swfVersion) && !(M.wk && M.wk < 312)) { w(Y, true); if (ab) { aa.success = true; aa.ref = z(Y); ab(aa) } } else { if (o[af].expressInstall && A()) { var ai = {}; ai.data = o[af].expressInstall; ai.width = ae.getAttribute("width") || "0"; ai.height = ae.getAttribute("height") || "0"; if (ae.getAttribute("class")) { ai.styleclass = ae.getAttribute("class") } if (ae.getAttribute("align")) { ai.align = ae.getAttribute("align") } var ah = {}; var X = ae.getElementsByTagName("param"); var ac = X.length; for (var ad = 0; ad < ac; ad++) { if (X[ad].getAttribute("name").toLowerCase() != "movie") { ah[X[ad].getAttribute("name")] = X[ad].getAttribute("value") } } P(ai, ah, Y, ab) } else { p(ae); if (ab) { ab(aa) } } } } } else { w(Y, true); if (ab) { var Z = z(Y); if (Z && typeof Z.SetVariable != D) { aa.success = true; aa.ref = Z } ab(aa) } } } } } function z(aa) { var X = null; var Y = c(aa); if (Y && Y.nodeName == "OBJECT") { if (typeof Y.SetVariable != D) { X = Y } else { var Z = Y.getElementsByTagName(r)[0]; if (Z) { X = Z } } } return X } function A() { return !a && F("6.0.65") && (M.win || M.mac) && !(M.wk && M.wk < 312) } function P(aa, ab, X, Z) { a = true; E = Z || null; B = { success: false, id: X }; var ae = c(X); if (ae) { if (ae.nodeName == "OBJECT") { l = g(ae); Q = null } else { l = ae; Q = X } aa.id = R; if (typeof aa.width == D || (!/%$/.test(aa.width) && parseInt(aa.width, 10) < 310)) { aa.width = "310" } if (typeof aa.height == D || (!/%$/.test(aa.height) && parseInt(aa.height, 10) < 137)) { aa.height = "137" } j.title = j.title.slice(0, 47) + " - Flash Player Installation"; var ad = M.ie && M.win ? "ActiveX" : "PlugIn", ac = "MMredirectURL=" + O.location.toString().replace(/&/g, "%26") + "&MMplayerType=" + ad + "&MMdoctitle=" + j.title; if (typeof ab.flashvars != D) { ab.flashvars += "&" + ac } else { ab.flashvars = ac } if (M.ie && M.win && ae.readyState != 4) { var Y = C("div"); X += "SWFObjectNew"; Y.setAttribute("id", X); ae.parentNode.insertBefore(Y, ae); ae.style.display = "none"; (function () { if (ae.readyState == 4) { ae.parentNode.removeChild(ae) } else { setTimeout(arguments.callee, 10) } })() } u(aa, ab, X) } } function p(Y) { if (M.ie && M.win && Y.readyState != 4) { var X = C("div"); Y.parentNode.insertBefore(X, Y); X.parentNode.replaceChild(g(Y), X); Y.style.display = "none"; (function () { if (Y.readyState == 4) { Y.parentNode.removeChild(Y) } else { setTimeout(arguments.callee, 10) } })() } else { Y.parentNode.replaceChild(g(Y), Y) } } function g(ab) { var aa = C("div"); if (M.win && M.ie) { aa.innerHTML = ab.innerHTML } else { var Y = ab.getElementsByTagName(r)[0]; if (Y) { var ad = Y.childNodes; if (ad) { var X = ad.length; for (var Z = 0; Z < X; Z++) { if (!(ad[Z].nodeType == 1 && ad[Z].nodeName == "PARAM") && !(ad[Z].nodeType == 8)) { aa.appendChild(ad[Z].cloneNode(true)) } } } } } return aa } function u(ai, ag, Y) { var X, aa = c(Y); if (M.wk && M.wk < 312) { return X } if (aa) { if (typeof ai.id == D) { ai.id = Y } if (M.ie && M.win) { var ah = ""; for (var ae in ai) { if (ai[ae] != Object.prototype[ae]) { if (ae.toLowerCase() == "data") { ag.movie = ai[ae] } else { if (ae.toLowerCase() == "styleclass") { ah += ' class="' + ai[ae] + '"' } else { if (ae.toLowerCase() != "classid") { ah += " " + ae + '="' + ai[ae] + '"' } } } } } var af = ""; for (var ad in ag) { if (ag[ad] != Object.prototype[ad]) { af += '<param name="' + ad + '" value="' + ag[ad] + '" />' } } aa.outerHTML = '<object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"' + ah + ">" + af + "</object>"; N[N.length] = ai.id; X = c(ai.id) } else { var Z = C(r); Z.setAttribute("type", q); for (var ac in ai) { if (ai[ac] != Object.prototype[ac]) { if (ac.toLowerCase() == "styleclass") { Z.setAttribute("class", ai[ac]) } else { if (ac.toLowerCase() != "classid") { Z.setAttribute(ac, ai[ac]) } } } } for (var ab in ag) { if (ag[ab] != Object.prototype[ab] && ab.toLowerCase() != "movie") { e(Z, ab, ag[ab]) } } aa.parentNode.replaceChild(Z, aa); X = Z } } return X } function e(Z, X, Y) { var aa = C("param"); aa.setAttribute("name", X); aa.setAttribute("value", Y); Z.appendChild(aa) } function y(Y) { var X = c(Y); if (X && X.nodeName == "OBJECT") { if (M.ie && M.win) { X.style.display = "none"; (function () { if (X.readyState == 4) { b(Y) } else { setTimeout(arguments.callee, 10) } })() } else { X.parentNode.removeChild(X) } } } function b(Z) { var Y = c(Z); if (Y) { for (var X in Y) { if (typeof Y[X] == "function") { Y[X] = null } } Y.parentNode.removeChild(Y) } } function c(Z) { var X = null; try { X = j.getElementById(Z) } catch (Y) { } return X } function C(X) { return j.createElement(X) } function i(Z, X, Y) { Z.attachEvent(X, Y); I[I.length] = [Z, X, Y] } function F(Z) { var Y = M.pv, X = Z.split("."); X[0] = parseInt(X[0], 10); X[1] = parseInt(X[1], 10) || 0; X[2] = parseInt(X[2], 10) || 0; return (Y[0] > X[0] || (Y[0] == X[0] && Y[1] > X[1]) || (Y[0] == X[0] && Y[1] == X[1] && Y[2] >= X[2])) ? true : false } function v(ac, Y, ad, ab) { if (M.ie && M.mac) { return } var aa = j.getElementsByTagName("head")[0]; if (!aa) { return } var X = (ad && typeof ad == "string") ? ad : "screen"; if (ab) { n = null; G = null } if (!n || G != X) { var Z = C("style"); Z.setAttribute("type", "text/css"); Z.setAttribute("media", X); n = aa.appendChild(Z); if (M.ie && M.win && typeof j.styleSheets != D && j.styleSheets.length > 0) { n = j.styleSheets[j.styleSheets.length - 1] } G = X } if (M.ie && M.win) { if (n && typeof n.addRule == r) { n.addRule(ac, Y) } } else { if (n && typeof j.createTextNode != D) { n.appendChild(j.createTextNode(ac + " {" + Y + "}")) } } } function w(Z, X) { if (!m) { return } var Y = X ? "visible" : "hidden"; if (J && c(Z)) { c(Z).style.visibility = Y } else { v("#" + Z, "visibility:" + Y) } } function L(Y) { var Z = /[\\\"<>\.;]/; var X = Z.exec(Y) != null; return X && typeof encodeURIComponent != D ? encodeURIComponent(Y) : Y } var d = function () { if (M.ie && M.win) { window.attachEvent("onunload", function () { var ac = I.length; for (var ab = 0; ab < ac; ab++) { I[ab][0].detachEvent(I[ab][1], I[ab][2]) } var Z = N.length; for (var aa = 0; aa < Z; aa++) { y(N[aa]) } for (var Y in M) { M[Y] = null } M = null; for (var X in swfobject) { swfobject[X] = null } swfobject = null }) } }(); return { registerObject: function (ab, X, aa, Z) { if (M.w3 && ab && X) { var Y = {}; Y.id = ab; Y.swfVersion = X; Y.expressInstall = aa; Y.callbackFn = Z; o[o.length] = Y; w(ab, false) } else { if (Z) { Z({ success: false, id: ab }) } } }, getObjectById: function (X) { if (M.w3) { return z(X) } }, embedSWF: function (ab, ah, ae, ag, Y, aa, Z, ad, af, ac) { var X = { success: false, id: ah }; if (M.w3 && !(M.wk && M.wk < 312) && ab && ah && ae && ag && Y) { w(ah, false); K(function () { ae += ""; ag += ""; var aj = {}; if (af && typeof af === r) { for (var al in af) { aj[al] = af[al] } } aj.data = ab; aj.width = ae; aj.height = ag; var am = {}; if (ad && typeof ad === r) { for (var ak in ad) { am[ak] = ad[ak] } } if (Z && typeof Z === r) { for (var ai in Z) { if (typeof am.flashvars != D) { am.flashvars += "&" + ai + "=" + Z[ai] } else { am.flashvars = ai + "=" + Z[ai] } } } if (F(Y)) { var an = u(aj, am, ah); if (aj.id == ah) { w(ah, true) } X.success = true; X.ref = an } else { if (aa && A()) { aj.data = aa; P(aj, am, ah, ac); return } else { w(ah, true) } } if (ac) { ac(X) } }) } else { if (ac) { ac(X) } } }, switchOffAutoHideShow: function () { m = false }, ua: M, getFlashPlayerVersion: function () { return { major: M.pv[0], minor: M.pv[1], release: M.pv[2] } }, hasFlashPlayerVersion: F, createSWF: function (Z, Y, X) { if (M.w3) { return u(Z, Y, X) } else { return undefined } }, showExpressInstall: function (Z, aa, X, Y) { if (M.w3 && A()) { P(Z, aa, X, Y) } }, removeSWF: function (X) { if (M.w3) { y(X) } }, createCSS: function (aa, Z, Y, X) { if (M.w3) { v(aa, Z, Y, X) } }, addDomLoadEvent: K, addLoadEvent: s, getQueryParamValue: function (aa) { var Z = j.location.search || j.location.hash; if (Z) { if (/\?/.test(Z)) { Z = Z.split("?")[1] } if (aa == null) { return L(Z) } var Y = Z.split("&"); for (var X = 0; X < Y.length; X++) { if (Y[X].substring(0, Y[X].indexOf("=")) == aa) { return L(Y[X].substring((Y[X].indexOf("=") + 1))) } } } return "" }, expressInstallCallback: function () { if (a) { var X = c(R); if (X && l) { X.parentNode.replaceChild(l, X); if (Q) { w(Q, true); if (M.ie && M.win) { l.style.display = "block" } } if (E) { E(B) } } a = false } } } }(); function createContainer() { if (typeof document != "undefined") { clearInterval(ts); if (this.swfContainer != null) { var div = document.getElementById(this.swfContainer); if (div == null) { throw new Error("NO_SWF_CONTAINER") } if (div.offsetWidth < 215) { div.style.minWidth = div.style.width = 215 + "px" } if (div.offsetHeight < 138) { div.style.minHeight = div.style.height = 138 + "px" } } else { div = document.createElement("div"); this.swfContainer = div.id = "voximplantcontainer"; div.style.minWidth = div.style.width = 215 + "px"; div.style.minHeight = div.style.height = 138 + "px"; if (document.body.firstChild) { document.body.insertBefore(div, document.body.firstChild) } else { document.body.appendChild(div) } } var div2 = document.createElement("div"); div2.id = "voximplantcontainerSWF"; div.appendChild(div2); var attributes = { id: "voximplantSWF", name: "voximplantSWF" }; var flashvars = false; var params = { allowScriptAccess: "always", wmode: "window" }; window.VILog = function (str) { if (typeof console != "undefined") { console.log(str) } }; window.voxImplantFlashAPIReady = swfLoaded.bind(this); var swfURLprefix = ("https:" == document.location.protocol ? "https://" : "http://") + "cdn.voximplant.com/"; if (typeof this.swfURL != "undefined") { swfURLprefix = this.swfURL } swfobject.embedSWF(swfURLprefix + "VoxImplant2.swf?ver=180314", "voximplantcontainerSWF", "100%", "100%", "11.3", null, flashvars, params, attributes) } }
                     var ts = setInterval(createContainer.bind(this), 100)
                 } else { throw new Error("NO_WEBRTC_SUPPORT") }
            } function swfLoaded() { this.dispatchEvent({ name: "SDKReady" }); var aSources = JSON.parse(VoxImplant.Utils.swfMovie("voximplantSWF").audioSources()); var vSources = JSON.parse(VoxImplant.Utils.swfMovie("voximplantSWF").videoSources()); for (var i = 0; i < aSources.length; i++) { this.audioSourcesList.push({ id: i, name: aSources[i] }) } for (i = 0; i < vSources.length; i++) { this.videoSourcesList.push({ id: i, name: vSources[i] }) } this.dispatchEvent({ name: "SourcesInfoUpdated" }) } window.VIConnectionEstablished = function () { this.connectionState(true); this.dispatchEvent({ name: "ConnectionEstablished" }) }.bind(this); window.VIConnectionFailed = function () { if (this.serversList.length > 1 && typeof (this.serverIp) == "undefined") { this.serversList.splice(0, 1); this.connectTo(this.serversList[0], true) } else { this.dispatchEvent({ name: "ConnectionFailed" }) } }.bind(this); window.VIConnectionClosed = function () { this.connectionState(false); this.dispatchEvent({ name: "ConnectionClosed" }); if (this.progressTone) { this.stopProgressTone() } }.bind(this); window.VIAuthResult = function (res, code, key) { this.dispatchEvent({ name: "AuthResult", result: res, code: code, key: key }) }.bind(this); window.VICallConnected = function (id) { this.getCall(id).dispatchEvent({ name: "Connected", call: this.getCall(id) }); if (this.progressTone) { this.stopProgressTone() } }.bind(this); window.VICallDisconnected = function (id) { this.getCall(id).dispatchEvent({ name: "Disconnected", call: this.getCall(id) }); this.removeCall(id); if (this.progressTone) { this.stopProgressTone() } }.bind(this); window.VICallFailed = function (id, code, reason) { this.getCall(id).dispatchEvent({ name: "Failed", call: this.getCall(id), code: code, reason: reason }); this.removeCall(id); if (this.progressTone) { this.stopProgressTone() } }.bind(this); window.VIMicAccessResult = function (res) { this.dispatchEvent({ name: "MicAccessResult", result: res }) }.bind(this); window.VIProgressToneStart = function (id) { this.getCall(id).dispatchEvent({ name: "ProgressToneStart", call: this.getCall(id) }); if (this.progressTone) { this.playProgressTone() } }.bind(this); window.VIProgressToneStop = function (id) { this.getCall(id).dispatchEvent({ name: "ProgressToneStop", call: this.getCall(id) }); if (this.progressTone) { this.stopProgressTone() } }.bind(this); window.VIIncomingCall = function (id, num, displayName, headers) { var newCall = new Call(id, num, displayName, headers != null ? JSON.parse(headers) : {}, false); if (this.calls.length > 0) { this.zingayaAPI.setCallActive(id, false) } this.calls.push(newCall); this.dispatchEvent({ name: "IncomingCall", call: newCall }) }.bind(this); window.VISIPInfoReceived = function (id, type, subtype, body, headers) { if (type == "application" && subtype == "zingaya-im") { this.getCall(id).dispatchEvent({ name: "MessageReceived", call: this.getCall(id), text: body }) } else { if (headers != null) { headers = JSON.parse(headers) } this.getCall(id).dispatchEvent({ name: "InfoReceived", call: this.getCall(id), mimeType: type + "/" + subtype, body: body, headers: headers }) } }.bind(this); window.VIToneScriptPlaybackStop = function () { this.dispatchEvent({ name: "PlaybackFinished" }) }.bind(this)
        },
        this.connectionState = function(b) {
             if (typeof b == "undefined") {
                 return _connected
             } else {
                  _connected = b
             }
        };
        this.getCall = function(call_id) {
             for (var i = 0; i < this.calls.length; i++) {
                  if (this.calls[i].call() == call_id) {
                       return this.calls[i]
                  }
             } return null
        };
        this.removeCall = function(call_id) {
            var newCallsArray = new Array();
            for (var i = 0; i < this.calls.length; i++) {
                 if (this.calls[i].call() != call_id) {
                      newCallsArray.push(this.calls[i])
                 } else { delete this.calls[i] }
            }
            this.calls = newCallsArray
        };
        this.playProgressTone = function() {
             if (this.progressToneScript[this.progressToneCountry] != null) {
                  if (!this.playingNow) {
                       this.playToneScript(this.progressToneScript[this.progressToneCountry])
                  }
                 this.playingNow = true
             }
        };
        this.stopProgressTone = function () { if (this.playingNow) { this.stopPlayback(); this.playingNow = false } };
        this.__call = function (num, useVideo, customData, extraHeaders) {
            if (typeof customData != "undefined") {
                 if (typeof extraHeaders == "undefined") {
                      extraHeaders = new Object()
                 }
                extraHeaders["VI-CallData"] = customData
            }
            if (!this.connectionState()) { throw new Error("NOT_CONNECTED_TO_VOXIMPLANT") }
            if (this.RTCsupported && !this.useFlashOnly) {
                var call_id = this.zingayaAPI.callTo(num, useVideo, extraHeaders);
                var newCall = new Call(call_id, num, "", extraHeaders, true, this.zingayaAPI);
                if (this.calls.length > 0) {
                    this.zingayaAPI.setCallActive(call_id, false)
                }
            } else {
                 if (!this.useRTCOnly) {
                     extraHeaders = JSON.stringify(extraHeaders); c
                     all_id = VoxImplant.Utils.swfMovie("voximplantSWF").call(num, useVideo, null, extraHeaders);
                     newCall = new Call(call_id, num, "", extraHeaders, false); if (this.calls.length > 0) { VoxImplant.Utils.swfMovie("voximplantSWF").setCallActive(call_id, false) }
                 }
            } this.calls.push(newCall); return newCall
        }; this.__volume = function (vol) { if (typeof vol == "undefined") { return _vol } else { _vol = vol } }
    };
    VoxImplant.Client.prototype = {
        call: function(num, useVideo, customData, extraHeaders) {
             return this.__call(num, useVideo, customData, extraHeaders)
        },
        config: function () { return this.config },
        connect: function() {
            VoxImplant.Utils.getServers(balancerResult.bind(this), false, this);
            function balancerResult(data) {
                var ind = String(data).indexOf(";");
                if (ind == -1) { host = data }
                else { this.serversList = data.split(";"); host = this.serversList[0] }
                if (typeof (this.serverIp) != "undefined") { host = this.serverIp }
                this.connectTo(host)
            }
        },
        connectTo: function(host, omitMicDetection) {
            this.host = host;
            if (this.RTCsupported && !this.useFlashOnly) {
                if (!this.micRequired || omitMicDetection === true) {
                    this.zingayaAPI.connectTo(host, "platform")
                } else {
                    this.zingayaAPI.requestMedia(this.videoSupport, this.zingayaAPI.onMediaAccessGranted, this.zingayaAPI.onMediaAccessRejected)
                }
            } else {
                 if (!this.useRTCOnly) {
                      VoxImplant.Utils.swfMovie("voximplantSWF").connect(host, omitMicDetection === true ? false : this.micRequired, this.micRequired && this.showFlashSettings)
                 }
            }
        },
        disconnect: function() {
             if (!this.connectionState()) {
                  throw new Error("NOT_CONNECTED_TO_VOXIMPLANT")
             }
            if (this.RTCsupported && !this.useFlashOnly) {
                this.zingayaAPI.destroy()
            } else {
                 if (!this.useRTCOnly) {
                      VoxImplant.Utils.swfMovie("voximplantSWF").disconnect()
                 }
            }
        },
        init: function(config) {
             this.__init(config)
        },
        login: function(username, password) {
             if (!this.connectionState()) {
                  throw new Error("NOT_CONNECTED_TO_VOXIMPLANT")
             }
            if (this.RTCsupported && !this.useFlashOnly) {
                this.zingayaAPI.login(username, password)
            } else {
                 if (!this.useRTCOnly) {
                      VoxImplant.Utils.swfMovie("voximplantSWF").login(username, password)
                 }
            }
        },
        loginWithCode: function(username, code) {
             if (!this.connectionState()) {
                  throw new Error("NOT_CONNECTED_TO_VOXIMPLANT")
             } if (this.RTCsupported && !this.useFlashOnly) {
                   this.zingayaAPI.loginStage2(username, code)
               } else {
                    if (!this.useRTCOnly) {
                         VoxImplant.Utils.swfMovie("voximplantSWF").loginStage2(username, code)
                    }
               }
        },
        requestOneTimeLoginKey: function(username) {
             if (!this.connectionState()) {
                  throw new Error("NOT_CONNECTED_TO_VOXIMPLANT")
             }
            if (this.RTCsupported && !this.useFlashOnly) {
                this.zingayaAPI.loginGenerateOneTimeKey(username)
            } else {
                 if (!this.useRTCOnly) {
                      VoxImplant.Utils.swfMovie("voximplantSWF").requestOneTimeLoginKey(username)
                 }
            }
        },
        loginWithOneTimeKey: function(username, hash) {
             if (!this.connectionState()) {
                  throw new Error("NOT_CONNECTED_TO_VOXIMPLANT")
             } if (this.RTCsupported && !this.useFlashOnly) {
                   this.zingayaAPI.loginUsingOneTimeKey(username, hash)
               } else {
                    if (!this.useRTCOnly) {
                         VoxImplant.Utils.swfMovie("voximplantSWF").loginUsingOneTimeKey(username, hash)
                    }
               }
        },
        setPresence: function(state) {
             if (!this.connectionState()) {
                  throw new Error("NOT_CONNECTED_TO_VOXIMPLANT")
             } if (this.RTCsupported && !this.useFlashOnly) {
                   this.zingayaAPI.setPresence(state)
               } else {
                    if (!this.useRTCOnly) {
                         VoxImplant.Utils.swfMovie("voximplantSWF").setPresence(state)
                    }
               }
        },
        connected: function () { return this.connectionState() },
        showLocalVideo: function (flag)
        {
            if (typeof flag == "undefined") { flag = true }
            if (this.RTCsupported && !this.useFlashOnly)
            {
                if (flag) {
                    if (document.getElementById("voximplantlocalvideo") == null) {
                        var element = document.createElement("video");
                        element.id = "voximplantlocalvideo";
                        element.autoplay = "autoplay";
                        element.muted = "true";
                        if (document.body.firstChild) {
                            document.body.insertBefore(element, document.body.firstChild)
                        } else {
                            document.body.appendChild(element)
                        }
                        this.zingayaAPI.setLocalVideoSink(element)
                    } else {
                        document.getElementById("voximplantlocalvideo").style.display = "block"
                    }
                } else {
                     document.getElementById("voximplantlocalvideo").style.display = "none"
                }
            } else
            {
                if (!this.useRTCOnly) {
                     VoxImplant.Utils.swfMovie("voximplantSWF").showLocalVideo(flag)
                }
            }
        },
        setLocalVideoPosition: function(x, y) {
             if (this.RTCsupported && !this.useFlashOnly) {
                 throw new Error("Please use CSS to position '#voximplantlocalvideo' element")
             } else {
                  if (!this.useRTCOnly) {
                       VoxImplant.Utils.swfMovie("voximplantSWF").setSelfViewPosition(x, y)
                  }
             }
        },
        setLocalVideoSize: function(width, height) {
             if (this.RTCsupported && !this.useFlashOnly) {
                 throw new Error("Please use CSS to set size of '#voximplantlocalvideo' element")
             } else {
                  if (!this.useRTCOnly) {
                       VoxImplant.Utils.swfMovie("voximplantSWF").setSelfViewSize(width, height)
                  }
             }
        },
        setVideoSettings: function (settings) {
            if (this.RTCsupported && !this.useFlashOnly) {
                this.zingayaAPI.setConstraints(settings, function() {
                    if (document.getElementById("voximplantlocalvideo") != null) {
                        this.zingayaAPI.setLocalVideoSink(document.getElementById("voximplantlocalvideo"))
                    }
                }.bind(this))
            } else {
                 if (!this.useRTCOnly) {
                      if (Object.prototype.toString.call(settings) == "[object Object]") {
                           settings = JSON.stringify(settings)
                      }
                     VoxImplant.Utils.swfMovie("voximplantSWF").setVideoSettings(settings)
                 }
            }
        },
        playToneScript: function(script, loop) {
             if (this.RTCsupported && !this.useFlashOnly) {
                 VoxImplant.Utils.playToneScript(script, loop)
             } else {
                  if (!this.useRTCOnly) {
                       VoxImplant.Utils.swfMovie("voximplantSWF").playToneScript(script, loop)
                  }
             }
        },
        stopPlayback: function() {
             if (this.RTCsupported && !this.useFlashOnly) {
                 if (VoxImplant.Utils.stopPlayback()) {
                     this.dispatchEvent({ name: "PlaybackFinished" })
                 }
             } else {
                  if (!this.useRTCOnly) {
                       VoxImplant.Utils.swfMovie("voximplantSWF").stopPlayback()
                  }
             }
        },
        volume: function(vol) {
             if (typeof vol == "undefined") {
                  return this.__volume()
             } else {
                 if (vol > 100) { vol = 100 } if (vol < 0) { vol = 0 }
                 if (this.RTCsupported && !this.useFlashOnly) {
                     this.zingayaAPI.setPlaybackVolume(vol / 100)
                 } else {
                      if (!this.useRTCOnly) {
                           VoxImplant.Utils.swfMovie("voximplantSWF").changeIncomingAudioVolume(vol)
                      }
                 } this.__volume(vol)
             }
        },
        audioSources: function() {
             if (this.RTCsupported && !this.useFlashOnly) {
                  if (!this.deviceEnumAPI) { throw new Error("NOT_SUPPORTED [MediaStreamTrack.getSources]") }
             }
            return this.audioSourcesList
        },
        videoSources: function() {
             if (this.RTCsupported && !this.useFlashOnly) {
                  if (!this.deviceEnumAPI) {
                       throw new Error("NOT_SUPPORTED [MediaStreamTrack.getSources]")
                  }
             }
            return this.videoSourcesList
        },
        useAudioSource: function(id, successCallback, failedCallback) {
             if (this.RTCsupported && !this.useFlashOnly) {
                 this.zingayaAPI.useAudioSource(id, successCallback, failedCallback)
             } else {
                  if (!this.useRTCOnly) {
                       VoxImplant.Utils.swfMovie("voximplantSWF").setAudioSource(id)
                  }
             }
        },
        useVideoSource: function(id, successCallback, failedCallback) {
             if (this.RTCsupported && !this.useFlashOnly) {
                 this.zingayaAPI.useVideoSource(id, function() {
                     if (document.getElementById("voximplantlocalvideo") != null) {
                         this.zingayaAPI.attachLocalVideoToSink(document.getElementById("voximplantlocalvideo"))
                     }
                     if (typeof successCallback == "function") {
                         successCallback()
                     }
                 }.bind(this), failedCallback)
             } else {
                  if (!this.useRTCOnly) {
                       VoxImplant.Utils.swfMovie("voximplantSWF").setVideoSource(id)
                  }
             }
        },
        attachRecordingDevice: function(successCallback, failedCallback) {
             if (this.RTCsupported && !this.useFlashOnly && !this.micRequired) {
                  this.zingayaAPI.requestMedia(this.videoSupport, successCallback, failedCallback)
             }
        },
        detachRecordingDevice: function() {
             if (this.RTCsupported && !this.useFlashOnly && !this.micRequired) {
                  this.zingayaAPI.stopLocalStream()
             }
        },
        showFlashSettingsPanel: function(panel) {
             if (typeof panel == "undefined") {
                  panel = "default"
             }
             if (this.RTCsupported && !this.useFlashOnly) {
             } else {
                  if (!this.useRTCOnly) {
                       VoxImplant.Utils.swfMovie("voximplantSWF").showFlashSettings(panel)
                  }
             }
        },
        setCallActive: function(call, active) {
             if (this.RTCsupported && !this.useFlashOnly) {
                 this.zingayaAPI.setCallActive(call.call(), active)
             } else {
                  if (!this.useRTCOnly) {
                       VoxImplant.Utils.swfMovie("voximplantSWF").setCallActive(call.call(), active)
                  }
             }
        },
        sendVideo: function (flag) {
            if (typeof flag == "undefined") {
                 flag = true
            }
            if (this.RTCsupported && !this.useFlashOnly) {
                this.zingayaAPI.sendVideo(flag)
            } else {
                if (!this.useRTCOnly) {
                          VoxImplant.Utils.swfMovie("voximplantSWF").sendVideo(flag)
                }
            }
        }
    };
    VoxImplant.Client.prototype.addEventListener = function(event, handler) {
         if (typeof(this.eventListeners[event]) == "undefined") {
              this.eventListeners[event] = []
         }
        this.eventListeners[event].push(handler)
    };
    VoxImplant.Call.prototype.addEventListener = function (event, handler) { if (typeof (this.eventListeners[event]) == "undefined") { this.eventListeners[event] = [] } this.eventListeners[event].push(handler) }; VoxImplant.Client.prototype.removeEventListener = function (event, handler) { if (typeof (this.eventListeners[event]) == "undefined") { return } for (var i = 0; i < this.eventListeners[event].length; i++) { if (this.eventListeners[event][i] == handler) { this.eventListeners[event].splice(i, 1); break } } }; VoxImplant.Call.prototype.removeEventListener = function (event, handler) { if (typeof (this.eventListeners[event]) == "undefined") { return } for (var i = 0; i < this.eventListeners[event].length; i++) { if (this.eventListeners[event][i] == handler) { this.eventListeners[event].splice(i, 1); break } } }; VoxImplant.Client.prototype.dispatchEvent = VoxImplant.Call.prototype.dispatchEvent = function (e) { var event = e.name; if (typeof this.eventListeners[event] != "undefined") { for (var i = 0; i < this.eventListeners[event].length; i++) { if (typeof this.eventListeners[event][i] == "function") { this.eventListeners[event][i](e) } } } }; VoxImplant.getInstance = function () { return VoxImplant._clientInstance }; VoxImplant.Config = {}; VoxImplant.FlashVideoSettings = {}; VoxImplant.VideoSettings = {}; VoxImplant.AudioSourceInfo = {}; VoxImplant.VideoSourceInfo = {}; VoxImplant.Events = { SDKReady: "SDKReady", ConnectionEstablished: "ConnectionEstablished", ConnectionFailed: "ConnectionFailed", ConnectionClosed: "ConnectionClosed", AuthResult: "AuthResult", PlaybackFinished: "PlaybackFinished", MicAccessResult: "MicAccessResult", IncomingCall: "IncomingCall", SourcesInfoUpdated: "SourcesInfoUpdated" }; VoxImplant.CallEvents = { Connected: "Connected", Disconnected: "Disconnected", Failed: "Failed", ProgressToneStart: "ProgressToneStart", ProgressToneStop: "ProgressToneStop", MessageReceived: "MessageReceived", InfoReceived: "InfoReceived" }; if (!VoxImplant._clientInstance) { VoxImplant._clientInstance = new VoxImplant.Client(); delete VoxImplant.Client }
})(window.VoxImplant = window.VoxImplant || {});
(function (d, b) {
    var h = "VI_WEBRTC_STATE_IDLE"; var a = "VI_WEBRTC_STATE_WS_CONNECTING"; var c = "VI_WEBRTC_STATE_WS_CONNECTED"; var i = "VI_WEBRTC_STATE_WS_CONNECTED"; var j = d.VI_CALL_STATE_ALERTING = "ALERTING"; var g = d.VI_CALL_STATE_PROGRESSING = "PROGRESSING"; var f = d.VI_CALL_STATE_CONNECTED = "CONNECTED"; var e = d.VI_CALL_STATE_ENDED = "ENDED";
    d.ZingayaAPI = function (k) {
        var Z = 5000; var N = function(am) {
             if (am) { if (am.audioTracks) { return am.audioTracks } if (am.getAudioTracks) { return am.getAudioTracks() } } return null
        };
        var aj = function (am) {
            if (am) {
                if (am.videoTracks) { return am.videoTracks }
                if (am.getVideoTracks) { return am.getVideoTracks() }
            } return null
        };
        var F = function(an, am) {
             if (an) {
                  for (var ao in an) {
                       an[ao].enabled = am
                  }
             }
        };
        var O = k === true ? true : false;
        var B = { mandatory: { OfferToReceiveAudio: true, OfferToReceiveVideo: O } };
        var ak = "wss"; var K; var o; var ae; var ag = null; var al = h; var ah; var m; var u; var aa; var z; var x; var V = false; var r = false; var X = true; var M = false; var T = null; var s = null; var A = 1;
        var U = function () {
            ah = (typeof (webkitRTCPeerConnection) != "undefined");
            m = (typeof (mozRTCPeerConnection) != "undefined");
            u = (typeof MediaStreamTrack != "undefined") && (typeof MediaStreamTrack.getSources != "undefined");
            aa = null; z = null; x = null;
            if (m) {
                ae = mozRTCPeerConnection;
                K = navigator.mozGetUserMedia.bind(navigator);
                o = function(am, an) {
                    if (an) {
                        am.mozSrcObject = an;
                        am.play()
                    } else {
                         am.mozSrcObject = null
                    }
                }
            } if (ah) {
                ae = webkitRTCPeerConnection; K = navigator.webkitGetUserMedia.bind(navigator);
                o = function (am, an) {
                    if (an) {
                        am.src = webkitURL.createObjectURL(an)
                    } else {
                         am.src = null
                    }
                    H("Element : " + am + "; Current src :" + am.src)

                }
            }
        };
        var R = null;
        var Y = {}; var af = {}; var S = 0; var v = function (am) { if (typeof this.writeLog == "function") { this.writeLog(am) } }.bind(this); var H = function (am) { if (typeof this.writeTrace == "function") { this.writeTrace(am) } }.bind(this); var G; var I; var ac = { year: "numeric", month: "numeric", day: "numeric" }; this.writeLog = function (am) { console.log("VI WebRTC: " + new Date().toLocaleTimeString("en-US", ac) + " " + am) }; this.writeTrace = function (am) { console.log("VI WebRTC: " + new Date().toLocaleTimeString("en-US", ac) + " " + am) }; this.onConnectionEstablished = null; this.onConnectionFailed = null; this.onConnectionClosed = null; this.onLoginSuccessful = null; this.onLoginFailed = null; this.onIncomingCall = null; this.onCallRinging = null; this.onCallMediaStarted = null; this.onCallConnected = null; this.onCallEnded = null; this.onCallFailed = null; this.onSIPInfoReceived = null; this.onInstantMessageReceived = null; var q = function (ao) { var an = {}; for (var am in ao) { if (am.substring(0, 2) == "X-" || am == "VI-CallData") { an[am] = ao[am] } } return an };
        var E = function () { S = 0; for (var am in Y) { S++ } };
        var D = function (am) {
            Y[am.id()] = am;
            E()
        };
        var P = function (am) { delete Y[am]; E() }.bind(this); U();
        var Q = function (am) {
            var ap = ""; var an = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
            for (var ao = 0; ao < am; ao++) {
                 ap += an.charAt(Math.floor(Math.random() * an.length))
            }
            return ap
        };
        var C = function () { H("Calls: " + JSON.stringify(Y)); H("PCs: " + JSON.stringify(af)) };
        this.muteMicrophone = function (am) { V = am; if (R) { F(N(R), !am) } };
        this.sendVideo = function (am) { X = am; if (R) { F(aj(R), am) } };
        this.mutePlayback = function (an) { r = an; for (var am in af) { af[am].updateSpeakerMuteState() } };
        this.setPlaybackVolume = function (an) { A = an; for (var am in af) { af[am].setPlaybackVolume(an) } };
        this.getCalls = function () { var an = []; for (var am in Y) { an.push(am) } return an };
        this.setLocalVideoSink = function(am) {
            G = am;
            if (R) {
                 o(am, R)
            }
        };
        this.setRemoteSinksContainerId = function (am) { I = am };
        this.stopLocalStream = function () { if (R) { R.stop() } }.bind(this);
        this.destroy = function () { this.disconnect(); this.stopLocalStream() }.bind(this);
        this.disconnect = function () { if (ag) { w(); ag.onclose = null; ag.close(); l() } };
        this.useAudioSource = function (ap, am, an, ao) { if (u) { aa = ap; this.requestMedia(ao, am, an, O) } }.bind(this);
        this.useVideoSource = function (ao, am, an) { if (u) { z = ao; this.requestMedia(true, am, an, true) } }.bind(this);
        this.setConstraints = function (ao, am, an) { x = ao; this.requestMedia(O, am, an, O) }.bind(this);
        this.requestMedia = function (ao, ap, an, am) {
            if (aa == null && z == null) {
                 var aq = { audio: true, video: ao === true ? true : false }
            }
            else {
                if (aa != null && z != null) {
                     var aq = { audio: { optional: [{ sourceId: aa }] }, video: { optional: [{ sourceId: z }] } }
                }
                else {
                    if (aa != null) {
                        var aq = { audio: { optional: [{ sourceId: aa }] }, video: ao === true ? true : false }
                    } else {
                         if (z != null) {
                              var aq = { audio: true, video: { optional: [{ sourceId: z }] } }
                         }
                    }
                }
            }
            if (x != null) {
                aq.video = new Object();
                if (typeof x.mandatory != "undefined") {
                     aq.video.mandatory = x.mandatory
                } if (typeof x.optional != "undefined") {
                      aq.video.optional = x.optional;
                      if (z != null) {
                          aq.video.optional.push({ sourceId: z })
                      }
                  } else {
                       if (z != null) {
                            aq.video.optional = [{ sourceId: z }]
                       }
                  }
            } if (R && am) { R.stop(); R = null } K(aq, function(at) {
                 if (R) { R.stop(); for (var ar in af) {
                                         af[ar].setLocalStream(null)
                 }
                 }
                 v("Media access granted"); R = at; F(N(R), !V); if (G) { o(G, at) }
                for (var ar in af) {
                 af[ar].setLocalStream(R)
                }
                if (typeof ap == "function")
                {
                     ap()
                }
            }.bind(this), function (ar) { v("Media access rejected: " + ar.name); if (typeof an == "function") { an(ar.name) } })
        }.bind(this);
        this.getRemoteParty = function(am) {
             if (Y[am]) {
                  return Y[am].getRemoteParty()
             }
            return null
        };
        this.getCallState = function(am) {
            if (Y[am]) {
                 return Y[am].getState()
            }
            return null
        };
        this.setCallActive = function(am, an) {
             if (Y[am]) {
                  return Y[am].setStreamsActive(an)
             }
        };
        this.isCallActive = function(am) {
             if (Y[am]) {
                  return Y[am].streamsAreActive()
             }
            return false
        };
        this.connectTo = function(an, ao, am) {
            if (al == h) {
                 ag = new WebSocket(ak + "://" + an + "/platform?version=2&client=" + (m ? "firefox" : "chrome") + "&referrer=" + encodeURIComponent(ao) + "&extra=" + encodeURIComponent(am) + "&video=" + (O === true ? "true" : "false") + "&q=" + Q(12));
                 al = a;
                 ag.onopen = p;
                 ag.onclose = w;
                 ag.onerror = y;
                 ag.onmessage = L
             } else {
                  v("Error: called connectTo while in state " + al)
             }
        }.bind(this);
        this.login = function (an, am) { if (al != i) { v("login called while in state " + al); return } n("login", [an, am]) };
        this.loginStage2 = function (an, am) { if (al != i) { v("loginStage2 called while in state " + al); return } n("loginStage2", [an, am]) };
        this.loginGenerateOneTimeKey = function (am) { if (al != i) { v("loginGenerateOneTimeKey called while in state " + al); return } n("loginGenerateOneTimeKey", [am]) };
        this.loginUsingOneTimeKey = function (an, am) { if (al != i) { v("loginUsingOneTimeKey called while in state " + al); return } n("loginUsingOneTimeKey", [an, am]) };
        this.setOperatorACDStatus = function (am) { if (al != i) { v("setOperatorACDStatus called while in state " + am); return } n("setOperatorACDStatus", [am]) };
        this.callTo = function (am, ao, ap, ar) {
            var aq = Q(36); var an = new ad(aq, g, am, "");
            Y[aq] = an;
            n("createCall", [-1, am, ao, aq, null, null, q(typeof ap == "undefined" ? {} : ap), ar]);
            D(an);
            return aq
        };
        this.hangupCall = function(an, ao) {
            var am = Y[an];
            if (am) {
                if (am.getState() == j) {
                    n("rejectCall", [an, true, q(ao)])
                } else {
                    n("disconnectCall", [an, q(ao)])
                }
            } else {
                 v("ERROR: trying to hangup unknown call " + an)
            }
        };
        this.rejectCall = function(an, ao, ap) {
            var am = Y[an];
            if (am) {
                if (am.getState() == j) {
                    n("rejectCall", [an, true, q(ap)])
                } else {
                    v("ERROR: trying to reject call " + an + " in state " + am.getState())
                }
            } else {
                 v("ERROR: trying to reject unknown call " + an)
            }
        };
        this.answerCall = function(an, ao) {
            var am = Y[an];
            if (am) {
                if (am.getState() == j) {
                    n("acceptCall", [an, q(ao)])
                } else {
                    v("ERROR: trying to answer call " + an + " in state " + am.getState())
                }
            } else {
                 v("ERROR: trying to answer unknown call " + an)
            }
        };
        this.sendDigit = function(an, ao) {
            var am = Y[an];
            if (am) {
                if (am.getState() == f) {
                    n("sendDTMF", [an, ao])
                } else {
                    v("ERROR: trying to send digit to call " + an + " in state " + am.getState())
                }
            } else {
                 v("ERROR: trying to send digit to unknown call " + an)
            }
        };
        this.sendSIPInfo = function(aq, ap, an, am, ar) {
            var ao = Y[aq];
            if (ao) {
                if (ao.getState() == f) {
                    n("sendSIPInfo", [aq, ap, an, am, q(ar)])
                } else {
                    v("ERROR: trying to send SIP Info to call " + aq + " in state " + ao.getState())
                }
            } else {
                 v("ERROR: trying to send SIP Info to unknown call " + aq)
            }
        };
        this.sendInstantMessage = function (am, an) { this.sendSIPInfo(am, "application", "zingaya-im", an, {}) };
        this.getVideoElementId = function (an) {
            var am = Y[an];
            if (am) { return am.getVideoElementId() }
            else { v("ERROR: No such call " + an) }
        };
        var l = function () {
            for (var am in af) {
                af[am].close()
            }
            af = {}; Y = {}; S = 0; if (T) { clearTimeout(T) } if (s) { clearTimeout(s) }
        }; var y = function (am) { v("WS error: " + am); al = h; l(); if (typeof this.onConnectionFailed == "function") { this.onConnectionFailed(am) } }.bind(this); var p = function () { al = c; v("WS connected") }.bind(this); var w = function () { v("WS closed"); var an = (al == i); var am = an ? this.onConnectionClosed : this.onConnectionFailed; al = h; l(); if (typeof am == "function") { am("Connection closed") } }.bind(this); var ai = function () { T = null; n("__ping", []); s = setTimeout(function () { s = null; v("WS closed"); var an = (al == i); var am = an ? this.onConnectionClosed : this.onConnectionFailed; al = h; l(); if (typeof am == "function") { am("Connection closed") } }.bind(this), Z) }.bind(this);
        var W = {
            __createPC: function (ap, ao) {
                if (af[ap]) { af[ap].close() } var am = new ab(ap, ao);
                if (Y[ap]) { am.setStreamsActive(Y[ap].streamsAreActive()) }
                af[ap] = am;
                am.setLocalStream(R);
                am.start();
                var an = Y[ap];
                if (an) {
                     Y[ap].setPeerConnection(am); am.setCall(an)
                }
            },
            __destroyPC: function (am) { if (af[am]) { af[am].close(); delete af[am] } },
            __pong: function () { if (s) { clearTimeout(s); s = null; T = setTimeout(ai, Z) } },
            __connectionSuccessful: function() {
                 if (al == c) {
                     al = i;
                     if (typeof this.onConnectionEstablished == "function") {
                          this.onConnectionEstablished()
                     }
                     T = setTimeout(ai, Z)
                 }
            },
            loginSuccessful: function (am) { if (typeof this.onLoginSuccessful == "function") {
                                                  this.onLoginSuccessful(am)
            }
            },
            loginFailed: function(an, am) {
                 if (typeof this.onLoginFailed == "function") {
                      this.onLoginFailed({ errorCode: an, oneTimeKey: am })
                 }
            },
            handleConnectionConnected: function (an, ao) {
                var am = Y[an];
                if (am) {

                    if (am.getState() == g || am.getState() == j) {
                        am.setState(f);
                        if (typeof this.onCallConnected == "function") {
                             this.onCallConnected(an, ao)
                        }
                    } else { v("WARNING: received handleConnectionConnected for call: " + an + " in invalid state: " + am.getState()) }
                }
                else { v("WARNING: received handleConnectionConnected for unknown call: " + an) }
            },
            stopRinging: function (an) {
                var am = Y[an];
                if (am) {
                                                             if (typeof this.onCallMediaStarted == "function") {
                                                                 this.onCallMediaStarted(an)
                                                             }
                                                         } else {
                                                              v("WARNING: received stopRinging for unknown call: " + an)
                                                         }
            },
            handleConnectionDisconnected: function (an, ao) {
                var am = Y[an];
                if (am) {
                    am.setState(e);
                    if (typeof this.onCallEnded == "function") {
                        this.onCallEnded(an, ao)
                    }
                    P(an)
                } else {
                     v("WARNING: received handleConnectionDisconnected for unknown call: " + an)
                }
            },
            handleConnectionFailed: function(an, ao, ap, aq) {
                var am = Y[an];
                if (am) {
                    if (am.getState() == g) {
                        am.setState(e);
                        if (typeof this.onCallFailed == "function") {
                            this.onCallFailed(an, ao, ap, aq)
                        }
                        P(an)
                    } else {
                         v("WARNING: received handleConnectionFailed for call: " + an + " in invalid state: " + am.getState())
                    }
                }
                else { v("WARNING: received handleConnectionFailed for unknown call: " + an) }
            },
            handleRingOut: function (an) {
                var am = Y[an];
                if (am) {
                                                                if (am.getState() == g) {
                                                                    if (typeof this.onCallRinging == "function") {
                                                                        this.onCallRinging(an)
                                                                    }
                                                                } else {
                                                                     v("WARNING: received handleRingOut for call: " + an + " in invalid state: " + am.getState())
                                                                }
                }
                else { v("WARNING: received handleRingOut for unknown call: " + an) }
            },
            handleIncomingConnection: function (aq, ao, am, ap) {
                var an = new ad(aq, j, ao, am);
                D(an);
                if (typeof this.onIncomingCall == "function") {
                    this.onIncomingCall(aq, ao, am, ap)
                } else {
                     this.rejectCall(aq, 486); v("WARNING: Received incoming call while no handler was specified")
                }
            },
            handleSIPInfo: function (ap, ao, ar, am, aq) {
                var an = Y[ap];
                if (an) { if (an.getState() == f || an.getState() == g || an.getState() == j) {
                              if (ao == "application" && ar == "zingaya-im") {
                                  if (typeof this.onInstantMessageReceived == "function") {
                                      this.onInstantMessageReceived(ap, am)
                                  }
                              } else {
                                  if (typeof this.onSIPInfoReceived == "function") {
                                      this.onSIPInfoReceived(ap, ao + "/" + ar, am, aq)
                                  }
                              }
                          } else {
                               v("WARNING: received handleSIPInfo for call: " + ap + " in invalid state: " + an.getState())
                          } } else { v("WARNING: received handleSIPInfo for unknown call: " + ap) }
            },
            handleSIPEvent: function () { }
        };
        var L = function (ao) {
            var am = JSON.parse(ao.data);
            var an = am.name;
            var ap = am.params;
            H("Called local function " + an + " with params " + JSON.stringify(ap));
            if (typeof W[an] == "function") {
                W[an].apply(this, ap)
            } else {
                 v("Unknown function called: " + an)
            }
            C()
        }.bind(this); var J = function (an, am) { if (typeof mozRTCSessionDescription == "function") { return new mozRTCSessionDescription({ type: an, sdp: am }) } else { return new RTCSessionDescription({ type: an, sdp: am }) } }; var ad = function (an, am, av, au) {
            var at = an; var ao = am; var ar = av; var aw = au; var aq; var ap = true; this.id = function () { return at };
            this.getRemoteParty = function () { return ar };
            this.getState = function () { return ao };
            this.setState = function (ax) { ao = ax };
            this.getDisplayName = function () { return aw };
            this.setPeerConnection = function (ax) { aq = ax };
            this.getPeerConnection = function () { return aq };
            this.streamsAreActive = function () { return ap };
            this.setStreamsActive = function (ax) { ap = ax; if (af[at]) { af[at].setStreamsActive(ax) } };
            this.getVideoElementId = function() {
                 return aq.getVideoElementId()
            }
        }; var ab = function (aI, au) {
            var am = new ae(null, { optional: [{ DtlsSrtpKeyAgreement: "true" }] });
            var aq = aI;
            var aD = function (aN) { v("PC " + aq + ": " + aN) };
            var aL = function (aN) { H("PC " + aq + ": " + aN) };
            var aE;
            this.setCall = function (aN) { aE = aN };
            this.getCall = function () { return aE }; var aH; var aC;
            aH = document.createElement("audio"); aH.id = "vi_audio_" + aq;
            aH.autoplay = "true"; aH.volume = A;
            document.body.appendChild(aH);
            if (O) {
                aC = document.createElement("video");
                aC.id = "vi_video_" + aq; aC.autoplay = "true"; aC.width = 400; aC.height = 300;
                aC.style.display = "none"; aC.volume = A;
                var aG = I ? document.getElementById(I) : document.body; aG.appendChild(aC)
            }
            var aA = J("offer", au);
            var az = null; var aB = false; var at = false; var an = null; var aF = null; var aM = null; var aJ = false;
            var ao = false; var aK = true;
            rtpCandidateGenerated = false; rtpVideoCandidateGenerated = false; rtcpCandidateGenerated = false;
            rtcpVideoCandidateGenerated = false;
            this.getRemoteAudioStream = function () { return an };
            this.getRemoteVideoStream = function () {
                 return aF
            };
            this.getVideoElementId = function() {
                 return aC ? aC.id : null
            };
            this.setLocalStream = function (aO) {
                if (ao) { return }
                if (aM) {
                     am.removeStream(aM); aM = null
                }
                if (aO) {
                    aM = aO;
                    var aP = typeof aO.getAudioTracks == "undefined" ? aO.audioTracks : aO.getAudioTracks();
                    var aN = typeof aO.getVideoTracks == "undefined" ? aO.videoTracks : aO.getVideoTracks();
                    aM = aO; am.addStream(aM);
                    F(aM.getAudioTracks(), !V);
                    F(aM.getVideoTracks(), X)
                }
            };
            var ar = function() {
                 if (ao) {
                      return
                 }
                 aD("Sending local answer");
                 aL("Local answer: " + az.sdp);
                n("__confirmPC", [aq, az.sdp])
            };
            var ap = function(aN) {
                 if (ao) {
                      return
                 }
                 aB = aN.sdp.indexOf("a=rtcp-mux") != -1;
                am.setLocalDescription(aN, function() {
                     az = aN; if (aN.sdp.indexOf("candidate") != -1) { at = true; ar() }
                },
                    function (aO) { aD("ERROR: " + aO) })
            }.bind(this);
            var aw = function() {
                if (ao) { return } aL("Calling createAnswer");
                am.createAnswer(ap, function (aN) { v("ERROR: " + aN) })
            };
            var av = function (aO) {
                if (ao) { return }
                if (aO.candidate) {
                    aL("ICE candidate: " + aO.candidate.candidate);
                    var aN = aO.candidate.candidate;
                    if (aN.indexOf("1 udp") != -1) {
                         if (aO.candidate.sdpMid == "audio") {
                             rtpCandidateGenerated = true
                         } else {
                              rtpVideoCandidateGenerated = true
                         }
                    }
                    if (aN.indexOf("2 udp") != -1) {
                         if (aO.candidate.sdpMid == "audio") {
                             rtcpCandidateGenerated = true
                         } else {
                              rtcpVideoCandidateGenerated = true
                         }
                    }
                    
                    if (rtpCandidateGenerated && (rtcpCandidateGenerated || aB) && ((rtpVideoCandidateGenerated && (rtcpVideoCandidateGenerated || aB)) || !O)) {
                        aJ = true;
                        if (!at) {
                            at = true;
                            am.createAnswer(function (aP) { az = aP; ar() })
                        }
                    }
                } else { aD("End of candidates."); if (!aJ) { } }
            };
            var ay = function() {
                if (ao) {
                     aD("Renegotiation requested on closed PeerConnection"); return
                }
                if (az == null) {
                     aD("Renegotiation needed, but no local SD, skipping"); return
                }
                if (am.iceConnectionState != "connected" && am.iceConnectionState != "completed") {
                    aD("Renegotiation requested while ice state is " + am.iceConnectionState + ". Postponing");
                    setTimeout(ay, 100); return
                }
                if (M) {
                    aD("Renegotiation in progress. Queueing")
                } else {
                     aD("Renegotiation started")
                }
                M = true;
                am.setRemoteDescription(aA, function() {
                    if (ao) { M = false; return }
                    am.createAnswer(function (aN) {
                        if (ao) {
                             M = false; return
                        }
                        az = aN;
                        am.setLocalDescription(az, function() {
                            M = false;
                            aD("Renegotiation successful")
                        }, function(aO) {
                             M = false; aD("ERROR: " + aO)
                        })
                    },
                        function (aN) {
                         M = false; aD("ERROR: " + aN)
                        })
                },
                    function (aN) {
                     M = false; aD("ERROR: " + aN)
                })
            };
            var ax = function (aO) {
                var aN = aj(aO.stream).length > 0;
                aD("Remote stream added " + aO.stream.id + " " + (aN ? "video" : "audio"));
                if (aN) {
                    aF = aO.stream
                } else {
                    an = aO.stream
                }
                if (aN) {
                    if (aC) {
                        o(aC, aO.stream)
                    }
                } else {
                     o(aH, aO.stream)
                }
                this.setStreamsActive(aK)
            };
            this.setPlaybackVolume = function (aN) { if (aH) { aH.volume = aN } if (aC) { aC.volume = aN } }; this.streamsAreActive = function () { return aK }; this.setStreamsActive = function (aN) { aK = aN; F(N(an), aN && !r); F(N(aF), aN && !r); F(aj(aF), aN); n("__muteLocal", [aq, !aN]) }.bind(this); this.updateMicrophoneMuteState = function () { }; this.updateSpeakerMuteState = function () { if (an) { F(N(an), aK && !r) } }; this.activateStreams = function () { if (ao) { return } this.setStreamsActive(true) }; this.deactivateStreams = function () { if (ao) { return } this.setStreamsActive(false) };
            am.onicecandidate = av.bind(this);
            am.onaddstream = ax.bind(this);
            am.onnegotiationneeded = ay.bind(this);
            this.start = function () { if (ao) { return } am.setRemoteDescription(aA, function () { aw() }, function (aN) { v("ERROR: " + aN) }) }; this.close = function () { ao = true; am.close(); if (aH) { aH.parentNode.removeChild(aH) } if (aC) { aC.parentNode.removeChild(aC) } }
        };
        var n = function (am, an) { H("Called remote function " + am + " with params " + JSON.stringify(an)); if (ag) { if (typeof Array.prototype.toJSON != "undefined" || typeof String.prototype.toJSON != "undefined") { ag.send(VoxImplantJSON.stringify({ name: am, params: an })) } else { ag.send(JSON.stringify({ name: am, params: an })) } } else { v("ERROR: can't call remote function when not connected") } C() }
    }
})(window.VoxImplant = window.VoxImplant || {});