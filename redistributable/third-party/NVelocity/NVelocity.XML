<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NVelocity</name>
    </assembly>
    <members>
        <member name="T:NVelocity.App.Events.EventCartridge">
            <summary>
            'Package' of event handlers...
            </summary>
        </member>
        <member name="M:NVelocity.App.Events.EventCartridge.ReferenceInsert(System.Collections.Stack,System.String,System.Object)">
            <summary>
            Called during Velocity merge before a reference value will
            be inserted into the output stream.
            </summary>
            <param name="referenceStack">the stack of objects used to reach this reference</param>
            <param name="reference">reference from template about to be inserted</param>
            <param name="value"> value about to be inserted (after toString() )</param>
            <returns>
            Object on which toString() should be called for output.
            </returns>
        </member>
        <member name="M:NVelocity.App.Events.EventCartridge.ShouldLogOnNullSet(System.String,System.String)">
            <summary>
            Called during Velocity merge to determine if when
            a #set() results in a null assignment, a warning
            is logged.
            </summary>
            <returns>true if to be logged, false otherwise</returns>
        </member>
        <member name="M:NVelocity.App.Events.EventCartridge.HandleMethodException(System.Type,System.String,System.Exception)">
            <summary>
            Called during Velocity merge if a reference is null
            </summary>
            <param name="claz">Class that is causing the exception</param>
            <param name="method">method called that causes the exception</param>
            <param name="e">Exception thrown by the method</param>
            <returns>Object to return as method result</returns>
            <exception cref="T:System.Exception">exception to be wrapped and propogated to app</exception>
        </member>
        <member name="M:NVelocity.App.Events.EventCartridge.AttachToContext(NVelocity.Context.IContext)">
            <summary>
            Attached the EventCartridge to the context
            </summary>
            <param name="context">context to attach to</param>
            <returns>true if successful, false otherwise</returns>
        </member>
        <member name="T:NVelocity.App.Events.EventHandler">
             <summary>  Base interface for all event handlers
             *
             </summary>
             <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
             </author>
             <version> $Id: EventHandler.cs,v 1.3 2003/10/27 13:54:07 corts Exp $
            
             </version>
        </member>
        <member name="T:NVelocity.App.Events.MethodExceptionEventHandler">
            <summary>
            Called when a method throws an exception.  This gives the
            application a chance to deal with it and either
            return something nice, or throw.
            
            Please return what you want rendered into the output stream.
            </summary>
        </member>
        <member name="T:NVelocity.App.Events.NullSetEventHandler">
            <summary>
            Lets an app approve / veto writing a log message when RHS of #set() is null.
            </summary>
        </member>
        <member name="P:NVelocity.App.Events.NullSetEventArgs.LHS">
            <summary>
            reference literal of left-hand-side of set statement
            </summary>
        </member>
        <member name="P:NVelocity.App.Events.NullSetEventArgs.RHS">
            <summary>
            reference literal of right-hand-side of set statement
            </summary>
        </member>
        <member name="T:NVelocity.App.Events.ReferenceInsertionEventHandler">
            <summary>
            Reference 'Stream insertion' event handler.  Called with object
            that will be inserted into stream via value.toString().
            Make sure you return an Object that will toString() without throwing an exception.
            </summary>
        </member>
        <member name="T:NVelocity.App.Tools.VelocityFormatter">
            <summary>
            Formatting tool for inserting into the Velocity WebContext.  Can
            format dates or lists of objects.
            
            <para>Here's an example of some uses:
            <code><pre>
            $formatter.formatShortDate($object.Date)
            $formatter.formatLongDate($db.getRecord(232).getDate())
            $formatter.formatArray($array)
            $formatter.limitLen(30, $object.Description)
            </pre></code>
            </para>
            </summary>
            <author><a href="mailto:sean@somacity.com">Sean Legassick</a></author>
            <author><a href="mailto:dlr@collab.net">Daniel Rall</a></author>
            <version>$Id: VelocityFormatter.cs,v 1.5 2003/11/05 04:15:02 corts Exp $</version>
        </member>
        <member name="M:NVelocity.App.Tools.VelocityFormatter.#ctor(NVelocity.Context.IContext)">
            <summary>
            Constructor needs a backpointer to the context.
            </summary>
            <param name="context">A Context.</param>
        </member>
        <member name="M:NVelocity.App.Tools.VelocityFormatter.FormatShortDate(System.DateTime)">
            <summary>
            Formats a date in 'short' style.
            </summary>
            <param name="date">A Date.</param>
            <returns>A String.</returns>
        </member>
        <member name="M:NVelocity.App.Tools.VelocityFormatter.FormatLongDate(System.DateTime)">
            <summary>
            Formats a date in 'long' style.
            </summary>
            <param name="date">A Date.</param>
            <returns>A String.</returns>
        </member>
        <member name="M:NVelocity.App.Tools.VelocityFormatter.FormatShortDateTime(System.DateTime)">
            <summary>
            Formats a date/time in 'short' style.
            </summary>
            <param name="date">A Date.</param>
            <returns>A String.</returns>
        </member>
        <member name="M:NVelocity.App.Tools.VelocityFormatter.FormatLongDateTime(System.DateTime)">
            <summary>
            Formats a date/time in 'long' style.
            </summary>
            <param name="date">A Date.</param>
            <returns>A String.</returns>
        </member>
        <member name="M:NVelocity.App.Tools.VelocityFormatter.FormatArray(System.Object)">
            <summary>
            Formats an array into the form "A, B and C".
            </summary>
            <param name="array">An Object.</param>
            <returns>A String.</returns>
        </member>
        <member name="M:NVelocity.App.Tools.VelocityFormatter.FormatArray(System.Object,System.String)">
            <summary> 
            Formats an array into the form
            "A&lt;delim&gt;B&lt;delim&gt;C".
            </summary>
            <param name="array">An Object.</param>
            <param name="delim">A String.</param>
            <returns>A String.</returns>
        </member>
        <member name="M:NVelocity.App.Tools.VelocityFormatter.FormatArray(System.Object,System.String,System.String)">
            <summary>
            Formats an array into the form
            "A&lt;delim&gt;B&lt;finaldelim&gt;C".
            </summary>
            <param name="array">An Object.</param>
            <param name="delim">A String.</param>
            <param name="finaldelim">A String.</param>
            <returns>A String.</returns>
        </member>
        <member name="M:NVelocity.App.Tools.VelocityFormatter.FormatVector(System.Collections.IList)">
            <summary>
            Formats a list into the form "A, B and C".
            </summary>
            <param name="list">A list.</param>
            <returns>A String.</returns>
        </member>
        <member name="M:NVelocity.App.Tools.VelocityFormatter.FormatVector(System.Collections.IList,System.String)">
            <summary>
            Formats a list into the form "A&lt;delim&gt;B&lt;delim&gt;C".
            </summary>
            <param name="list">A list.</param>
            <param name="delim">A String.</param>
            <returns>A String.</returns>
        </member>
        <member name="M:NVelocity.App.Tools.VelocityFormatter.FormatVector(System.Collections.IList,System.String,System.String)">
            <summary>
            Formats a list into the form
            "Adelim&gt;B&lt;finaldelim&gt;C".
            </summary>
            <param name="list">A list.</param>
            <param name="delim">A String.</param>
            <param name="finaldelim">A String.</param>
            <returns>A String.</returns>
        </member>
        <member name="M:NVelocity.App.Tools.VelocityFormatter.LimitLen(System.Int32,System.String)">
            <summary>
            Limits 'string' to 'maxlen' characters.  If the string gets
            curtailed, "..." is appended to it.
            </summary>
            <param name="maxlen">An int with the maximum length.</param>
            <param name="value">A String.</param>
            <returns>A String.</returns>
        </member>
        <member name="M:NVelocity.App.Tools.VelocityFormatter.LimitLen(System.Int32,System.String,System.String)">
            <summary>
            Limits 'string' to 'maxlen' character.  If the string gets
            curtailed, 'suffix' is appended to it.
            </summary>
            <param name="maxlen">An int with the maximum length.</param>
            <param name="value">A String.</param>
            <param name="suffix">A String.</param>
            <returns>A String.</returns>
        </member>
        <member name="M:NVelocity.App.Tools.VelocityFormatter.MakeAlternator(System.String,System.String,System.String)">
            <summary>
            Makes an alternator object that alternates between two values.
            
            <para>Example usage in a Velocity template:
            
            <code>
            &lt;table&gt;
            $formatter.makeAlternator("rowcolor", "#c0c0c0", "#e0e0e0")
            #foreach $item in $items
            &lt;tr&gt;&lt;td bgcolor="$rowcolor"&gt;$item.Name&lt;/td&gt;&lt;/tr&gt;
            $rowcolor.alternate()
            #end
            &lt;/table&gt;
            </code>
            </para>
            </summary>
            <param name="name">The name for the alternator int the context.</param>
            <param name="alt1">The first alternate.</param>
            <param name="alt2">The second alternate.</param>
            <returns>The newly created instance.</returns>
        </member>
        <member name="M:NVelocity.App.Tools.VelocityFormatter.MakeAlternator(System.String,System.String,System.String,System.String)">
            <summary>
            Makes an alternator object that alternates between three values.
            </summary>
        </member>
        <member name="M:NVelocity.App.Tools.VelocityFormatter.MakeAlternator(System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Makes an alternator object that alternates between four values.
            </summary>
        </member>
        <member name="M:NVelocity.App.Tools.VelocityFormatter.MakeAutoAlternator(System.String,System.String,System.String)">
            <summary>
            Makes an alternator object that alternates between two values
            automatically.
            </summary>
        </member>
        <member name="M:NVelocity.App.Tools.VelocityFormatter.IsNull(System.Object,System.Object)">
            <summary>
            Returns a default value if the object passed is null.
            </summary>
        </member>
        <member name="T:NVelocity.App.Tools.VelocityFormatter.VelocityAlternator">
            <summary>
            Class that returns alternating values in a template.  It stores
            a list of alternate Strings, whenever alternate() is called it
            switches to the next in the list.  The current alternate is
            retrieved through toString() - i.e. just by referencing the
            object in a Velocity template.  For an example of usage see the
            makeAlternator() method below.
            </summary>
        </member>
        <member name="M:NVelocity.App.Tools.VelocityFormatter.VelocityAlternator.#ctor(System.String[])">
            <summary>
            Constructor takes an array of Strings.
            </summary>
            <param name="alternates">A String[].
            </param>
        </member>
        <member name="M:NVelocity.App.Tools.VelocityFormatter.VelocityAlternator.Alternate">
            <summary>
            Alternates to the next in the list.
            </summary>
            <returns>The current alternate in the sequence.</returns>
        </member>
        <member name="M:NVelocity.App.Tools.VelocityFormatter.VelocityAlternator.ToString">
            <summary>
            Returns the current alternate.
            </summary>
            <returns>A String.</returns>
        </member>
        <member name="T:NVelocity.App.Tools.VelocityFormatter.VelocityAutoAlternator">
            <summary>
            As VelocityAlternator, but calls <code>alternate()</code>
            automatically on rendering in a template.
            </summary>
        </member>
        <member name="M:NVelocity.App.Tools.VelocityFormatter.VelocityAutoAlternator.#ctor(System.String[])">
             <summary>
             Constructor takes an array of Strings.
             </summary>
             <param name="alternates">A String[].
            
             </param>
        </member>
        <member name="M:NVelocity.App.Tools.VelocityFormatter.VelocityAutoAlternator.ToString">
            <summary>
            Returns the current alternate, and automatically alternates
            to the next alternate in its sequence (trigged upon
            rendering).
            </summary>
            <returns>The current alternate in the sequence.</returns>
        </member>
        <member name="T:NVelocity.App.FieldMethodizer">
             <summary>
             <para>This is a small utility class allow easy access to static fields in a class,
             such as string constants.  Velocity will not introspect for class
             fields (and won't in the future :), but writing setter/getter methods to do
             this really is a pain,  so use this if you really have
             to access fields.</para>
            
             <para>The idea it so enable access to the fields just like you would in Java.
             For example, in Java, you would access a static field like
             <blockquote><pre>
             MyClass.STRING_CONSTANT
             </pre></blockquote>
             and that is the same thing we are trying to allow here.</para>
            
             <para>So to use in your Java code, do something like this :
             <blockquote><pre>
             context.put("runtime", new FieldMethodizer( "NVelocity.Runtime.Runtime" ));
             </pre></blockquote>
             and then in your template, you can access any of your static fields in this way :
             <blockquote><pre>
             $runtime.RUNTIME_LOG_WARN_STACKTRACE
             </pre></blockquote></para>
            
             <para>Right now, this class only methodizes <code>public static</code> fields.  It seems
             that anything else is too dangerous.  This class is for convenience accessing
             'constants'.  If you have fields that aren't <code>static</code> it may be better
             to handle them by explicitly placing them into the context.</para>
             </summary>
             <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
             </author>
             <version>$Id: FieldMethodizer.cs,v 1.3 2003/10/27 13:54:07 corts Exp $</version>
        </member>
        <member name="F:NVelocity.App.FieldMethodizer.fieldHash">
            <summary>
            Hold the field objects by field name
            </summary>
        </member>
        <member name="F:NVelocity.App.FieldMethodizer.classHash">
            <summary>
            Hold the class objects by field name
            </summary>
        </member>
        <member name="M:NVelocity.App.FieldMethodizer.#ctor">
            <summary>
            Allow object to be initialized without any data. You would use
            addObject() to add data later.
            </summary>
        </member>
        <member name="M:NVelocity.App.FieldMethodizer.#ctor(System.String)">
            <summary>
            Constructor that takes as it's arg the name of the class
            to methodize.
            </summary>
            <param name="s">Name of class to methodize.</param>
        </member>
        <member name="M:NVelocity.App.FieldMethodizer.#ctor(System.Object)">
            <summary>
            Constructor that takes as it's arg a living
            object to methodize.  Note that it will still
            only methodized the public static fields of
            the class.
            </summary>
            <param name="o">object to methodize.</param>
        </member>
        <member name="M:NVelocity.App.FieldMethodizer.AddObject(System.String)">
            <summary>
            Add the Name of the class to methodize
            </summary>
        </member>
        <member name="M:NVelocity.App.FieldMethodizer.AddObject(System.Object)">
            <summary> Add an Object to methodize
            </summary>
        </member>
        <member name="M:NVelocity.App.FieldMethodizer.Get(System.String)">
            <summary>
            Accessor method to get the fields by name.
            </summary>
            <param name="fieldName">Name of static field to retrieve</param>
            <returns>The value of the given field.</returns>
        </member>
        <member name="M:NVelocity.App.FieldMethodizer.Inspect(System.Type)">
            <summary>  Method that retrieves all public static fields
            in the class we are methodizing.
            </summary>
        </member>
        <member name="T:NVelocity.App.Velocity">
            <summary>
            This class provides  services to the application
            developer, such as :
            <ul>
            <li> Simple Velocity Runtime engine initialization methods.</li>
            <li> Functions to apply the template engine to streams and strings</li>
            to allow embedding and dynamic template generation.
            <li> Methods to access Velocimacros directly.</li>
            </ul>
            <br/><br/>
            While the most common way to use NVelocity is via templates, as
            Velocity is a general-purpose template engine, there are other
            uses that NVelocity is well suited for, such as processing dynamically
            created templates, or processing content streams.
            <br/><br/>
            The methods herein were developed to allow easy access to the NVelocity
            facilities without direct spelunking of the internals.  If there is
            something you feel is necessary to add here, please, send a patch.
            </summary>
        </member>
        <member name="M:NVelocity.App.Velocity.Init">
            <summary>
            initialize the NVelocity runtime engine, using the default
            properties of the NVelocity distribution
            </summary>
        </member>
        <member name="M:NVelocity.App.Velocity.Init(System.String)">
            <summary>
            initialize the Velocity runtime engine, using default properties
            plus the properties in the properties file passed in as the arg
            </summary>
            <param name="propsFilename">
            file containing properties to use to initialize
            the Velocity runtime
            </param>
        </member>
        <member name="M:NVelocity.App.Velocity.Init(Commons.Collections.ExtendedProperties)">
            <summary>
            initialize the Velocity runtime engine, using default properties
            plus the properties in the passed in java.util.Properties object
            </summary>
            <param name="p">
            Proprties object containing initialization properties
            </param>
        </member>
        <member name="M:NVelocity.App.Velocity.SetProperty(System.String,System.Object)">
            <summary>
            Set a Velocity Runtime property.
            </summary>
            <param name="key">key</param>
            <param name="value">value</param>
        </member>
        <member name="M:NVelocity.App.Velocity.AddProperty(System.String,System.Object)">
            <summary>
            Add a Velocity Runtime property.
            </summary>
            <param name="key">key</param>
            <param name="value">value</param>
        </member>
        <member name="M:NVelocity.App.Velocity.ClearProperty(System.String)">
            <summary>
            Clear a NVelocity Runtime property.
            </summary>
            <param name="key">of property to clear</param>
        </member>
        <member name="M:NVelocity.App.Velocity.SetExtendedProperties(Commons.Collections.ExtendedProperties)">
            <summary>
            Set an entire configuration at once. This is
            useful in cases where the parent application uses
            the ExtendedProperties class and the velocity configuration
            is a subset of the parent application's configuration.
            </summary>
        </member>
        <member name="M:NVelocity.App.Velocity.GetProperty(System.String)">
            <summary>
            Get a Velocity Runtime property.
            </summary>
            <param name="key">property to retrieve</param>
            <returns>property value or null if the property not currently set</returns>
        </member>
        <member name="M:NVelocity.App.Velocity.Evaluate(NVelocity.Context.IContext,System.IO.TextWriter,System.String,System.String)">
            <summary>
            renders the input string using the context into the output writer.
            To be used when a template is dynamically constructed, or want to use
            Velocity as a token replacer.
            </summary>
            <param name="context">context to use in rendering input string</param>
            <param name="writer"> Writer in which to render the output</param>
            <param name="logTag"> string to be used as the template name for log messages in case of error</param>
            <param name="instring">input string containing the VTL to be rendered</param>
            <returns>true if successful, false otherwise.  If false, see Velocity runtime log</returns>
        </member>
        <member name="M:NVelocity.App.Velocity.Evaluate(NVelocity.Context.IContext,System.IO.TextWriter,System.String,System.IO.Stream)">
            <summary>
            Renders the input stream using the context into the output writer.
            To be used when a template is dynamically constructed, or want to
            use Velocity as a token replacer.
            </summary>
            <param name="context">context to use in rendering input string</param>
            <param name="writer"> Writer in which to render the output</param>
            <param name="logTag"> string to be used as the template name for log messages in case of error</param>
            <param name="instream">input stream containing the VTL to be rendered</param>
            <returns>true if successful, false otherwise.  If false, see Velocity runtime log</returns>
        </member>
        <member name="M:NVelocity.App.Velocity.Evaluate(NVelocity.Context.IContext,System.IO.TextWriter,System.String,System.IO.TextReader)">
            <summary>
            Renders the input reader using the context into the output writer.
            To be used when a template is dynamically constructed, or want to
            use Velocity as a token replacer.
            </summary>
            <param name="context">context to use in rendering input string</param>
            <param name="writer"> Writer in which to render the output</param>
            <param name="logTag"> string to be used as the template name for log messages in case of error</param>
            <param name="reader">Reader containing the VTL to be rendered</param>
            <returns>true if successful, false otherwise.  If false, see Velocity runtime log</returns>
        </member>
        <member name="M:NVelocity.App.Velocity.InvokeVelocimacro(System.String,System.String,System.String[],NVelocity.Context.IContext,System.IO.TextWriter)">
            <summary>
            Invokes a currently registered Velocimacro with the parms provided
            and places the rendered stream into the writer.
            
            Note : currently only accepts args to the VM if they are in the context.
            </summary>
            <param name="vmName">name of Velocimacro to call</param>
            <param name="logTag">string to be used for template name in case of error</param>
            <param name="parameters">args used to invoke Velocimacro. In context key format :
            eg  "foo","bar" (rather than "$foo","$bar")
            </param>
            <param name="context">Context object containing data/objects used for rendering.</param>
            <param name="writer"> Writer for output stream</param>
            <returns>true if Velocimacro exists and successfully invoked, false otherwise.</returns>
        </member>
        <member name="M:NVelocity.App.Velocity.MergeTemplate(System.String,NVelocity.Context.IContext,System.IO.TextWriter)">
            <summary>
            merges a template and puts the rendered stream into the writer
            </summary>
            <param name="templateName">name of template to be used in merge</param>
            <param name="context"> filled context to be used in merge</param>
            <param name="writer"> writer to write template into</param>
            <returns>true if successful, false otherwise.  Errors logged to velocity log.</returns>
        </member>
        <member name="M:NVelocity.App.Velocity.MergeTemplate(System.String,System.String,NVelocity.Context.IContext,System.IO.TextWriter)">
            <summary>
            merges a template and puts the rendered stream into the writer
            </summary>
            <param name="templateName">name of template to be used in merge</param>
            <param name="encoding">encoding used in template</param>
            <param name="context"> filled context to be used in merge</param>
            <param name="writer"> writer to write template into</param>
            <returns>true if successful, false otherwise.  Errors logged to velocity log</returns>
        </member>
        <member name="M:NVelocity.App.Velocity.GetTemplate(System.String)">
            <summary>
            Returns a <code>Template</code> from the Velocity
            resource management system.
            </summary>
            <param name="name">The file name of the desired template.
            </param>
            <returns>    The template.
            @throws ResourceNotFoundException if template not found
            from any available source.
            @throws ParseErrorException if template cannot be parsed due
            to syntax (or other) error.
            @throws Exception if an error occurs in template initialization
            </returns>
        </member>
        <member name="M:NVelocity.App.Velocity.GetTemplate(System.String,System.String)">
            <summary>
            Returns a <code>Template</code> from the Velocity
            resource management system.
            </summary>
            <param name="name">The file name of the desired template.</param>
            <param name="encoding">The character encoding to use for the template.</param>
            <returns>The <see cref="T:NVelocity.Template"/> instance.</returns>
            <exception cref="T:NVelocity.Exception.ResourceNotFoundException">
            If template is not found from any available source.
            </exception>
            <exception cref="T:NVelocity.Exception.ParseErrorException">
            If template cannot be parsed due to syntax (or other) error.
            </exception>
            <exception cref="T:System.Exception">
            If an error occurs in template initialization.
            </exception>
        </member>
        <member name="M:NVelocity.App.Velocity.ResourceExists(System.String)">
            <summary>
            <p>Determines whether a resource is accessable via the
            currently configured resource loaders. <see cref="T:NVelocity.Runtime.Resource.Resource"/>
            is the generic description of templates, static content, etc.</p>
            
            <p>Note that the current implementation will <b>not</b> change
            the state of the system in any real way - so this cannot be
            used to pre-load the resource cache, as the previous
            implementation did as a side-effect.</p>
            </summary>
            <param name="templateName"> name of the template to search for</param>
            <returns>Whether the resource was located.</returns>
        </member>
        <member name="M:NVelocity.App.Velocity.Warn(System.Object)">
            <summary>
            Log a warning message.
            </summary>
            <param name="message">message to log
            </param>
        </member>
        <member name="M:NVelocity.App.Velocity.Info(System.Object)">
            <summary>
            Log an info message.
            </summary>
            <param name="message">message to log</param>
        </member>
        <member name="M:NVelocity.App.Velocity.Error(System.Object)">
            <summary>
            Log an error message.
            </summary>
            <param name="message">message to log</param>
        </member>
        <member name="M:NVelocity.App.Velocity.Debug(System.Object)">
            <summary>
            Log a debug message.
            </summary>
            <param name="message">message to log</param>
        </member>
        <member name="M:NVelocity.App.Velocity.SetApplicationAttribute(System.Object,System.Object)">
            <summary>
            <p>
            Set the an ApplicationAttribue, which is an Object
            set by the application which is accessable from
            any component of the system that gets a RuntimeServices.
            This allows communication between the application
            environment and custom pluggable components of the
            Velocity engine, such as loaders and loggers.
            </p>
            <p>
            Note that there is no enfocement or rules for the key
            used - it is up to the application developer.  However, to
            help make the intermixing of components possible, using
            the target Class name (e.g.  com.foo.bar ) as the key
            might help avoid collision.
            </p>
            </summary>
            <param name="key">object 'name' under which the object is stored
            </param>
            <param name="value">object to store under this key
            </param>
        </member>
        <member name="M:NVelocity.App.Velocity.TemplateExists(System.String)">
            <summary>
            <see>#ResourceExists(String)</see>
            </summary>
        </member>
        <member name="T:NVelocity.App.VelocityEngine">
            <summary>
            This class provides a separate new-able instance of the
            Velocity template engine.  The alternative model for use
            is using the Velocity class which employs the singleton
            model.
            
            Please ensure that you call one of the init() variants.
            This is critical for proper behavior.
            
            Coming soon : Velocity will call
            the parameter-less init() at the first use of this class
            if the init() wasn't explicitly called.  While this will
            ensure that Velocity functions, it almost certainly won't
            function in the way you intend, so please make sure to
            call init().
            </summary>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a></author>
        </member>
        <member name="M:NVelocity.App.VelocityEngine.#ctor">
            <summary>
            Init-less CTOR
            </summary>
        </member>
        <member name="M:NVelocity.App.VelocityEngine.#ctor(System.String)">
            <summary>
            CTOR that invokes an init(String), initializing
            the engine using the properties file specified
            </summary>
            <exception cref="T:System.Exception"></exception>
            <param name="propsFilename">name of properties file to init with</param>
        </member>
        <member name="M:NVelocity.App.VelocityEngine.#ctor(Commons.Collections.ExtendedProperties)">
            <summary>
            CTOR that invokes an init(String), initializing
            the engine using the Properties specified
            </summary>
            <param name="p">name of properties to init with</param>
        </member>
        <member name="M:NVelocity.App.VelocityEngine.SetExtendedProperties(Commons.Collections.ExtendedProperties)">
            <summary>
            Set an entire configuration at once. This is
            useful in cases where the parent application uses
            the ExtendedProperties class and the velocity configuration
            is a subset of the parent application's configuration.
            </summary>
        </member>
        <member name="M:NVelocity.App.VelocityEngine.Init">
            <summary>
            initialize the Velocity runtime engine, using the default
            properties of the Velocity distribution
            </summary>
        </member>
        <member name="M:NVelocity.App.VelocityEngine.Init(System.String)">
            <summary>
            initialize the Velocity runtime engine, using default properties
            plus the properties in the properties file passed in as the arg
            </summary>
            <param name="propsFilename">file containing properties to use to initialize
            the Velocity runtime</param>
        </member>
        <member name="M:NVelocity.App.VelocityEngine.Init(Commons.Collections.ExtendedProperties)">
            <summary>
            initialize the Velocity runtime engine, using default properties
            plus the properties in the passed in java.util.Properties object
            </summary>
            <param name="p"> Proprties object containing initialization properties</param>
        </member>
        <member name="M:NVelocity.App.VelocityEngine.SetProperty(System.String,System.Object)">
            <summary>
            Set a Velocity Runtime property.
            </summary>
        </member>
        <member name="M:NVelocity.App.VelocityEngine.AddProperty(System.String,System.Object)">
            <summary>
            Add a Velocity Runtime property.
            </summary>
        </member>
        <member name="M:NVelocity.App.VelocityEngine.ClearProperty(System.String)">
            <summary>
            Clear a Velocity Runtime property.
            </summary>
            <param name="key">ley of property to clear</param>
        </member>
        <member name="M:NVelocity.App.VelocityEngine.GetProperty(System.String)">
            <summary>
            Get a Velocity Runtime property.
            </summary>
            <param name="key">property to retrieve</param>
            <returns>
            property value or null if the property not currently set
            </returns>
        </member>
        <member name="M:NVelocity.App.VelocityEngine.Evaluate(NVelocity.Context.IContext,System.IO.TextWriter,System.String,System.String)">
            <summary>
            renders the input string using the context into the output writer.
            To be used when a template is dynamically constructed, or want to use
            Velocity as a token replacer.
            </summary>
            <param name="context">context to use in rendering input string</param>
            <param name="writer"> Writer in which to render the output</param>
            <param name="logTag"> string to be used as the template name for log messages in case of error</param>
            <param name="instring">input string containing the VTL to be rendered</param>
            <returns>true if successful, false otherwise.  If false, see Velocity runtime log</returns>
        </member>
        <member name="M:NVelocity.App.VelocityEngine.Evaluate(NVelocity.Context.IContext,System.IO.TextWriter,System.String,System.IO.Stream)">
            <summary>
            Renders the input stream using the context into the output writer.
            To be used when a template is dynamically constructed, or want to
            use Velocity as a token replacer.
            </summary>
            <param name="context">context to use in rendering input string</param>
            <param name="writer"> Writer in which to render the output</param>
            <param name="logTag"> string to be used as the template name for log messages in case of error</param>
            <param name="instream">input stream containing the VTL to be rendered</param>
            <returns>true if successful, false otherwise.  If false, see Velocity runtime log</returns>
        </member>
        <member name="M:NVelocity.App.VelocityEngine.Evaluate(NVelocity.Context.IContext,System.IO.TextWriter,System.String,System.IO.TextReader)">
            <summary>
            Renders the input reader using the context into the output writer.
            To be used when a template is dynamically constructed, or want to
            use Velocity as a token replacer.
            </summary>
            <param name="context">context to use in rendering input string</param>
            <param name="writer"> Writer in which to render the output</param>
            <param name="logTag"> string to be used as the template name for log messages in case of error</param>
            <param name="reader">Reader containing the VTL to be rendered</param>
            <returns>true if successful, false otherwise.  If false, see Velocity runtime log</returns>
        </member>
        <member name="M:NVelocity.App.VelocityEngine.InvokeVelocimacro(System.String,System.String,System.String[],NVelocity.Context.IContext,System.IO.TextWriter)">
            <summary>
            Invokes a currently registered Velocimacro with the parms provided
            and places the rendered stream into the writer.
            Note : currently only accepts args to the VM if they are in the context.
            </summary>
            <param name="vmName">name of Velocimacro to call</param>
            <param name="logTag">string to be used for template name in case of error</param>
            <param name="parameters">args used to invoke Velocimacro. In context key format :
            eg  "foo","bar" (rather than "$foo","$bar")
            </param>
            <param name="context">Context object containing data/objects used for rendering.</param>
            <param name="writer"> Writer for output stream</param>
            <returns>true if Velocimacro exists and successfully invoked, false otherwise.</returns>
        </member>
        <member name="M:NVelocity.App.VelocityEngine.MergeTemplate(System.String,NVelocity.Context.IContext,System.IO.TextWriter)">
            <summary>
            merges a template and puts the rendered stream into the writer
            </summary>
            <param name="templateName">name of template to be used in merge</param>
            <param name="context"> filled context to be used in merge</param>
            <param name="writer"> writer to write template into</param>
            <returns>true if successful, false otherwise.  Errors logged to velocity log.</returns>
        </member>
        <member name="M:NVelocity.App.VelocityEngine.MergeTemplate(System.String,System.String,NVelocity.Context.IContext,System.IO.TextWriter)">
            <summary>
            merges a template and puts the rendered stream into the writer
            </summary>
            <param name="templateName">name of template to be used in merge</param>
            <param name="encoding">encoding used in template</param>
            <param name="context"> filled context to be used in merge</param>
            <param name="writer"> writer to write template into</param>
            <returns>true if successful, false otherwise.  Errors logged to velocity log</returns>
        </member>
        <member name="M:NVelocity.App.VelocityEngine.GetTemplate(System.String)">
            <summary>
            Returns a <code>Template</code> from the Velocity
            resource management system.
            </summary>
            <param name="name">The file name of the desired template.</param>
            <returns>The template.</returns>
            <exception cref="T:NVelocity.Exception.ResourceNotFoundException">
            if template not found from any available source.
            </exception>
            <exception cref="T:NVelocity.Exception.ParseErrorException">
            if template cannot be parsed due
            to syntax (or other) error.
            </exception>
            <exception cref="T:System.Exception">
            if an error occurs in template initialization
            </exception>
        </member>
        <member name="M:NVelocity.App.VelocityEngine.GetTemplate(System.String,System.String)">
            <summary>
            Returns a <code>Template</code> from the Velocity
            resource management system.
            </summary>
            <param name="name">The file name of the desired template.</param>
            <param name="encoding">The character encoding to use for the template.</param>
            <returns>The template.</returns>
            <exception cref="T:NVelocity.Exception.ResourceNotFoundException">
            if template not found from any available source.
            </exception>
            <exception cref="T:NVelocity.Exception.ParseErrorException">
            if template cannot be parsed due
            to syntax (or other) error.
            </exception>
            <exception cref="T:System.Exception">
            if an error occurs in template initialization
            </exception>
        </member>
        <member name="M:NVelocity.App.VelocityEngine.TemplateExists(System.String)">
            <summary>
            Determines if a template is accessable via the currently
            configured resource loaders.
            <br/><br/>
            Note that the current implementation will <b>not</b>
            change the state of the system in any real way - so this
            cannot be used to pre-load the resource cache, as the
            previous implementation did as a side-effect.
            <br/><br/>
            The previous implementation exhibited extreme lazyness and
            sloth, and the author has been flogged.
            </summary>
            <param name="templateName"> name of the temlpate to search for
            </param>
            <returns>true if found, false otherwise
            </returns>
        </member>
        <member name="M:NVelocity.App.VelocityEngine.Warn(System.Object)">
            <summary>
            Log a warning message.
            </summary>
            <param name="message">message to log</param>
        </member>
        <member name="M:NVelocity.App.VelocityEngine.Info(System.Object)">
            
             <summary>
             Log an info message.
             </summary>
             <param name="message">message to log</param>
        </member>
        <member name="M:NVelocity.App.VelocityEngine.Error(System.Object)">
            <summary>
            Log an error message.
            </summary>
            <param name="message">message to log</param>
        </member>
        <member name="M:NVelocity.App.VelocityEngine.Debug(System.Object)">
            <summary>
            Log a debug message.
            </summary>
            <param name="message">message to log</param>
        </member>
        <member name="M:NVelocity.App.VelocityEngine.SetApplicationAttribute(System.Object,System.Object)">
            <summary>
            <p>
            Set the an ApplicationAttribue, which is an Object
            set by the application which is accessable from
            any component of the system that gets a RuntimeServices.
            This allows communication between the application
            environment and custom pluggable components of the
            Velocity engine, such as loaders and loggers.
            </p>
            <p>
            Note that there is no enfocement or rules for the key
            used - it is up to the application developer.  However, to
            help make the intermixing of components possible, using
            the target Class name (e.g.  com.foo.bar ) as the key
            might help avoid collision.
            </p>
            </summary>
            <param name="key">object 'name' under which the object is stored</param>
            <param name="value">object to store under this key</param>
        </member>
        <member name="T:Commons.Collections.CollectionsUtil">
            <summary>
            Static utility methods for collections
            </summary>
        </member>
        <member name="T:Commons.Collections.ExtendedProperties">
             <summary>
             This class extends normal Java properties by adding the possibility
             to use the same key many times concatenating the value strings
             instead of overwriting them.
            
             <para>The Extended Properties syntax is explained here:
            
             <ul>
             <li>
             Each property has the syntax <code>key = value</code>
             </li>
             <li>
             The <i>key</i> may use any character but the equal sign '='.
             </li>
             <li>
             <i>value</i> may be separated on different lines if a backslash
             is placed at the end of the line that continues below.
             </li>
             <li>
             If <i>value</i> is a list of strings, each token is separated
             by a comma ','.
             </li>
             <li>
             Commas in each token are escaped placing a backslash right before
             the comma.
             </li>
             <li>
             If a <i>key</i> is used more than once, the values are appended
             like if they were on the same line separated with commas.
             </li>
             <li>
             Blank lines and lines starting with character '#' are skipped.
             </li>
             <li>
             If a property is named "include" (or whatever is defined by
             setInclude() and getInclude() and the value of that property is
             the full path to a file on disk, that file will be included into
             the ConfigurationsRepository. You can also pull in files relative
             to the parent configuration file. So if you have something
             like the following:
            
             include = additional.properties
            
             Then "additional.properties" is expected to be in the same
             directory as the parent configuration file.
            
             Duplicate name values will be replaced, so be careful.
            
             </li>
             </ul>
             </para>
             <para>Here is an example of a valid extended properties file:
             </para>
             <para><pre>
             # lines starting with # are comments
            
             # This is the simplest property
             key = value
            
             # A long property may be separated on multiple lines
             longvalue = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa \
             aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
            
             # This is a property with many tokens
             tokens_on_a_line = first token, second token
            
             # This sequence generates exactly the same result
             tokens_on_multiple_lines = first token
             tokens_on_multiple_lines = second token
            
             # commas may be escaped in tokens
             commas.excaped = Hi\, what'up?
             </pre>
             </para>
             <para><b>NOTE</b>: this class has <b>not</b> been written for
             performance nor low memory usage.  In fact, it's way slower than it
             could be and generates too much memory garbage.  But since
             performance is not an issue during intialization (and there is not
             much time to improve it), I wrote it this way.  If you don't like
             it, go ahead and tune it up!</para>
             </summary>
        </member>
        <member name="F:Commons.Collections.ExtendedProperties.defaults">
            <summary> Default configurations repository.
            </summary>
        </member>
        <member name="F:Commons.Collections.ExtendedProperties.file">
            <summary>
            The file connected to this repository (holding comments and such).
            </summary>
        </member>
        <member name="F:Commons.Collections.ExtendedProperties.basePath">
            <summary>
            Base path of the configuration file used to create
            this ExtendedProperties object.
            </summary>
        </member>
        <member name="F:Commons.Collections.ExtendedProperties.fileSeparator">
            <summary>
            File separator.
            </summary>
        </member>
        <member name="F:Commons.Collections.ExtendedProperties.isInitialized">
            <summary>
            Has this configuration been intialized.
            </summary>
        </member>
        <member name="F:Commons.Collections.ExtendedProperties.include">
            <summary>
            This is the name of the property that can point to other
            properties file for including other properties files.
            </summary>
        </member>
        <member name="F:Commons.Collections.ExtendedProperties.keysAsListed">
            <summary>
            These are the keys in the order they listed
            in the configuration file. This is useful when
            you wish to perform operations with configuration
            information in a particular order.
            </summary>
        </member>
        <member name="M:Commons.Collections.ExtendedProperties.#ctor">
            <summary>
            Creates an empty extended properties object.
            </summary>
        </member>
        <member name="M:Commons.Collections.ExtendedProperties.#ctor(System.String)">
            <summary>
            Creates and loads the extended properties from the specified
            file.
            </summary>
            <param name="file">A String.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Commons.Collections.ExtendedProperties.#ctor(System.String,System.String)">
            <summary>
            Creates and loads the extended properties from the specified
            file.
            </summary>
            <param name="file">A String.</param>
            <param name="defaultFile">File to load defaults from.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Commons.Collections.ExtendedProperties.Init(Commons.Collections.ExtendedProperties)">
            <summary>
            Private initializer method that sets up the generic
            resources.
            </summary>
            <exception cref="T:System.IO.IOException">if there was an I/O problem.</exception>
        </member>
        <member name="M:Commons.Collections.ExtendedProperties.IsInitialized">
            <summary>
            Indicate to client code whether property
            resources have been initialized or not.
            </summary>
        </member>
        <member name="M:Commons.Collections.ExtendedProperties.Load(System.IO.Stream,System.String)">
            <summary>
            Load the properties from the given input stream
            and using the specified encoding.
            </summary>
            <param name="input">An InputStream.
            </param>
            <param name="enc">An encoding.
            </param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Commons.Collections.ExtendedProperties.GetProperty(System.String)">
             <summary>  Gets a property from the configuration.
             *
             </summary>
             <param name="key">property to retrieve
             </param>
             <returns>value as object. Will return user value if exists,
             if not then default value if exists, otherwise null
            
             </returns>
        </member>
        <member name="M:Commons.Collections.ExtendedProperties.AddProperty(System.String,System.Object)">
            <summary> Add a property to the configuration. If it already
            exists then the value stated here will be added
            to the configuration entry. For example, if
            *
            resource.loader = file
            *
            is already present in the configuration and you
            *
            addProperty("resource.loader", "classpath")
            *
            Then you will end up with a Vector like the
            following:
            *
            ["file", "classpath"]
            *
            </summary>
            <param name="key"></param>
            <param name="token"></param>
        </member>
        <member name="M:Commons.Collections.ExtendedProperties.AddPropertyDirect(System.String,System.Object)">
             <summary>   Adds a key/value pair to the map.  This routine does
             no magic morphing.  It ensures the keylist is maintained
             *
             </summary>
             <param name="key">key to use for mapping
             </param>
             <param name="obj">object to store
            
             </param>
        </member>
        <member name="M:Commons.Collections.ExtendedProperties.AddStringProperty(System.String,System.String)">
             <summary>  Sets a string property w/o checking for commas - used
             internally when a property has been broken up into
             strings that could contain escaped commas to prevent
             the inadvertant vectorization.
            
             Thanks to Leon Messerschmidt for this one.
            
             </summary>
        </member>
        <member name="M:Commons.Collections.ExtendedProperties.SetProperty(System.String,System.Object)">
            <summary> Set a property, this will replace any previously
            set values. Set values is implicitly a call
            to clearProperty(key), addProperty(key,value).
            </summary>
            <param name="key"></param>
            <param name="value_"></param>
        </member>
        <member name="M:Commons.Collections.ExtendedProperties.Save(System.IO.TextWriter,System.String)">
            <summary> Save the properties to the given outputstream.
            </summary>
            <param name="output">An OutputStream.
            </param>
            <param name="Header">A String.
            </param>
            <exception cref="T:System.IO.IOException">
            </exception>
        </member>
        <member name="M:Commons.Collections.ExtendedProperties.Combine(Commons.Collections.ExtendedProperties)">
             <summary> Combines an existing Hashtable with this Hashtable.
             *
             Warning: It will overwrite previous entries without warning.
             *
             </summary>
             <param name="c">ExtendedProperties
            
             </param>
        </member>
        <member name="M:Commons.Collections.ExtendedProperties.ClearProperty(System.String)">
             <summary> Clear a property in the configuration.
             *
             </summary>
             <param name="key">key to remove along with corresponding value.
            
             </param>
        </member>
        <member name="M:Commons.Collections.ExtendedProperties.GetKeys(System.String)">
             <summary> Get the list of the keys contained in the configuration
             repository.
             *
             </summary>
             <returns>An Iterator.
            
             </returns>
             <summary> Get the list of the keys contained in the configuration
             repository that match the specified prefix.
             *
             </summary>
             <param name="prefix">The prefix to test against.
             </param>
             <returns>An Iterator of keys that match the prefix.
            
             </returns>
        </member>
        <member name="M:Commons.Collections.ExtendedProperties.Subset(System.String)">
             <summary> Create an ExtendedProperties object that is a subset
             of this one. Take into account duplicate keys
             by using the setProperty() in ExtendedProperties.
             *
             </summary>
             <param name="prefix">prefix
            
             </param>
        </member>
        <member name="M:Commons.Collections.ExtendedProperties.ToString">
            <summary> Display the configuration for debugging
            purposes.
            </summary>
        </member>
        <member name="M:Commons.Collections.ExtendedProperties.GetString(System.String)">
             <summary> Get a string associated with the given configuration key.
             *
             </summary>
             <param name="key">The configuration key.
             </param>
             <returns>The associated string.
             </returns>
             <exception cref="T:System.InvalidCastException"> is thrown if the key maps to an
             object that is not a String.
            
             </exception>
        </member>
        <member name="M:Commons.Collections.ExtendedProperties.GetString(System.String,System.String)">
             <summary> Get a string associated with the given configuration key.
             *
             </summary>
             <param name="key">The configuration key.
             </param>
             <param name="defaultValue">The default value.
             </param>
             <returns>The associated string if key is found,
             default value otherwise.
             </returns>
             <exception cref="T:System.InvalidCastException"> is thrown if the key maps to an
             object that is not a String.
            
             </exception>
        </member>
        <member name="M:Commons.Collections.ExtendedProperties.GetProperties(System.String)">
             <summary> Get a list of properties associated with the given
             configuration key.
             *
             </summary>
             <param name="key">The configuration key.
             </param>
             <returns>The associated properties if key is found.
             </returns>
             <exception cref="T:System.InvalidCastException"> is thrown if the key maps to an
             object that is not a String/Vector.
             </exception>
             <exception cref="T:System.ArgumentException"> if one of the tokens is
             malformed (does not contain an equals sign).
            
             </exception>
        </member>
        <member name="M:Commons.Collections.ExtendedProperties.GetProperties(System.String,System.Collections.Hashtable)">
             <summary> Get a list of properties associated with the given
             configuration key.
             *
             </summary>
             <param name="key">The configuration key.
             </param>
             <param name="defaultProps">Default property values.
             </param>
             <returns>The associated properties if key is found.
             </returns>
             <exception cref="T:System.InvalidCastException"> is thrown if the key maps to an
             object that is not a String/Vector.
             </exception>
             <exception cref="T:System.ArgumentException"> if one of the tokens is
             malformed (does not contain an equals sign).
            
             </exception>
        </member>
        <member name="M:Commons.Collections.ExtendedProperties.GetStringArray(System.String)">
             <summary> Get an array of strings associated with the given configuration
             key.
             *
             </summary>
             <param name="key">The configuration key.
             </param>
             <returns>The associated string array if key is found.
             </returns>
             <exception cref="T:System.InvalidCastException"> is thrown if the key maps to an
             object that is not a String/Vector.
            
             </exception>
        </member>
        <member name="M:Commons.Collections.ExtendedProperties.GetVector(System.String)">
             <summary> Get a Vector of strings associated with the given configuration
             key.
             *
             </summary>
             <param name="key">The configuration key.
             </param>
             <returns>The associated Vector.
             </returns>
             <exception cref="T:System.InvalidCastException"> is thrown if the key maps to an
             object that is not a Vector.
            
             </exception>
        </member>
        <member name="M:Commons.Collections.ExtendedProperties.GetVector(System.String,System.Collections.ArrayList)">
             <summary> Get a Vector of strings associated with the given configuration
             key.
             *
             </summary>
             <param name="key">The configuration key.
             </param>
             <param name="defaultValue">The default value.
             </param>
             <returns>The associated Vector.
             </returns>
             <exception cref="T:System.InvalidCastException"> is thrown if the key maps to an
             object that is not a Vector.
            
             </exception>
        </member>
        <member name="M:Commons.Collections.ExtendedProperties.GetBoolean(System.String)">
             <summary> Get a boolean associated with the given configuration key.
             *
             </summary>
             <param name="key">The configuration key.
             </param>
             <returns>The associated boolean.
             </returns>
             <exception cref="T:System.Exception"> is thrown if the key doesn't
             map to an existing object.
             </exception>
             <exception cref="T:System.InvalidCastException"> is thrown if the key maps to an
             object that is not a Boolean.
            
             </exception>
        </member>
        <member name="M:Commons.Collections.ExtendedProperties.GetBoolean(System.String,System.Boolean)">
             <summary> Get a boolean associated with the given configuration key.
             *
             </summary>
             <param name="key">The configuration key.
             </param>
             <param name="defaultValue">The default value.
             </param>
             <returns>The associated boolean if key is found and has valid
             format, default value otherwise.
             </returns>
             <exception cref="T:System.InvalidCastException"> is thrown if the key maps to an
             object that is not a Boolean.
            
             </exception>
        </member>
        <member name="M:Commons.Collections.ExtendedProperties.TestBoolean(System.String)">
             <summary> Test whether the string represent by value maps to a boolean
             value or not. We will allow <code>true</code>, <code>on</code>,
             and <code>yes</code> for a <code>true</code> boolean value, and
             <code>false</code>, <code>off</code>, and <code>no</code> for
             <code>false</code> boolean values.  Case of value to test for
             boolean status is ignored.
             *
             </summary>
             <param name="value_">The value to test for boolean state.
             </param>
             <returns><code>true</code> or <code>false</code> if the supplied
             text maps to a boolean value, or <code>null</code> otherwise.
            
             </returns>
        </member>
        <member name="M:Commons.Collections.ExtendedProperties.GetByte(System.String)">
            <summary> Get a byte associated with the given configuration key.
            *
            </summary>
            <param name="key">The configuration key.
            </param>
            <returns>The associated byte if key is found and has valid
            format, <see cref="F:Commons.Collections.ExtendedProperties.DEFAULT_BYTE"/> otherwise.
            </returns>
            <exception cref="T:System.Exception"> is thrown if the key doesn't
            map to an existing object.
            </exception>
            <exception cref="T:System.InvalidCastException"> is thrown if the key maps to an
            object that is not a Byte.
            </exception>
        </member>
        <member name="M:Commons.Collections.ExtendedProperties.GetByte(System.String,System.SByte)">
            <summary> Get a byte associated with the given configuration key.
            *
            </summary>
            <param name="key">The configuration key.
            </param>
            <param name="defaultValue">The default value.
            </param>
            <returns>The associated byte if key is found and has valid
            format, default value otherwise.
            </returns>
            <exception cref="T:System.InvalidCastException"> is thrown if the key maps to an
            object that is not a Byte.
            </exception>
        </member>
        <member name="M:Commons.Collections.ExtendedProperties.GetByte(System.String,System.Byte)">
            <summary> Get a byte associated with the given configuration key.
            *
            </summary>
            <param name="key">The configuration key.
            </param>
            <param name="defaultValue">The default value.
            </param>
            <returns>The associated byte if key is found and has valid
            format, default value otherwise.
            </returns>
            <exception cref="T:System.InvalidCastException"> is thrown if the key maps to an
            object that is not a Byte.
            </exception>
        </member>
        <member name="M:Commons.Collections.ExtendedProperties.GetInt(System.String)">
             <summary> The purpose of this method is to get the configuration resource
             with the given name as an integer.
             *
             </summary>
             <param name="name">The resource name.
             </param>
             <returns>The value of the resource as an integer.
            
             </returns>
        </member>
        <member name="M:Commons.Collections.ExtendedProperties.GetInt(System.String,System.Int32)">
             <summary> The purpose of this method is to get the configuration resource
             with the given name as an integer, or a default value.
             *
             </summary>
             <param name="name">The resource name
             </param>
             <param name="def">The default value of the resource.
             </param>
             <returns>The value of the resource as an integer.
            
             </returns>
        </member>
        <member name="M:Commons.Collections.ExtendedProperties.GetInteger(System.String)">
            <summary> Get a int associated with the given configuration key.
            *
            </summary>
            <param name="key">The configuration key.
            </param>
            <returns>The associated int if key is found and has valid
            format, <see cref="F:Commons.Collections.ExtendedProperties.DEFAULT_INT32"/> otherwise.
            </returns>
            <exception cref="T:System.Exception"> is thrown if the key doesn't
            map to an existing object.
            </exception>
            <exception cref="T:System.InvalidCastException"> is thrown if the key maps to an
            object that is not a Integer.
            </exception>
        </member>
        <member name="M:Commons.Collections.ExtendedProperties.GetInteger(System.String,System.Int32)">
            <summary> Get a int associated with the given configuration key.
            *
            </summary>
            <param name="key">The configuration key.
            </param>
            <param name="defaultValue">The default value.
            </param>
            <returns>The associated int if key is found and has valid
            format, <see cref="F:Commons.Collections.ExtendedProperties.DEFAULT_INT32"/> otherwise.
            </returns>
            <returns>The associated int if key is found and has valid
            format, default value otherwise.
            </returns>
            <exception cref="T:System.InvalidCastException"> is thrown if the key maps to an
            object that is not a Integer.
            </exception>
        </member>
        <member name="M:Commons.Collections.ExtendedProperties.GetLong(System.String)">
            <summary> Get a long associated with the given configuration key.
            *
            </summary>
            <param name="key">The configuration key.
            </param>
            <returns>The associated long if key is found and has valid
            format, <see cref="F:Commons.Collections.ExtendedProperties.DEFAULT_INT64"/> otherwise.
            </returns>
            <exception cref="T:System.Exception"> is thrown if the key doesn't
            map to an existing object.
            </exception>
            <exception cref="T:System.InvalidCastException"> is thrown if the key maps to an
            object that is not a Long.
            </exception>
        </member>
        <member name="M:Commons.Collections.ExtendedProperties.GetLong(System.String,System.Int64)">
            <summary> Get a long associated with the given configuration key.
            *
            </summary>
            <param name="key">The configuration key.
            </param>
            <param name="defaultValue">The default value.
            </param>
            <returns>The associated long if key is found and has valid
            format, <see cref="F:Commons.Collections.ExtendedProperties.DEFAULT_INT64"/> otherwise.
            </returns>
            <exception cref="T:System.InvalidCastException"> is thrown if the key maps to an
            object that is not a Long.
            </exception>
        </member>
        <member name="M:Commons.Collections.ExtendedProperties.GetFloat(System.String)">
            <summary> Get a float associated with the given configuration key.
            *
            </summary>
            <param name="key">The configuration key.
            </param>
            <returns>The associated float if key is found and has valid
            format, <see cref="F:Commons.Collections.ExtendedProperties.DEFAULT_SINGLE"/> otherwise.
            </returns>
            <exception cref="T:System.Exception"> is thrown if the key doesn't
            map to an existing object.
            </exception>
            <exception cref="T:System.InvalidCastException"> is thrown if the key maps to an
            object that is not a Float.
            </exception>
        </member>
        <member name="M:Commons.Collections.ExtendedProperties.GetFloat(System.String,System.Single)">
            <summary> Get a float associated with the given configuration key.
            *
            </summary>
            <param name="key">The configuration key.
            </param>
            <param name="defaultValue">The default value.
            </param>
            <returns>The associated float if key is found and has valid
            format, <see cref="F:Commons.Collections.ExtendedProperties.DEFAULT_SINGLE"/> otherwise.
            </returns>
            <exception cref="T:System.InvalidCastException"> is thrown if the key maps to an
            object that is not a Float.
            </exception>
        </member>
        <member name="M:Commons.Collections.ExtendedProperties.GetDouble(System.String)">
            <summary> Get a double associated with the given configuration key.
            *
            </summary>
            <param name="key">The configuration key.
            </param>
            <returns>The associated double if key is found and has valid
            format, <see cref="F:Commons.Collections.ExtendedProperties.DEFAULT_DOUBLE"/> otherwise.
            </returns>
            <exception cref="T:System.Exception"> is thrown if the key doesn't
            map to an existing object.
            </exception>
            <exception cref="T:System.InvalidCastException"> is thrown if the key maps to an
            object that is not a Double.
            </exception>
        </member>
        <member name="M:Commons.Collections.ExtendedProperties.GetDouble(System.String,System.Double)">
            <summary> Get a double associated with the given configuration key.
            *
            </summary>
            <param name="key">The configuration key.
            </param>
            <param name="defaultValue">The default value.
            </param>
            <returns>The associated double if key is found and has valid
            format, <see cref="F:Commons.Collections.ExtendedProperties.DEFAULT_DOUBLE"/> otherwise.
            </returns>
            <exception cref="T:System.InvalidCastException"> is thrown if the key maps to an
            object that is not a Double.
            </exception>
        </member>
        <member name="M:Commons.Collections.ExtendedProperties.ConvertProperties(Commons.Collections.ExtendedProperties)">
            <summary>
            Convert a standard properties class into a configuration class.
            </summary>
            <param name="p">properties object to convert into a ExtendedProperties object.</param>
            <returns>ExtendedProperties configuration created from the properties object.</returns>
        </member>
        <member name="T:Commons.Collections.KeyedList">
             <summary>
            Using The KeyedList
            Using the KeyedList is just like using a Hashtable, except that when you enumerate through the list, the entries are in the same order as when they were added to the list.  Believe me, I needed this capability!
            
            using System;
            using System.Collections;
            
            namespace KeyedListTest {
                class ConsoleApp {
            	[STAThread]
            	static void Main(string[] args) {
            	    KeyedList k=new KeyedList();
            	    k.Add("One", 1);
            	    k.Add("Two", 2);
            	    k.Add("Three", 3);
            	    k.Add("Four", 4);
            	    k.Add("Five", 5);
            	    k.Add("Six", 6);
            	    k.Add("Seven", 7);
            	    k.Add("Eight", 8);
            	    k.Add("Nine", 9);
            	    k.Add("Ten", 10);
            
            	    foreach(DictionaryEntry entry in k) {
            		Console.WriteLine(entry.Key+": "+entry.Value.ToString());
            	    }
            	}
                }
            }
             </summary>
        </member>
        <member name="T:Commons.Collections.LRUMap">
            <summary>
            A keyed list with a fixed maximum size which removes
            the least recently used entry if an entry is added when full.
            </summary>
        </member>
        <member name="F:Commons.Collections.LRUMap.DEFAULT_MAX_SIZE">
            <summary>
            Default maximum size 
            </summary>
        </member>
        <member name="F:Commons.Collections.LRUMap.maxSize">
            <summary>
            Maximum size 
            </summary>
        </member>
        <member name="M:Commons.Collections.LRUMap.RemoveLRU">
            <summary>
            Remove the least recently used entry (the last one in the list)
            </summary>
        </member>
        <member name="P:Commons.Collections.LRUMap.MaxSize">
            <summary>
            Gets the maximum size of the map (the bound).
            </summary>
        </member>
        <member name="T:Commons.Collections.PropertiesReader">
            <summary>
            This class is used to read properties lines.  These lines do
            not terminate with new-line chars but rather when there is no
            backslash sign a the end of the line.  This is used to
            concatenate multiple lines for readability.
            </summary>
        </member>
        <member name="M:Commons.Collections.PropertiesReader.#ctor(System.IO.StreamReader)">
            <summary>
            Constructor.
            </summary>
            <param name="reader">A Reader.</param>
        </member>
        <member name="M:Commons.Collections.PropertiesReader.ReadProperty">
            <summary>
            Read a property.
            </summary>
            <returns>A String.</returns>
        </member>
        <member name="T:Commons.Collections.PropertiesTokenizer">
            <summary>
            This class divides into tokens a property value.  Token
            separator is "," but commas into the property value are escaped
            using the backslash in front.
            </summary>
        </member>
        <member name="F:Commons.Collections.PropertiesTokenizer.DELIMITER">
            <summary>
            The property delimiter used while parsing (a comma).
            </summary>
        </member>
        <member name="M:Commons.Collections.PropertiesTokenizer.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="str">A String</param>
        </member>
        <member name="M:Commons.Collections.PropertiesTokenizer.HasMoreTokens">
            <summary> Check whether the object has more tokens.
            </summary>
            <returns>True if the object has more tokens.
            </returns>
        </member>
        <member name="M:Commons.Collections.PropertiesTokenizer.NextToken">
            <summary>
            Get next token.
            </summary>
            <returns>A String</returns>
        </member>
        <member name="T:NVelocity.Context.AbstractContext">
             <summary>  This class is the abstract base class for all conventional
             Velocity Context  implementations.  Simply extend this class
             and implement the abstract routines that access your preferred
             storage method.
             *
             Takes care of context chaining.
             *
             Also handles / enforces policy on null keys and values :
             *
             <ul>
             <li> Null keys and values are accepted and basically dropped.</li>
             <li> If you place an object into the context with a null key, it
             will be ignored and logged.</li>
             <li> If you try to place a null into the context with any key, it
             will be dropped and logged.</li>
             </ul>
             *
             The default implementation of this for application use is
             org.apache.velocity.VelocityContext.
             *
             All thanks to Fedor for the chaining idea.
             *
             </summary>
             <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
             </author>
             <author> <a href="mailto:fedor.karpelevitch@home.com">Fedor Karpelevitch</a>
             </author>
             <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a>
             </author>
             <version> $Id: AbstractContext.cs,v 1.4 2003/10/27 13:54:08 corts Exp $
            
             </version>
        </member>
        <member name="T:NVelocity.Context.InternalContextBase">
             <summary>  class to encapsulate the 'stuff' for internal operation of velocity.
             We use the context as a thread-safe storage : we take advantage of the
             fact that it's a visitor  of sorts  to all nodes (that matter) of the
             AST during init() and render().
             Currently, it carries the template name for namespace
             support, as well as node-local context data introspection caching.
             *
             Note that this is not a public class.  It is for package access only to
             keep application code from accessing the internals, as AbstractContext
             is derived from this.
             *
             </summary>
             <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
             </author>
             <version> $Id: InternalContextBase.cs,v 1.4 2003/10/27 13:54:08 corts Exp $
            
             </version>
        </member>
        <member name="T:NVelocity.Context.IInternalHousekeepingContext">
             <summary>
             interface to encapsulate the 'stuff' for internal operation of velocity.
             We use the context as a thread-safe storage : we take advantage of the
             fact that it's a visitor  of sorts  to all nodes (that matter) of the
             AST during init() and render().
            
             Currently, it carries the template name for namespace
             support, as well as node-local context data introspection caching.
             </summary>
             <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a></author>
             <author> <a href="mailto:Christoph.Reck@dlr.de">Christoph Reck</a></author>
             <version> $Id: InternalHousekeepingContext.cs,v 1.4 2003/10/27 13:54:08 corts Exp $</version>
        </member>
        <member name="M:NVelocity.Context.IInternalHousekeepingContext.PushCurrentTemplateName(System.String)">
            <summary>
            set the current template name on top of stack
            </summary>
            <param name="s">current template name</param>
        </member>
        <member name="M:NVelocity.Context.IInternalHousekeepingContext.PopCurrentTemplateName">
            <summary>
            remove the current template name from stack
            </summary>
        </member>
        <member name="M:NVelocity.Context.IInternalHousekeepingContext.ICacheGet(System.Object)">
            <summary>
            Gets the <see cref="T:NVelocity.Util.Introspection.IntrospectionCacheData"/> object if exists 
            for the key
            </summary>
            <param name="key">key to find in cache</param>
            <returns>cache object</returns>
        </member>
        <member name="M:NVelocity.Context.IInternalHousekeepingContext.ICachePut(System.Object,NVelocity.Util.Introspection.IntrospectionCacheData)">
            <summary>
            Sets the <see cref="T:NVelocity.Util.Introspection.IntrospectionCacheData"/> object 
            for the key
            </summary>
            <param name="key"> key </param>
            <param name="o"> IntrospectionCacheData object to place in cache</param>
        </member>
        <member name="P:NVelocity.Context.IInternalHousekeepingContext.CurrentTemplateName">
            <summary>
            get the current template name
            </summary>
            <returns>String current template name</returns>
        </member>
        <member name="P:NVelocity.Context.IInternalHousekeepingContext.TemplateNameStack">
            <summary>
            Returns the template name stack in form of an array.
            </summary>
            <returns>Object[] with the template name stack contents.</returns>
        </member>
        <member name="P:NVelocity.Context.IInternalHousekeepingContext.CurrentResource">
            <summary>
            temporary fix to enable #include() to figure out
            current encoding.
            </summary>
        </member>
        <member name="T:NVelocity.Context.IInternalEventContext">
            <summary>
            Interface for event support.  Note that this is a public internal
            interface, as it is something that will be accessed from outside
            of the .context package.
            </summary>
        </member>
        <member name="F:NVelocity.Context.InternalContextBase.introspectionCache">
            <summary>
            cache for node/context specific introspection information
            </summary>
        </member>
        <member name="F:NVelocity.Context.InternalContextBase.templateNameStack">
            <summary>
            Template name stack. The stack top contains the current template name.
            </summary>
        </member>
        <member name="F:NVelocity.Context.InternalContextBase.eventCartridge">
            <summary>
            EventCartridge we are to carry.  Set by application
            </summary>
        </member>
        <member name="F:NVelocity.Context.InternalContextBase.currentResource">
            <summary>
            Current resource - used for carrying encoding and other
            information down into the rendering process
            </summary>
        </member>
        <member name="M:NVelocity.Context.InternalContextBase.PushCurrentTemplateName(System.String)">
            <summary>
            set the current template name on top of stack
            </summary>
            <param name="s">current template name</param>
        </member>
        <member name="M:NVelocity.Context.InternalContextBase.PopCurrentTemplateName">
            <summary>remove the current template name from stack</summary>
        </member>
        <member name="T:NVelocity.Context.IContext">
             <summary>
             Interface describing the application data context.  This set of
             routines is used by the application to set and remove 'named' data
             object to pass them to the template engine to use when rendering
             a template.
            
             This is the same set of methods supported by the original Context
             class
             </summary>
             <seealso cref="T:NVelocity.Context.AbstractContext"/>
             <seealso cref="T:NVelocity.VelocityContext"/>
             <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a></author>
             <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a></author>
        </member>
        <member name="M:NVelocity.Context.IContext.Put(System.String,System.Object)">
            <summary>
            Adds a name/value pair to the context.
            </summary>
            <param name="key">The name to key the provided value with.</param>
            <param name="value">The corresponding value.</param>
        </member>
        <member name="M:NVelocity.Context.IContext.Get(System.String)">
            <summary>
            Gets the value corresponding to the provided key from the context.
            </summary>
            <param name="key">The name of the desired value.</param>
            <returns>The value corresponding to the provided key.</returns>
        </member>
        <member name="M:NVelocity.Context.IContext.ContainsKey(System.Object)">
            <summary>
            Indicates whether the specified key is in the context.
            </summary>
            <param name="key">The key to look for.</param>
            <returns>Whether the key is in the context.</returns>
        </member>
        <member name="M:NVelocity.Context.IContext.Remove(System.Object)">
            <summary>
            Removes the value associated with the specified key from the context.
            </summary>
            <param name="key">The name of the value to remove.</param>
            <returns>The value that the key was mapped to, or <code>null</code> if unmapped.</returns>
        </member>
        <member name="P:NVelocity.Context.IContext.Count">
            <summary>
            Returns the number of elements in this context
            </summary>
            <value>The count.</value>
        </member>
        <member name="P:NVelocity.Context.IContext.Keys">
            <summary>
            Get all the keys for the values in the context
            </summary>
        </member>
        <member name="F:NVelocity.Context.AbstractContext.innerContext">
            <summary>  the chained Context if any
            </summary>
        </member>
        <member name="M:NVelocity.Context.AbstractContext.InternalGet(System.String)">
            
             <summary>  Implement to return a value from the context storage.
             <br/><br/>
             The implementation of this method is required for proper
             operation of a Context implementation in general
             Velocity use.
            
             </summary>
             <param name="key">key whose associated value is to be returned
             </param>
             <returns>object stored in the context
            
             </returns>
        </member>
        <member name="M:NVelocity.Context.AbstractContext.InternalPut(System.String,System.Object)">
            
             <summary>  Implement to put a value into the context storage.
             <br/><br/>
             The implementation of this method is required for
             proper operation of a Context implementation in
             general Velocity use.
             *
             </summary>
             <param name="key">key with which to associate the value
             </param>
             <param name="value_">value to be associated with the key
             </param>
             <returns>previously stored value if exists, or null
            
             </returns>
        </member>
        <member name="M:NVelocity.Context.AbstractContext.InternalContainsKey(System.Object)">
            
             <summary>  Implement to determine if a key is in the storage.
             <br/><br/>
             Currently, this method is not used internally by
             the Velocity core.
             *
             </summary>
             <param name="key">key to test for existance
             </param>
             <returns>true if found, false if not
            
             </returns>
        </member>
        <member name="M:NVelocity.Context.AbstractContext.InternalGetKeys">
            
             <summary>  Implement to return an object array of key
             strings from your storage.
             <br/><br/>
             Currently, this method is not used internally by
             the Velocity core.
             *
             </summary>
             <returns>array of keys
            
             </returns>
        </member>
        <member name="M:NVelocity.Context.AbstractContext.InternalRemove(System.Object)">
            
             <summary>  I mplement to remove an item from your storage.
             <br/><br/>
             Currently, this method is not used internally by
             the Velocity core.
             *
             </summary>
             <param name="key">key to remove
             </param>
             <returns>object removed if exists, else null
            
             </returns>
        </member>
        <member name="M:NVelocity.Context.AbstractContext.#ctor">
            <summary>  default CTOR
            </summary>
        </member>
        <member name="M:NVelocity.Context.AbstractContext.#ctor(NVelocity.Context.IContext)">
             <summary>  Chaining constructor accepts a Context argument.
             It will relay get() operations into this Context
             in the even the 'local' get() returns null.
            
             </summary>
             <param name="inner">context to be chained
            
             </param>
        </member>
        <member name="M:NVelocity.Context.AbstractContext.Put(System.String,System.Object)">
             <summary> Adds a name/value pair to the context.
            
             </summary>
             <param name="key">  The name to key the provided value with.
             </param>
             <param name="value_">The corresponding value.
             </param>
             <returns>Object that was replaced in the the Context if
             applicable or null if not.
            
             </returns>
        </member>
        <member name="M:NVelocity.Context.AbstractContext.Get(System.String)">
             <summary>  Gets the value corresponding to the provided key from the context.
             *
             Supports the chaining context mechanism.  If the 'local' context
             doesn't have the value, we try to get it from the chained context.
             *
             </summary>
             <param name="key">The name of the desired value.
             </param>
             <returns>   The value corresponding to the provided key or null if
             the key param is null.
            
             </returns>
        </member>
        <member name="M:NVelocity.Context.AbstractContext.ContainsKey(System.Object)">
             <summary>  Indicates whether the specified key is in the context.  Provided for
             debugging purposes.
             *
             </summary>
             <param name="key">The key to look for.
             </param>
             <returns>true if the key is in the context, false if not.
            
             </returns>
        </member>
        <member name="M:NVelocity.Context.AbstractContext.Remove(System.Object)">
             <summary>  Get all the keys for the values in the context
             </summary>
             <returns>Object[] of keys in the Context. Does not return
             keys in chained context.
            
             </returns>
             <summary> Removes the value associated with the specified key from the context.
             *
             </summary>
             <param name="key">The name of the value to remove.
             </param>
             <returns>   The value that the key was mapped to, or <code>null</code>
             if unmapped.
            
             </returns>
        </member>
        <member name="T:NVelocity.Context.IInternalContextAdapter">
             <summary>  interface to bring all necessary internal and user contexts together.
             this is what the AST expects to deal with.  If anything new comes
             along, add it here.
             *
             I will rename soon :)
             *
             </summary>
             <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
             </author>
             <version> $Id: InternalContextAdapter.cs,v 1.3 2003/10/27 13:54:08 corts Exp $
            
             </version>
        </member>
        <member name="T:NVelocity.Context.IInternalWrapperContext">
            <summary>
            interface for internal context wrapping functionality
            </summary>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a></author>
            <version> $Id: InternalWrapperContext.cs,v 1.4 2003/10/27 13:54:08 corts Exp $ </version>
        </member>
        <member name="P:NVelocity.Context.IInternalWrapperContext.InternalUserContext">
            <summary>
            returns the wrapped user context
            </summary>
        </member>
        <member name="P:NVelocity.Context.IInternalWrapperContext.BaseContext">
            <summary>
            returns the base full context impl
            </summary>
        </member>
        <member name="M:NVelocity.Context.IInternalContextAdapter.Remove(System.Object)">
            <summary>
            Need to define this method here otherwise since both IDicationary and IContext
            contains a Remove(Object key) method we will need to cast the object to either interface
            before calling this method, for backward compabillity we make the IContext.Remove the default
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="T:NVelocity.Context.InternalContextAdapterImpl">
             <summary>  This adapter class is the container for all context types for internal
             use.  The AST now uses this class rather than the app-level Context
             interface to allow flexibility in the future.
             *
             Currently, we have two context interfaces which must be supported :
             <ul>
             <li> Context : used for application/template data access</li>
             <li> InternalHousekeepingContext : used for internal housekeeping and caching</li>
             <li> InternalWrapperContext : used for getting root cache context and other
             such.</li>
             <li> InternalEventContext : for event handling.</li>
             </ul>
             *
             This class implements the two interfaces to ensure that all methods are
             supported.  When adding to the interfaces, or adding more context
             functionality, the interface is the primary definition, so alter that first
             and then all classes as necessary.  As of this writing, this would be
             the only class affected by changes to InternalContext
             *
             This class ensures that an InternalContextBase is available for internal
             use.  If an application constructs their own Context-implementing
             object w/o subclassing AbstractContext, it may be that support for
             InternalContext is not available.  Therefore, InternalContextAdapter will
             create an InternalContextBase if necessary for this support.  Note that
             if this is necessary, internal information such as node-cache data will be
             lost from use to use of the context.  This may or may not be important,
             depending upon application.
            
             *
             </summary>
             <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
             </author>
             <version> $Id: InternalContextAdapterImpl.cs,v 1.4 2003/10/27 13:54:08 corts Exp $
            
             </version>
        </member>
        <member name="F:NVelocity.Context.InternalContextAdapterImpl.context">
            
             <summary>  the user data Context that we are wrapping
             </summary>
        </member>
        <member name="F:NVelocity.Context.InternalContextAdapterImpl.icb">
            
             <summary>  the ICB we are wrapping.  We may need to make one
             if the user data context implementation doesn't
             support one.  The default AbstractContext-derived
             VelocityContext does, and it's recommended that
             people derive new contexts from AbstractContext
             rather than piecing things together
             </summary>
        </member>
        <member name="F:NVelocity.Context.InternalContextAdapterImpl.iec">
            <summary>  The InternalEventContext that we are wrapping.  If
            the context passed to us doesn't support it, no
            biggie.  We don't make it for them - since its a
            user context thing, nothing gained by making one
            for them now
            </summary>
        </member>
        <member name="M:NVelocity.Context.InternalContextAdapterImpl.#ctor(NVelocity.Context.IContext)">
             <summary>  CTOR takes a Context and wraps it, delegating all 'data' calls
             to it.
            
             For support of internal contexts, it will create an InternalContextBase
             if need be.
             </summary>
        </member>
        <member name="M:NVelocity.Context.InternalContextAdapterImpl.AttachEventCartridge(NVelocity.App.Events.EventCartridge)">
            <summary>  returns the user data context that
            we are wrapping
            </summary>
            <summary>  Returns the base context that we are
            wrapping. Here, its this, but for other thing
            like VM related context contortions, it can
            be something else
            </summary>
        </member>
        <member name="T:NVelocity.Context.VMContext">
             <summary>  This is a special, internal-use-only context implementation to be
             used for the new Velocimacro implementation.
             *
             The main distinguishing feature is the management of the VMProxyArg objects
             in the put() and get() methods.
             *
             Further, this context also supports the 'VM local context' mode, where
             any get() or put() of references that aren't args to the VM are considered
             local to the vm, protecting the global context.
            
             </summary>
             <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
             </author>
             <version> $Id: VMContext.cs,v 1.4 2003/10/27 13:54:08 corts Exp $
            
             </version>
        </member>
        <member name="F:NVelocity.Context.VMContext.vmproxyhash">
            <summary>container for our VMProxy Objects
            </summary>
        </member>
        <member name="F:NVelocity.Context.VMContext.localcontext">
            <summary>container for any local or constant VMProxy items
            </summary>
        </member>
        <member name="F:NVelocity.Context.VMContext.innerContext">
            <summary>the base context store.  This is the 'global' context
            </summary>
        </member>
        <member name="F:NVelocity.Context.VMContext.wrappedContext">
            <summary>context that we are wrapping
            </summary>
        </member>
        <member name="F:NVelocity.Context.VMContext.localcontextscope">
            <summary>support for local context scope feature, where all references are local
            </summary>
        </member>
        <member name="M:NVelocity.Context.VMContext.#ctor(NVelocity.Context.IInternalContextAdapter,NVelocity.Runtime.IRuntimeServices)">
            <summary>  CTOR, wraps an ICA
            </summary>
        </member>
        <member name="M:NVelocity.Context.VMContext.AddVMProxyArg(NVelocity.Runtime.Directive.VMProxyArg)">
             <summary>  return the inner / user context
             </summary>
             <summary>  Used to put VMProxyArgs into this context.  It separates
             the VMProxyArgs into constant and non-constant types
             pulling out the value of the constant types so they can
             be modified w/o damaging the VMProxyArg, and leaving the
             dynamic ones, as they modify context rather than their own
             state
             </summary>
             <param name="vmpa">VMProxyArg to add
            
             </param>
        </member>
        <member name="M:NVelocity.Context.VMContext.Put(System.String,System.Object)">
             <summary>  Impl of the Context.put() method.
             *
             </summary>
             <param name="key">name of item to set
             </param>
             <param name="value_">object to set to key
             </param>
             <returns>old stored object
            
             </returns>
        </member>
        <member name="M:NVelocity.Context.VMContext.Get(System.String)">
             <summary>  Impl of the Context.gut() method.
             *
             </summary>
             <param name="key">name of item to get
             </param>
             <returns> stored object or null
            
             </returns>
        </member>
        <member name="M:NVelocity.Context.VMContext.ContainsKey(System.Object)">
            <summary>  not yet impl
            </summary>
        </member>
        <member name="M:NVelocity.Context.VMContext.Remove(System.Object)">
            <summary>  impl badly
            </summary>
            <summary>  impl badly
            </summary>
        </member>
        <member name="T:NVelocity.Exception.MethodInvocationException">
            <summary>
            Application-level exception thrown when a reference method is
            invoked and an exception is thrown.
            <br/>
            When this exception is thrown, a best effort will be made to have
            useful information in the exception's message.  For complete
            information, consult the runtime log.
            </summary>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a> </author>
            <version> $Id: MethodInvocationException.cs,v 1.3 2003/10/27 13:54:08 corts Exp $ </version>
        </member>
        <member name="T:NVelocity.Exception.VelocityException">
            <summary>  
            Base class for Velocity exceptions thrown to the
            application layer.
            </summary>
        </member>
        <member name="M:NVelocity.Exception.MethodInvocationException.#ctor(System.String,System.Exception,System.String)">
            <summary>
            Wraps the passed in exception for examination later
            </summary>
        </member>
        <member name="T:NVelocity.Exception.ParseErrorException">
             <summary>  Application-level exception thrown when a resource of any type
             has a syntax or other error which prevents it from being parsed.
             <br/>
             When this resource is thrown, a best effort will be made to have
             useful information in the exception's message.  For complete
             information, consult the runtime log.
             *
             </summary>
             <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
             </author>
             <version> $Id: ParseErrorException.cs,v 1.3 2003/10/27 13:54:08 corts Exp $
            
             </version>
        </member>
        <member name="T:NVelocity.Exception.ResourceNotFoundException">
            <summary>  
            Application-level exception thrown when a resource of any type
            isn't found by the Velocity engine.
            <br/>
            When this exception is thrown, a best effort will be made to have
            useful information in the exception's message.  For complete
            information, consult the runtime log.
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Directive.Directive">
            <summary> Base class for all directives used in Velocity.</summary>
            <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a> </author>
            <version> $Id: Directive.cs,v 1.3 2003/10/27 13:54:10 corts Exp $ </version>
        </member>
        <member name="M:NVelocity.Runtime.Directive.Directive.Init(NVelocity.Runtime.IRuntimeServices,NVelocity.Context.IInternalContextAdapter,NVelocity.Runtime.Parser.Node.INode)">
            <summary>
            How this directive is to be initialized.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Directive.Directive.SetLocation(System.Int32,System.Int32)">
            <summary>
            Allows the template location to be set
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Directive.Directive.Render(NVelocity.Context.IInternalContextAdapter,System.IO.TextWriter,NVelocity.Runtime.Parser.Node.INode)">
            <summary>
            How this directive is to be rendered
            </summary>
        </member>
        <member name="P:NVelocity.Runtime.Directive.Directive.Name">
            <summary>
            Return the name of this directive
            </summary>
        </member>
        <member name="P:NVelocity.Runtime.Directive.Directive.Type">
            <summary>
            Get the directive type BLOCK/LINE
            </summary>
        </member>
        <member name="P:NVelocity.Runtime.Directive.Directive.Line">
            <summary>
            for log msg purposes
            </summary>
        </member>
        <member name="P:NVelocity.Runtime.Directive.Directive.Column">
            <summary>
            for log msg purposes
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Directive.DirectiveType">
            <summary>
            Directive Types
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Directive.Foreach">
            <summary>
            Foreach directive used for moving through arrays,
            or objects that provide an Iterator.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Directive.Foreach.counterName">
            <summary>
            The name of the variable to use when placing
            the counter value into the context. Right
            now the default is $velocityCount.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Directive.Foreach.counterInitialValue">
            <summary>
            What value to start the loop counter at.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Directive.Foreach.elementKey">
             <summary>
             The reference name used to access each
             of the elements in the list object. It
             is the $item in the following:
            
             #foreach ($item in $list)
            
             This can be used class wide because
             it is immutable.
             </summary>
        </member>
        <member name="M:NVelocity.Runtime.Directive.Foreach.Init(NVelocity.Runtime.IRuntimeServices,NVelocity.Context.IInternalContextAdapter,NVelocity.Runtime.Parser.Node.INode)">
            <summary>  
            simple init - init the tree and get the elementKey from
            the AST
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Directive.Foreach.GetIterator(NVelocity.Context.IInternalContextAdapter,NVelocity.Runtime.Parser.Node.INode)">
            <summary>
            returns an Iterator to the collection in the #foreach()
            </summary>
            <param name="context"> current context </param>
            <param name="node">  AST node </param>
            <returns>Iterator to do the dataset </returns>
        </member>
        <member name="M:NVelocity.Runtime.Directive.Foreach.Render(NVelocity.Context.IInternalContextAdapter,System.IO.TextWriter,NVelocity.Runtime.Parser.Node.INode)">
            <summary>
            renders the #foreach() block
            </summary>
        </member>
        <member name="P:NVelocity.Runtime.Directive.Foreach.Name">
            <summary>
            Return name of this directive.
            </summary>
        </member>
        <member name="P:NVelocity.Runtime.Directive.Foreach.Type">
            <summary>
            Return type of this directive.
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Directive.Include">
             <summary>
             Pluggable directive that handles the #include() statement in VTL.
             This #include() can take multiple arguments of either
             StringLiteral or Reference.
             
             Notes:
             -----
             1) The included source material can only come from somewhere in
             the TemplateRoot tree for security reasons. There is no way
             around this.  If you want to include content from elsewhere on
             your disk, use a link from somwhere under Template Root to that
             content.
             
             2) By default, there is no output to the render stream in the event of
             a problem.  You can override this behavior with two property values :
             include.output.errormsg.start
             include.output.errormsg.end
             If both are defined in velocity.properties, they will be used to
             in the render output to bracket the arg string that caused the
             problem.
             Ex. : if you are working in html then
             include.output.errormsg.start=<!-- #include error :
             include.output.errormsg.end= -->
             might be an excellent way to start...
             
             3) As noted above, #include() can take multiple arguments.
             Ex : #include( "foo.vm" "bar.vm" $foo )
             will simply include all three if valid to output w/o any
             special separator.
             
             </summary>
             <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
             </author>
             <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a>
             </author>
             <author> <a href="mailto:kav@kav.dk">Kasper Nielsen</a>
             </author>
             <version> $Id: Include.cs,v 1.3 2003/10/27 13:54:10 corts Exp $
            
             </version>
        </member>
        <member name="M:NVelocity.Runtime.Directive.Include.Init(NVelocity.Runtime.IRuntimeServices,NVelocity.Context.IInternalContextAdapter,NVelocity.Runtime.Parser.Node.INode)">
            <summary>
            simple init - init the tree and get the elementKey from
            the AST
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Directive.Include.Render(NVelocity.Context.IInternalContextAdapter,System.IO.TextWriter,NVelocity.Runtime.Parser.Node.INode)">
            <summary>
            iterates through the argument list and renders every
            argument that is appropriate.  Any non appropriate
            arguments are logged, but render() continues.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Directive.Include.RenderOutput(NVelocity.Runtime.Parser.Node.INode,NVelocity.Context.IInternalContextAdapter,System.IO.TextWriter)">
            <summary>
            does the actual rendering of the included file
            </summary>
            <param name="node">AST argument of type StringLiteral or Reference</param>
            <param name="context">valid context so we can render References</param>
            <param name="writer">output Writer</param>
            <returns>boolean success or failure.  failures are logged</returns>
        </member>
        <member name="M:NVelocity.Runtime.Directive.Include.OutputErrorToStream(System.IO.TextWriter,System.String)">
            <summary>
            Puts a message to the render output stream if ERRORMSG_START / END
            are valid property strings.  Mainly used for end-user template
            debugging.
            </summary>
        </member>
        <member name="P:NVelocity.Runtime.Directive.Include.Name">
            <summary>
            Return name of this directive.
            </summary>
        </member>
        <member name="P:NVelocity.Runtime.Directive.Include.Type">
            <summary> Return type of this directive.</summary>
        </member>
        <member name="T:NVelocity.Runtime.Directive.Literal">
            <summary>
            A very simple directive that leverages the Node.literal()
            to grab the literal rendition of a node. We basically
            grab the literal value on init(), then repeatedly use
            that during render().
            </summary>
            <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a> </author>
            <version> $Id: Literal.cs,v 1.3 2003/10/27 13:54:10 corts Exp $ </version>
        </member>
        <member name="M:NVelocity.Runtime.Directive.Literal.Init(NVelocity.Runtime.IRuntimeServices,NVelocity.Context.IInternalContextAdapter,NVelocity.Runtime.Parser.Node.INode)">
            <summary>
            Store the literal rendition of a node using
            the Node.literal().
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Directive.Literal.Render(NVelocity.Context.IInternalContextAdapter,System.IO.TextWriter,NVelocity.Runtime.Parser.Node.INode)">
            <summary> Throw the literal rendition of the block between
            #literal()/#end into the writer.
            </summary>
        </member>
        <member name="P:NVelocity.Runtime.Directive.Literal.Name">
            <summary>Return name of this directive.</summary>
        </member>
        <member name="P:NVelocity.Runtime.Directive.Literal.Type">
            <summary> Return type of this directive. </summary>
        </member>
        <member name="T:NVelocity.Runtime.Directive.Macro">
             <summary>
             Macro implements the macro definition directive of VTL.
            
             example :
            
             #macro( isnull $i )
             #if( $i )
             $i
             #end
             #end
            
             This object is used at parse time to mainly process and register the
             macro.  It is used inline in the parser when processing a directive.
            
             </summary>
             <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a></author>
             <version> $Id: Macro.cs,v 1.3 2003/10/27 13:54:10 corts Exp $</version>
        </member>
        <member name="M:NVelocity.Runtime.Directive.Macro.Render(NVelocity.Context.IInternalContextAdapter,System.IO.TextWriter,NVelocity.Runtime.Parser.Node.INode)">
            <summary> Return name of this directive.
            </summary>
            <summary> Return type of this directive.
            </summary>
            <summary>   render() doesn't do anything in the final output rendering.
            There is no output from a #macro() directive.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Directive.Macro.processAndRegister(NVelocity.Runtime.IRuntimeServices,NVelocity.Runtime.Parser.Node.INode,System.String)">
             <summary>
             Used by Parser.java to process VMs withing the parsing process
            
             processAndRegister() doesn't actually render the macro to the output
             Processes the macro body into the internal representation used by the
             VelocimacroProxy objects, and if not currently used, adds it
             to the macro Factory
             </summary>
        </member>
        <member name="M:NVelocity.Runtime.Directive.Macro.getArgArray(NVelocity.Runtime.Parser.Node.INode)">
            <summary>  creates an array containing the literal
            strings in the macro arguement
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Directive.Macro.getASTAsStringArray(NVelocity.Runtime.Parser.Node.INode)">
            <summary>  Returns an array of the literal rep of the AST
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Directive.Parse">
            <summary>
            Pluggable directive that handles the #parse() statement in VTL.
            
            Notes:
            -----
            1) The parsed source material can only come from somewhere in
            the TemplateRoot tree for security reasons. There is no way
            around this.  If you want to include content from elsewhere on
            your disk, use a link from somwhere under Template Root to that
            content.
            
            2) There is a limited parse depth.  It is set as a property
            "parse_directive.maxdepth = 10"  for example.  There is a 20 iteration
            safety in the event that the parameter isn't set.
            
            </summary>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a> </author>
            <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a> </author>
            <author> <a href="mailto:Christoph.Reck@dlr.de">Christoph Reck</a> </author>
            <version> $Id: Parse.cs,v 1.4 2003/10/27 13:54:10 corts Exp $ </version>
        </member>
        <member name="M:NVelocity.Runtime.Directive.Parse.Render(NVelocity.Context.IInternalContextAdapter,System.IO.TextWriter,NVelocity.Runtime.Parser.Node.INode)">
            <summary>
            iterates through the argument list and renders every
            argument that is appropriate.  Any non appropriate
            arguments are logged, but render() continues.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Directive.Parse.AssertTemplateStack(NVelocity.Context.IInternalContextAdapter)">
            <summary>
            See if we have exceeded the configured depth.
            If it isn't configured, put a stop at 20 just in case.
            </summary>
        </member>
        <member name="P:NVelocity.Runtime.Directive.Parse.Name">
            <summary>
            Return name of this directive.
            </summary>
        </member>
        <member name="P:NVelocity.Runtime.Directive.Parse.Type">
            <summary> Return type of this directive. </summary>
        </member>
        <member name="T:NVelocity.Runtime.Directive.ParseDirectiveException">
             <summary> Exception for #parse() problems
             *
             </summary>
             <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
             </author>
             <version> $Id: ParseDirectiveException.cs,v 1.3 2003/10/27 13:54:10 corts Exp $
            
             </version>
        </member>
        <member name="M:NVelocity.Runtime.Directive.ParseDirectiveException.#ctor(System.String,System.Int32)">
            <summary> Constructor
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Directive.ParseDirectiveException.addFile(System.String)">
            <summary> Get a message.
            </summary>
            <summary> Add a file to the filename stack
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Directive.VelocimacroProxy">
            <summary>
            VelocimacroProxy
            a proxy Directive-derived object to fit with the current directive system
            </summary>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a></author>
            <version> $Id: VelocimacroProxy.cs,v 1.4 2003/10/27 13:54:10 corts Exp $ </version>
        </member>
        <member name="M:NVelocity.Runtime.Directive.VelocimacroProxy.Init(NVelocity.Runtime.IRuntimeServices,NVelocity.Context.IInternalContextAdapter,NVelocity.Runtime.Parser.Node.INode)">
            <summary>
            The major meat of VelocimacroProxy, init() checks the # of arguments, 
            patches the macro body, renders the macro into an AST, and then inits 
            the AST, so it is ready for quick rendering.  Note that this is only 
            AST dependant stuff. Not context.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Directive.VelocimacroProxy.Render(NVelocity.Context.IInternalContextAdapter,System.IO.TextWriter,NVelocity.Runtime.Parser.Node.INode)">
            <summary>
            Renders the macro using the context
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Directive.VelocimacroProxy.setupMacro(System.String[],System.Int32[])">
            <summary>
            basic VM setup.  Sets up the proxy args for this
            use, and parses the tree
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Directive.VelocimacroProxy.parseTree(System.String[])">
            <summary>
            parses the macro.  We need to do this here, at init time, or else
            the local-scope template feature is hard to get to work :)
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Directive.VelocimacroProxy.getArgArray(NVelocity.Runtime.Parser.Node.INode)">
            <summary>
            Gets the args to the VM from the instance-use AST
            </summary>
        </member>
        <member name="P:NVelocity.Runtime.Directive.VelocimacroProxy.Name">
            <summary>
            The name of this Velocimacro.
            </summary>
        </member>
        <member name="P:NVelocity.Runtime.Directive.VelocimacroProxy.Type">
            <summary>
            Velocimacros are always LINE
            type directives.
            </summary>
        </member>
        <member name="P:NVelocity.Runtime.Directive.VelocimacroProxy.ArgArray">
            <summary>
            Sets the array of arguments specified in the macro definition
            </summary>
        </member>
        <member name="P:NVelocity.Runtime.Directive.VelocimacroProxy.NumArgs">
            <summary>
            Returns the number of ars needed for this VM
            </summary>
        </member>
        <member name="P:NVelocity.Runtime.Directive.VelocimacroProxy.Macrobody">
            <summary>
            Sets the orignal macro body.  This is simply the cat of the 
            macroArray, but the Macro object creates this once during parsing, 
            and everyone shares it.
            
            Note : it must not be modified.
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Directive.VMProxyArg">
             <summary>  
             The function of this class is to proxy for the calling parameter to the VM.
             *
             This class is designed to be used in conjunction with the VMContext class
             which knows how to get and set values via it, rather than a simple get()
             or put() from a hashtable-like object.
             *
             There is probably a lot of undocumented subtlty here, so step lightly.
             *
             We rely on the observation that an instance of this object has a constant
             state throughout its lifetime as it's bound to the use-instance of a VM.
             In other words, it's created by the VelocimacroProxy class, to represent
             one of the arguments to a VM in a specific template.  Since the template
             is fixed (it's a file...), we don't have to worry that the args to the VM
             will change.  Yes, the VM will be called in other templates, or in other
             places on the same template, bit those are different use-instances.
             *
             These arguments can be, in the lingo of
             the parser, one of :
             <ul>
             <li> Reference() : anything that starts with '$'</li>
             <li> StringLiteral() : something like "$foo" or "hello geir"</li>
             <li> NumberLiteral() : 1, 2 etc</li>
             <li> IntegerRange() : [ 1..2] or [$foo .. $bar]</li>
             <li> ObjectArray() : [ "a", "b", "c"]</li>
             <li> True() : true</li>
             <li> False() : false</li>
             <li>Word() : not likely - this is simply allowed by the parser so we can have
             syntactical sugar like #foreach($a in $b)  where 'in' is the Word</li>
             </ul>
             Now, Reference(), StringLit, NumberLit, IntRange, ObjArr are all dynamic things, so
             their value is gotten with the use of a context.  The others are constants.  The trick
             we rely on is that the context rather than this class really represents the
             state of the argument. We are simply proxying for the thing, returning the proper value
             when asked, and storing the proper value in the appropriate context when asked.
             *
             So, the hope here, so an instance of this can be shared across threads, is to
             keep any dynamic stuff out of it, relying on trick of having the appropriate
             context handed to us, and when a constant argument, letting VMContext punch that
             into a local context.
            
             </summary>
             <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
             </author>
             <version> $Id: VMProxyArg.cs,v 1.4 2003/10/27 13:54:10 corts Exp $
            
             </version>
        </member>
        <member name="F:NVelocity.Runtime.Directive.VMProxyArg.GENERALSTATIC">
            <summary>in the event our type is switched - we don't care really what it is
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Directive.VMProxyArg.type">
            <summary>type of arg I will have
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Directive.VMProxyArg.nodeTree">
            <summary>the AST if the type is such that it's dynamic (ex. JJTREFERENCE )
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Directive.VMProxyArg.staticObject">
            <summary>reference for the object if we proxy for a static arg like an NumberLiteral
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Directive.VMProxyArg.usercontext">
            <summary>not used in this impl : carries the appropriate user context
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Directive.VMProxyArg.numTreeChildren">
            <summary>number of children in our tree if a reference
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Directive.VMProxyArg.contextReference">
            <summary>our identity in the current context
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Directive.VMProxyArg.callerReference">
            <summary>the reference we are proxying for
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Directive.VMProxyArg.singleLevelRef">
            <summary>the 'de-dollared' reference if we are a ref but don't have a method attached
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Directive.VMProxyArg.constant">
            <summary>by default, we are dynamic.  safest
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Directive.VMProxyArg.#ctor(NVelocity.Runtime.IRuntimeServices,System.String,System.String,System.Int32)">
             <summary>  ctor for current impl
             *
             takes the reference literal we are proxying for, the literal
             the VM we are for is called with...
             *
             </summary>
             <param name="rs">
             </param>
             <param name="contextRef">reference arg in the definition of the VM, used in the VM
             </param>
             <param name="callerRef"> reference used by the caller as an arg to the VM
             </param>
             <param name="t"> type of arg : JJTREFERENCE, JJTTRUE, etc
            
             </param>
        </member>
        <member name="M:NVelocity.Runtime.Directive.VMProxyArg.isConstant">
             <summary>  tells if arg we are poxying for is
             dynamic or constant.
             *
             </summary>
             <returns>true of constant, false otherwise
            
             </returns>
        </member>
        <member name="M:NVelocity.Runtime.Directive.VMProxyArg.setObject(NVelocity.Context.IInternalContextAdapter,System.Object)">
             <summary>  Invoked by VMContext when Context.put() is called for a proxied reference.
             *
             </summary>
             <param name="context">context to modify via direct placement, or AST.setValue()
             </param>
             <param name="o"> new value of reference
             </param>
             <returns>Object currently null
            
             </returns>
        </member>
        <member name="M:NVelocity.Runtime.Directive.VMProxyArg.getObject(NVelocity.Context.IInternalContextAdapter)">
             <summary>  returns the value of the reference.  Generally, this is only
             called for dynamic proxies, as the static ones should have
             been stored in the VMContext's localcontext store
             *
             </summary>
             <param name="context">Context to use for getting current value
             </param>
             <returns>Object value
             *
            
             </returns>
        </member>
        <member name="M:NVelocity.Runtime.Directive.VMProxyArg.setup">
            <summary>  does the housekeeping upon creationg.  If a dynamic type
            it needs to make an AST for further get()/set() operations
            Anything else is constant.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Directive.VMProxyArg.#ctor(NVelocity.Runtime.Directive.VMProxyArg,NVelocity.Context.IInternalContextAdapter)">
            <summary>  not used in current impl
            *
            Constructor for alternate impl where VelProxy class would make new
            VMProxyArg objects, and use this contructor to avoid reparsing the
            reference args
            *
            that impl also had the VMProxyArg carry it's context
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Exception.ReferenceException">
             <summary> Exception thrown when a bad reference is found.
             *
             </summary>
             <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
             </author>
             <version> $Id: ReferenceException.cs,v 1.3 2003/10/27 13:54:10 corts Exp $
            
             </version>
        </member>
        <member name="F:NVelocity.Runtime.Log.LogLevel.Debug">
            <summary>
            Prefix for debug messages.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Log.LogLevel.Info">
            <summary>
            Prefix for info messages.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Log.LogLevel.Warn">
            <summary>
            Prefix for warning messages.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Log.LogLevel.Error">
            <summary>
            Prefix for error messages.
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Log.ILogSystem">
            <summary>
            Base interface that Logging systems need to implement.
            </summary>
            <author> <a href="mailto:jon@latchkey.com">Jon S. Stevens</a></author>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a></author>
        </member>
        <member name="M:NVelocity.Runtime.Log.ILogSystem.Init(NVelocity.Runtime.IRuntimeServices)">
            <summary>
            init()
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Log.ILogSystem.LogVelocityMessage(NVelocity.Runtime.Log.LogLevel,System.String)">
            <summary>
            Send a log message from Velocity.
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Log.LogManager">
            <summary>
            <p>
            This class is responsible for instantiating the correct LoggingSystem
            </p>
            <p>
            The approach is :
            </p>
            <ul>
            <li>
            First try to see if the user is passing in a living object
            that is a LogSystem, allowing the app to give is living
            custom loggers.
            </li>
            <li>
            Next, run through the (possible) list of classes specified
            specified as loggers, taking the first one that appears to
            work.  This is how we support finding either log4j or
            logkit, whichever is in the classpath, as both are
            listed as defaults.
            </li>
            <li>
            Finally, we turn to 'faith-based' logging, and hope that
            logkit is in the classpath, and try for an AvalonLogSystem
            as a final gasp.  After that, there is nothing we can do.
            </li>
            </ul>
            </summary>
            <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a></author>
            <author> <a href="mailto:jon@latchkey.com">Jon S. Stevens</a></author>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a></author>
        </member>
        <member name="M:NVelocity.Runtime.Log.LogManager.CreateLogSystem(NVelocity.Runtime.IRuntimeServices)">
            <summary>  Creates a new logging system or returns an existing one
            specified by the application.
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Log.NullLogSystem">
             <summary>  Logger used in case of failure. Does nothing.
             *
             </summary>
             <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
             </author>
             <version> $Id: NullLogSystem.cs,v 1.4 2003/10/27 13:54:10 corts Exp $
            
             </version>
        </member>
        <member name="M:NVelocity.Runtime.Log.NullLogSystem.LogVelocityMessage(NVelocity.Runtime.Log.LogLevel,System.String)">
            <summary>
            logs messages to the great Garbage Collector in the sky
            </summary>
            <param name="level">severity level</param>
            <param name="message">complete error message</param>
        </member>
        <member name="T:NVelocity.Runtime.Parser.Node.AbstractExecutor">
            <summary> Abstract class that is used to execute an arbitrary
            method that is in introspected. This is the superclass
            for the GetExecutor and PropertyExecutor.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Parser.Node.AbstractExecutor.method">
            <summary>
            Method to be executed.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.AbstractExecutor.Execute(System.Object)">
            <summary>
            Execute method against context.
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Parser.Node.ASTAddNode">
            <summary>
            Handles integer addition of nodes
            
            Please look at the Parser.jjt file which is
            what controls the generation of this class.
            </summary>
            <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a> </author>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a> </author>
            <version> $Id: ASTAddNode.cs,v 1.3 2003/10/27 13:54:10 corts Exp $ </version>
        </member>
        <member name="T:NVelocity.Runtime.Parser.Node.INode">
            <summary>  All AST nodes must implement this interface.  It provides basic
            machinery for constructing the parent and child relationships
            between nodes.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.INode.Open">
            <summary>
            This method is called after the node has been made the current
            node. It indicates that child nodes can now be added to it.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.INode.Close">
            <summary>
            This method is called after all the child nodes have been added.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.INode.AddChild(NVelocity.Runtime.Parser.Node.INode,System.Int32)">
            <summary>
            This method tells the node to add its argument to the node's
            list of children.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.INode.GetChild(System.Int32)">
            <summary>
            This method returns a child node.  The children are numbered
            from zero, left to right.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.INode.Accept(NVelocity.Runtime.Parser.Node.IParserVisitor,System.Object)">
            <summary>
            Accept the visitor.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.SimpleNode.Accept(NVelocity.Runtime.Parser.Node.IParserVisitor,System.Object)">
            <summary>Accept the visitor. *
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.SimpleNode.ChildrenAccept(NVelocity.Runtime.Parser.Node.IParserVisitor,System.Object)">
            <summary>Accept the visitor. *
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTAddNode.Accept(NVelocity.Runtime.Parser.Node.IParserVisitor,System.Object)">
            <summary>
            Accept the visitor.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTAddNode.Value(NVelocity.Context.IInternalContextAdapter)">
            <summary>
            Computes the sum of the two nodes.
            Currently only integer operations are supported.
            </summary>
            <returns>Integer object with value, or null</returns>
        </member>
        <member name="T:NVelocity.Runtime.Parser.Node.ASTAndNode">
            <summary>
            Please look at the Parser.jjt file which is
            what controls the generation of this class.
            </summary>
            <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a> </author>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a> </author>
            <version> $Id: ASTAndNode.cs,v 1.3 2003/10/27 13:54:10 corts Exp $ </version>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTAndNode.Accept(NVelocity.Runtime.Parser.Node.IParserVisitor,System.Object)">
            <summary>
            Accept the visitor.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTAndNode.Value(NVelocity.Context.IInternalContextAdapter)">
            <summary>  Returns the value of the expression.
            Since the value of the expression is simply the boolean
            result of evaluate(), lets return that.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTAndNode.Evaluate(NVelocity.Context.IInternalContextAdapter)">
            <summary>
            logical and :
            null &amp;&amp; right = false
            left &amp;&amp; null = false
            null &amp;&amp; null = false
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTAssignment.Accept(NVelocity.Runtime.Parser.Node.IParserVisitor,System.Object)">
            <summary>
            Accept the visitor.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTBlock.Accept(NVelocity.Runtime.Parser.Node.IParserVisitor,System.Object)">
            <summary>
            Accept the visitor.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTComment.Accept(NVelocity.Runtime.Parser.Node.IParserVisitor,System.Object)">
            <summary>
            Accept the visitor.
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Parser.Node.ASTDirective">
             <summary>
             This class is responsible for handling the pluggable
             directives in VTL. ex.  #foreach()
            
             Please look at the Parser.jjt file which is
             what controls the generation of this class.
             </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTDirective.Accept(NVelocity.Runtime.Parser.Node.IParserVisitor,System.Object)">
            <summary>
            Accept the visitor.
            </summary>
        </member>
        <member name="P:NVelocity.Runtime.Parser.Node.ASTDirective.DirectiveName">
            <summary>
            Gets or sets the directive name.
            Used by the parser.  
            This keeps us from having to
            dig it out of the token stream and gives the parse 
            the change to override.
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Parser.Node.ASTDivNode">
            <summary> Handles integer division of nodes
            
            Please look at the Parser.jjt file which is
            what controls the generation of this class.
            </summary>
            <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a> </author>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a> </author>
            <version> $Id: ASTDivNode.cs,v 1.3 2003/10/27 13:54:10 corts Exp $ </version>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTDivNode.Accept(NVelocity.Runtime.Parser.Node.IParserVisitor,System.Object)">
            <summary>
            Accept the visitor.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTDivNode.Value(NVelocity.Context.IInternalContextAdapter)">
            <summary>
            Computes the result of the division. Currently limited to Integers.
            </summary>
            <returns>Integer(value) or null</returns>
        </member>
        <member name="T:NVelocity.Runtime.Parser.Node.ASTElseIfStatement">
             <summary> This class is responsible for handling the ElseIf VTL control statement.
            
             Please look at the Parser.jjt file which is
             what controls the generation of this class.
             *
             </summary>
             <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a>
             </author>
             <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
             </author>
             <version> $Id: ASTElseIfStatement.cs,v 1.3 2003/10/27 13:54:10 corts Exp $
             </version>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTElseIfStatement.Accept(NVelocity.Runtime.Parser.Node.IParserVisitor,System.Object)">
            <summary>
            Accept the visitor.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTElseIfStatement.Evaluate(NVelocity.Context.IInternalContextAdapter)">
            <summary>
            An ASTElseStatement is true if the expression
            it contains evaluates to true. Expressions know
            how to evaluate themselves, so we do that
            here and return the value back to ASTIfStatement
            where this node was originally asked to evaluate
            itself.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTElseIfStatement.Render(NVelocity.Context.IInternalContextAdapter,System.IO.TextWriter)">
            <summary>
            renders the block
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Parser.Node.ASTElseStatement">
             <summary>
             This class is responsible for handling the Else VTL control statement.
            
             Please look at the Parser.jjt file which is
             what controls the generation of this class.
             </summary>
             <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a> </author>
             <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a> </author>
             <version> $Id: ASTElseStatement.cs,v 1.3 2003/10/27 13:54:10 corts Exp $ </version>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTElseStatement.Accept(NVelocity.Runtime.Parser.Node.IParserVisitor,System.Object)">
            <summary>
            Accept the visitor.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTElseStatement.Evaluate(NVelocity.Context.IInternalContextAdapter)">
            <summary>
            An ASTElseStatement always evaluates to
            true. Basically behaves like an #if(true).
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Parser.Node.ASTEQNode">
            <summary>
            Handles the equivalence operator
            
            &lt;arg1&gt;  == &lt;arg2&gt;
            
            This operator requires that the LHS and RHS are both of the
            same Class.
            </summary>
            <version> $Id: ASTEQNode.cs,v 1.3 2003/10/27 13:54:10 corts Exp $ </version>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTEQNode.Accept(NVelocity.Runtime.Parser.Node.IParserVisitor,System.Object)">
            <summary>Accept the visitor. *
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTEQNode.Evaluate(NVelocity.Context.IInternalContextAdapter)">
            <summary>
            Calculates the value of the logical expression
            
            arg1 == arg2
            
            All class types are supported.   Uses equals() to
            determine equivalence.  This should work as we represent
            with the types we already support, and anything else that
            implements equals() to mean more than identical references.
            </summary>
            <param name="context"> internal context used to evaluate the LHS and RHS </param>
            <returns>
            true if equivalent, false if not equivalent,
            false if not compatible arguments, or false
            if either LHS or RHS is null
            </returns>
        </member>
        <member name="T:NVelocity.Runtime.Parser.Node.ASTEscape">
             <summary> This class is responsible for handling Escapes
             in VTL.
            
             Please look at the Parser.jjt file which is
             what controls the generation of this class.
             *
             </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTEscape.Accept(NVelocity.Runtime.Parser.Node.IParserVisitor,System.Object)">
            <summary>Accept the visitor. *
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Parser.Node.ASTEscapedDirective">
             <summary>
             This class is responsible for handling EscapedDirectives
             in VTL.
            
             Please look at the Parser.jjt file which is
             what controls the generation of this class.
             </summary>
             <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a> </author>
             <version> $Id: ASTEscapedDirective.cs,v 1.3 2003/10/27 13:54:10 corts Exp $ </version>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTEscapedDirective.Accept(NVelocity.Runtime.Parser.Node.IParserVisitor,System.Object)">
            <summary>
            Accept the visitor.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTExpression.Accept(NVelocity.Runtime.Parser.Node.IParserVisitor,System.Object)">
            <summary>
            Accept the visitor.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTFalse.Accept(NVelocity.Runtime.Parser.Node.IParserVisitor,System.Object)">
            <summary>
            Accept the visitor.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTGENode.Accept(NVelocity.Runtime.Parser.Node.IParserVisitor,System.Object)">
            <summary>
            Accept the visitor.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTGTNode.Accept(NVelocity.Runtime.Parser.Node.IParserVisitor,System.Object)">
            <summary>
            Accept the visitor.
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Parser.Node.ASTIdentifier">
            <summary>
            ASTIdentifier.java
            
            Method support for identifiers :  $foo
            
            mainly used by ASTRefrence
            
            Introspection is now moved to 'just in time' or at render / execution
            time. There are many reasons why this has to be done, but the
            primary two are   thread safety, to remove any context-derived
            information from class member  variables.
            </summary>
            <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a> </author>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a> </author>
            <version> $Id: ASTIdentifier.cs,v 1.5 2004/12/27 05:55:30 corts Exp $ </version>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTIdentifier.Accept(NVelocity.Runtime.Parser.Node.IParserVisitor,System.Object)">
            <summary>
            Accept the visitor.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTIdentifier.Init(NVelocity.Context.IInternalContextAdapter,System.Object)">
            <summary>
            simple init - don't do anything that is context specific.
            just get what we need from the AST, which is static.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTIdentifier.Execute(System.Object,NVelocity.Context.IInternalContextAdapter)">
            <summary>
            invokes the method on the object passed in
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTIfStatement.Accept(NVelocity.Runtime.Parser.Node.IParserVisitor,System.Object)">
            <summary>
            Accept the visitor.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTIncludeStatement.Accept(NVelocity.Runtime.Parser.Node.IParserVisitor,System.Object)">
            <summary>Accept the visitor.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTIntegerRange.Accept(NVelocity.Runtime.Parser.Node.IParserVisitor,System.Object)">
            <summary>
            Accept the visitor.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTIntegerRange.Value(NVelocity.Context.IInternalContextAdapter)">
            <summary>
            does the real work.  Creates an Vector of Integers with the
            right value range
            </summary>
            <param name="context">app context used if Left or Right of .. is a ref</param>
            <returns>Object array of Integers</returns>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTLENode.Accept(NVelocity.Runtime.Parser.Node.IParserVisitor,System.Object)">
            <summary>Accept the visitor. *
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTLTNode.Accept(NVelocity.Runtime.Parser.Node.IParserVisitor,System.Object)">
            <summary>
            Accept the visitor.
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Parser.Node.ASTMap">
            <summary>
            AST Node for creating a map / dictionary.
            This class was originally generated from Parset.jjt.
            </summary>
            <version>$Id: ASTMap.cs,v 1.2 2004/12/27 05:50:11 corts Exp $</version>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTMap.Accept(NVelocity.Runtime.Parser.Node.IParserVisitor,System.Object)">
            <summary>
            Accept the visitor. 
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTMap.Value(NVelocity.Context.IInternalContextAdapter)">
            <summary>
            Evaluate the node.
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Parser.Node.ASTMethod">
             <summary>
             Method support for references :  $foo.method()
            
             NOTE :
            
             introspection is now done at render time.
            
             Please look at the Parser.jjt file which is
             what controls the generation of this class.
             </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTMethod.Accept(NVelocity.Runtime.Parser.Node.IParserVisitor,System.Object)">
            <summary>
            Accept the visitor.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTMethod.Init(NVelocity.Context.IInternalContextAdapter,System.Object)">
            <summary>
            simple init - init our subtree and get what we can from
            the AST
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTMethod.Execute(System.Object,NVelocity.Context.IInternalContextAdapter)">
            <summary>
            invokes the method.  Returns null if a problem, the
            actual return if the method returns something, or
            an empty string "" if the method returns void
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTMethod.doIntrospection(NVelocity.Context.IInternalContextAdapter,System.Type)">
             <summary>
             does the instrospection of the class for the method needed.
             Note, as this calls value() on the args if any, this must
             only be called at execute() / render() time.
            
             NOTE: this will try to flip the case of the first character for
             convience (compatability with Java version).  If there are no arguments,
             it will also try to find a property with the same name (also flipping first character).
             </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTModNode.Accept(NVelocity.Runtime.Parser.Node.IParserVisitor,System.Object)">
            <summary>
            Accept the visitor.
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Parser.Node.ASTMulNode">
            <summary>
            Handles integer multiplication
            
            Please look at the Parser.jjt file which is
            what controls the generation of this class.
            </summary>
            <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a> </author>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a> </author>
            <version> $Id: ASTMulNode.cs,v 1.3 2003/10/27 13:54:10 corts Exp $ </version>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTMulNode.Accept(NVelocity.Runtime.Parser.Node.IParserVisitor,System.Object)">
            <summary>Accept the visitor. *
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTMulNode.Value(NVelocity.Context.IInternalContextAdapter)">
            <summary>
            Computes the product of the two args.
            Returns null if either arg is null
            or if either arg is not an integer
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTNENode.Accept(NVelocity.Runtime.Parser.Node.IParserVisitor,System.Object)">
            <summary>
            Accept the visitor.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTNotNode.Accept(NVelocity.Runtime.Parser.Node.IParserVisitor,System.Object)">
            <summary>
            Accept the visitor.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTNumberLiteral.Accept(NVelocity.Runtime.Parser.Node.IParserVisitor,System.Object)">
            <summary>Accept the visitor. *
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTNumberLiteral.Init(NVelocity.Context.IInternalContextAdapter,System.Object)">
            <summary>  Initialization method - doesn't do much but do the object
            creation.  We only need to do it once.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTObjectArray.Accept(NVelocity.Runtime.Parser.Node.IParserVisitor,System.Object)">
            <summary>
            Accept the visitor.
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Parser.Node.ASTOrNode">
            <summary>
            Please look at the Parser.jjt file which is what controls 
            the generation of this class.
            </summary>
            <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a> </author>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a> </author>
            <version> $Id: ASTOrNode.cs,v 1.3 2003/10/27 13:54:10 corts Exp $ </version>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTOrNode.Accept(NVelocity.Runtime.Parser.Node.IParserVisitor,System.Object)">
            <summary>Accept the visitor. *
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTOrNode.Value(NVelocity.Context.IInternalContextAdapter)">
            <summary>  Returns the value of the expression.
            Since the value of the expression is simply the boolean
            result of evaluate(), lets return that.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTOrNode.Evaluate(NVelocity.Context.IInternalContextAdapter)">
            <summary>
            the logical or :
            the rule :
            left || null -> left
            null || right -> right
            null || null -> false
            left || right ->  left || right
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTParameters.Accept(NVelocity.Runtime.Parser.Node.IParserVisitor,System.Object)">
            <summary>
            Accept the visitor.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTprocess.Accept(NVelocity.Runtime.Parser.Node.IParserVisitor,System.Object)">
            <summary>Accept the visitor. *
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Parser.Node.ReferenceType">
            <summary>
            Reference types
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Parser.Node.ASTReference">
             <summary>
             This class is responsible for handling the references in
             VTL ($foo).
            
             Please look at the Parser.jjt file which is
             what controls the generation of this class.
             </summary>
             <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a></author>
             <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a></author>
             <author> <a href="mailto:Christoph.Reck@dlr.de">Christoph Reck</a></author>
             <author> <a href="mailto:kjohnson@transparent.com">Kent Johnson</a></author>
             <version> $Id: ASTReference.cs,v 1.4 2003/10/27 13:54:10 corts Exp $ </version>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTReference.Accept(NVelocity.Runtime.Parser.Node.IParserVisitor,System.Object)">
            <summary>Accept the visitor.</summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTReference.Execute(System.Object,NVelocity.Context.IInternalContextAdapter)">
            <summary>
            gets an Object that 'is' the value of the reference
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTReference.Render(NVelocity.Context.IInternalContextAdapter,System.IO.TextWriter)">
            <summary>
            gets the value of the reference and outputs it to the
            writer.
            </summary>
            <param name="context"> context of data to use in getting value </param>
            <param name="writer">  writer to render to </param>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTReference.Evaluate(NVelocity.Context.IInternalContextAdapter)">
            <summary>   
            Computes boolean value of this reference
            Returns the actual value of reference return type
            boolean, and 'true' if value is not null
            </summary>
            <param name="context">context to compute value with</param>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTReference.SetValue(NVelocity.Context.IInternalContextAdapter,System.Object)">
            <summary>
            Sets the value of a complex reference (something like $foo.bar)
            Currently used by ASTSetReference()
            </summary>
            <seealso cref="T:NVelocity.Runtime.Parser.Node.ASTSetDirective"/>
            <param name="context">context object containing this reference</param>
            <param name="value">Object to set as value</param>
            <returns>true if successful, false otherwise</returns>
        </member>
        <member name="P:NVelocity.Runtime.Parser.Node.ASTReference.RootString">
            <summary>
            Returns the 'root string', the reference key
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Parser.Node.ASTSetDirective">
            <summary> 
            Node for the #set directive
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTSetDirective.Accept(NVelocity.Runtime.Parser.Node.IParserVisitor,System.Object)">
            <summary>Accept the visitor. *
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTSetDirective.Init(NVelocity.Context.IInternalContextAdapter,System.Object)">
            <summary>  simple init.  We can get the RHS and LHS as the the tree structure is static
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTSetDirective.Render(NVelocity.Context.IInternalContextAdapter,System.IO.TextWriter)">
            <summary>   puts the value of the RHS into the context under the key of the LHS
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Parser.Node.ASTStringLiteral">
            <summary> 
            ASTStringLiteral support.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTStringLiteral.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NVelocity.Runtime.Parser.Node.ASTStringLiteral"/> class.
            </summary>
            <param name="id">The id.</param>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTStringLiteral.#ctor(NVelocity.Runtime.Parser.Parser,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NVelocity.Runtime.Parser.Node.ASTStringLiteral"/> class.
            </summary>
            <param name="p">The p.</param>
            <param name="id">The id.</param>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTStringLiteral.Init(NVelocity.Context.IInternalContextAdapter,System.Object)">
            <summary>  init : we don't have to do much.  Init the tree (there
            shouldn't be one) and then see if interpolation is turned on.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTStringLiteral.Accept(NVelocity.Runtime.Parser.Node.IParserVisitor,System.Object)">
            <summary>Accept the visitor. *
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTStringLiteral.Value(NVelocity.Context.IInternalContextAdapter)">
            <summary>  renders the value of the string literal
            If the properties allow, and the string literal contains a $ or a #
            the literal is rendered against the context
            Otherwise, the stringlit is returned.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTStringLiteral.InterpolateDictionaryString(System.String,NVelocity.Context.IInternalContextAdapter)">
            <summary>
            Interpolates the dictionary string.
            dictionary string is any string in the format
            "%{ key='value' [,key2='value2' }"		
            "%{ key='value' [,key2='value2'] }"		
            </summary>
            <param name="str">If valid input a HybridDictionary with zero or more items,
            otherwise the input string</param>
            <param name="context">NVelocity runtime context</param>
        </member>
        <member name="T:NVelocity.Runtime.Parser.Node.ASTSubtractNode">
            <summary>
            Handles integer subtraction of nodes (in #set() )
            
            Please look at the Parser.jjt file which is
            what controls the generation of this class.
            </summary>
            <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a> </author>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a> </author>
            <version> $Id: ASTSubtractNode.cs,v 1.3 2003/10/27 13:54:10 corts Exp $ </version>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTSubtractNode.Accept(NVelocity.Runtime.Parser.Node.IParserVisitor,System.Object)">
            <summary>
            Accept the visitor.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTSubtractNode.Value(NVelocity.Context.IInternalContextAdapter)">
            <summary>
            Computes the value of the subtraction.
            Currently limited to integers.
            </summary>
            <returns>Integer(value) or null</returns>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTText.Accept(NVelocity.Runtime.Parser.Node.IParserVisitor,System.Object)">
            <summary>
            Accept the visitor.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTTrue.Accept(NVelocity.Runtime.Parser.Node.IParserVisitor,System.Object)">
            <summary>
            Accept the visitor.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTVariable.Accept(NVelocity.Runtime.Parser.Node.IParserVisitor,System.Object)">
            <summary>
            Accept the visitor.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTWord.Accept(NVelocity.Runtime.Parser.Node.IParserVisitor,System.Object)">
            <summary>
            Accept the visitor.
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Parser.Node.BooleanPropertyExecutor">
             <summary>  Handles discovery and valuation of a
             boolean object property, of the
             form public boolean is&lt;property&gt; when executed.
            
             We do this separately as to preserve the current
             quasi-broken semantics of get&lt;as is property&gt;
             get&lt; flip 1st char&gt; get("property") and now followed
             by is&lt;Property&gt;
             </summary>
        </member>
        <member name="T:NVelocity.Runtime.Parser.Node.PropertyExecutor">
            <summary>
            Returned the value of object property when executed.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.PropertyExecutor.Execute(System.Object)">
            <summary>
            Execute property against context.
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Parser.Node.GetExecutor">
            <summary>
            Executor that simply tries to execute a get(key)
            operation. This will try to find a get(key) method
            for any type of object, not just objects that
            implement the Map interface as was previously
            the case.
            </summary>
            <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a></author>
            <remarks>
            Add discovery for .NET default property, using
            <see cref="M:System.Type.GetDefaultMembers"/>.
            </remarks>
        </member>
        <member name="F:NVelocity.Runtime.Parser.Node.GetExecutor.args">
            <summary>
            Container to hold the 'key' part of get(key).
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.GetExecutor.#ctor(NVelocity.Runtime.IRuntimeLogger,NVelocity.Util.Introspection.Introspector,System.Type,System.String)">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.GetExecutor.Execute(System.Object)">
            <summary>
            Execute method against context.
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Parser.Node.NodeUtils">
             <summary> Utilities for dealing with the AST node structure.
             *
             </summary>
             <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a>
             </author>
             <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
             </author>
             <version> $Id: NodeUtils.cs,v 1.4 2003/10/27 13:54:10 corts Exp $
            
             </version>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.NodeUtils.specialText(NVelocity.Runtime.Parser.Token)">
            <summary> Collect all the &lt;SPECIAL_TOKEN&gt;s that
            are carried along with a token. Special
            tokens do not participate in parsing but
            can still trigger certain lexical actions.
            In some cases you may want to retrieve these
            special tokens, this is simply a way to
            extract them.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.NodeUtils.tokenLiteral(NVelocity.Runtime.Parser.Token)">
            <summary>  complete node literal
            *
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.NodeUtils.interpolate(System.String,NVelocity.Context.IContext)">
            <summary> Utility method to interpolate context variables
            into string literals. So that the following will
            work:
            *
            #set $name = "candy"
            $image.getURI("${name}.jpg")
            *
            And the string literal argument will
            be transformed into "candy.jpg" before
            the method is executed.
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Parser.Node.ObjectComparer">
            <summary>
            ObjectComparer allows you to compare primitive types and some others
            using IComparable interface whenever possible, and performing type
            conversions to get the best possible result.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ObjectComparer.CompareObjects(System.Object,System.Object)">
            <summary>
            Tries to compare two random objects.  -1 is returned 
            if x is smaller than y, 1 the other way around, or 0 
            if they are equal.
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Parser.ICharStream">
             <summary> 
             This interface describes a character stream that maintains line and
             column number positions of the characters.  It also has the capability
             to backup the stream to some extent.  An implementation of this
             interface is used in the TokenManager implementation generated by
             JavaCCParser.
            
             All the methods except backup can be implemented in any fashion. backup
             needs to be implemented correctly for the correct operation of the lexer.
             Rest of the methods are all used to get information like line number,
             column number and the String that constitutes a token and are not used
             by the lexer. Hence their implementation won't affect the generated lexer's
             operation.
             </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.ICharStream.ReadChar">
            <summary> Returns the next character from the selected input.  The method
            of selecting the input is the responsibility of the class
            implementing this interface.  Can throw any java.io.IOException.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.ICharStream.Backup(System.Int32)">
            <summary> Backs up the input stream by amount steps. Lexer calls this method if it
            had already read some characters, but could not use them to match a
            (longer) token. So, they will be used again as the prefix of the next
            token and it is the implemetation's responsibility to do this right.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.ICharStream.BeginToken">
            <summary> Returns the next character that marks the beginning of the next token.
            All characters must remain in the buffer between two successive calls
            to this method to implement backup correctly.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.ICharStream.GetImage">
            <summary> Returns a string made up of characters from the marked token beginning
            to the current buffer position. Implementations have the choice of returning
            anything that they want to. For example, for efficiency, one might decide
            to just return null, which is a valid implementation.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.ICharStream.GetSuffix(System.Int32)">
             <summary> 
             Returns an array of characters that make up the suffix of length 'len' for
             the currently matched token. This is used to build up the matched string
             for use in actions in the case of MORE. A simple and inefficient
             implementation of this is as follows :
            
             {
             String t = GetImage();
             return t.substring(t.length() - len, t.length()).toCharArray();
             }
             </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.ICharStream.Done">
            <summary> The lexer calls this function to indicate that it is done with the stream
            and hence implementations can free any resources held by this class.
            Again, the body of this function can be just empty and it will not
            affect the lexer's operation.
            </summary>
        </member>
        <member name="P:NVelocity.Runtime.Parser.ICharStream.Column">
            <summary>
            Gets the column.
            </summary>
            <value>The column.</value>
        </member>
        <member name="P:NVelocity.Runtime.Parser.ICharStream.Line">
            <summary>
            Gets the line.
            </summary>
            <value>The line.</value>
        </member>
        <member name="P:NVelocity.Runtime.Parser.ICharStream.EndColumn">
            <summary>
            Gets the end column.
            </summary>
            <value>The end column.</value>
        </member>
        <member name="P:NVelocity.Runtime.Parser.ICharStream.EndLine">
            <summary>
            Gets the end line.
            </summary>
            <value>The end line.</value>
        </member>
        <member name="P:NVelocity.Runtime.Parser.ICharStream.BeginColumn">
            <summary>
            Gets the begin column.
            </summary>
            <value>The begin column.</value>
        </member>
        <member name="P:NVelocity.Runtime.Parser.ICharStream.BeginLine">
            <summary>
            Gets the begin line.
            </summary>
            <value>The begin line.</value>
        </member>
        <member name="T:NVelocity.Runtime.Parser.ParseException">
            <summary> This exception is thrown when parse errors are encountered.
            You can explicitly create objects of this exception type by
            calling the method generateParseException in the generated
            parser.
            *
            You can modify this class to customize your error reporting
            mechanisms so long as you retain the public fields.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Parser.ParseException.eol">
            <summary> The end of line string for this machine.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.ParseException.#ctor(NVelocity.Runtime.Parser.Token,System.Int32[][],System.String[])">
            <summary> This constructor is used by the method "generateParseException"
            in the generated parser.  Calling this constructor generates
            a new object of this type with the fields "currentToken",
            "expectedTokenSequences", and "tokenImage" set.  The boolean
            flag "specialConstructor" is also set to true to indicate that
            this constructor was used to create this object.
            This constructor calls its super class with the empty string
            to force the "toString" method of parent class "Throwable" to
            print the error message in the form:
            ParseException: &lt;result of getMessage&gt;
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.ParseException.#ctor">
            <summary> The following constructors are for use by you for whatever
            purpose you can think of.  Constructing the exception in this
            manner makes the exception behave in the normal way - i.e., as
            documented in the class "Throwable".  The fields "errorToken",
            "expectedTokenSequences", and "tokenImage" do not contain
            relevant information.  The JavaCC generated code does not use
            these constructors.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Parser.ParseException.specialConstructor">
            <summary> This variable determines which constructor was used to create
            this object and thereby affects the semantics of the
            "getMessage" method (see below).
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Parser.ParseException.currentToken">
            <summary> This is the last token that has been consumed successfully.  If
            this object has been created due to a parse error, the token
            followng this token will (therefore) be the first error token.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Parser.ParseException.expectedTokenSequences">
            <summary> Each entry in this array is an array of integers.  Each array
            of integers represents a sequence of tokens (by their ordinal
            values) that is expected at this point of the parse.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Parser.ParseException.tokenImage">
            <summary> This is a reference to the "tokenImage" array of the generated
            parser within which the parse error occurred.  This array is
            defined in the generated ...Constants interface.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.ParseException.add_escapes(System.String)">
            <summary> This method has the standard behavior when this object has been
            created using the standard constructors.  Otherwise, it uses
            "currentToken" and "expectedTokenSequences" to generate a parse
            error message and returns it.  If this object has been created
            due to a parse error, and you do not catch it (it gets thrown
            from the parser), then this method is called during the printing
            of the final stack trace, and hence the correct error message
            gets displayed.
            </summary>
            <summary> Used to convert raw characters to their escaped version
            when these raw version cannot be used as part of an ASCII
            string literal.
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Parser.Parser">
             <summary> This class is responsible for parsing a Velocity
             template. This class was generated by JavaCC using
             the JJTree extension to produce an Abstract
             Syntax Tree (AST) of the template.
            
             Please look at the Parser.jjt file which is
             what controls the generation of this class.
             </summary>
        </member>
        <member name="F:NVelocity.Runtime.Parser.Parser.directives">
            <summary>  This Hashtable contains a list of all of the dynamic directives.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Parser.Parser.currentTemplateName">
            <summary>  Name of current template we are parsing.  Passed to us in parse()
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Parser.#ctor(NVelocity.Runtime.IRuntimeServices)">
            <summary> 
            This constructor was added to allow the re-use of parsers.
            The normal constructor takes a single argument which
            an InputStream. This simply creates a re-usable parser
            object, we satisfy the requirement of an InputStream
            by using a newline character as an input stream.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Parser.Parse(System.IO.TextReader,System.String)">
            
             <summary> This was also added to allow parsers to be
             re-usable. Normal JavaCC use entails passing an
             input stream to the constructor and the parsing
             process is carried out once. We want to be able
             to re-use parsers: we do this by adding this
             method and re-initializing the lexer with
             the new stream that we want parsed.
             </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Parser.IsDirective(System.String)">
            <summary>  This method finds out of the directive exists in the directives
            Hashtable.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Parser.EscapedDirective(System.String)">
            <summary> Produces a processed output for an escaped control or
            pluggable directive
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Parser.Process">
            <summary> This method is what starts the whole parsing
            process. After the parsing is complete and
            the template has been turned into an AST,
            this method returns the root of AST which
            can subsequently be traversed by a visitor
            which implements the ParserVisitor interface
            which is generated automatically by JavaCC
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Parser.Statement">
            <summary> These are the types of statements that
            are acceptable in Velocity templates.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Parser.EscapedDirective">
            <summary>  used to separate the notion of a valid directive that has been
            escaped, versus something that looks like a directive and
            is just schmoo.  This is important to do as a separate production
            that creates a node, because we want this, in either case, to stop
            the further parsing of the Directive() tree.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Parser.Escape">
            <summary>  Used to catch and process escape sequences in grammatical constructs
            as escapes outside of VTL are just characters.  Right now we have both
            this and the EscapeDirective() construction because in the EscapeDirective()
            case, we want to suck in the #&lt;directive&gt; and here we don't.  We just want
            the escapes to render correctly
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Parser.Identifier">
            <summary> This method corresponds to variable
            references in Velocity templates.
            The following are examples of variable
            references that may be found in a
            template:
            *
            $foo
            $bar
            *
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Parser.DirectiveArg">
            <summary>   Supports the arguments for the Pluggable Directives
            We add whitespace in here as a token so the VMs can
            easily reconstruct a macro body from the token stream
            See Directive()
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Parser.Directive">
            <summary>   Supports the Pluggable Directives
            #foo( arg+ )
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Parser.IntegerRange">
            <summary>  supports the [n..m] vector generator for use in
            the #foreach() to generate measured ranges w/o
            needing explicit support from the app/servlet
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Parser.Parameter">
            <summary> This method has yet to be fully implemented
            but will allow arbitrarily nested method
            calls
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Parser.Method">
            <summary> This method has yet to be fully implemented
            but will allow arbitrarily nested method
            calls
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Parser.Text">
            <summary> This method is responsible for allowing
            all non-grammar text to pass through
            unscathed.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Parser.SetDirective">
            <summary>  Currently support both types of set :
            #set( expr )
            #set expr
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Parser.StopStatement">
            <summary> This method corresponds to the #stop
            directive which just simulates and EOF
            so that parsing stops. The #stop directive
            is useful for end-user debugging
            purposes.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.ParserTokenManager.StateStackPop">
              pushes the current state onto the 'state stack',
              and maintains the parens counts
              public because we need it in PD &amp; VM handling
            
              @return bool : success.  It can fail if the state machine
                 gets messed up (do don't mess it up :)
        </member>
        <member name="M:NVelocity.Runtime.Parser.ParserTokenManager.StateStackPush">
              pops a state off the stack, and restores paren counts
            
              @return bool : success of operation
        </member>
        <member name="M:NVelocity.Runtime.Parser.ParserTokenManager.ClearStateVars">
            Clears all state variables, resets to
            start values, clears stateStack.  Call
            before parsing.
            @return void
        </member>
        <member name="M:NVelocity.Runtime.Parser.ParserTokenManager.RPARENHandler">
            handles the dropdown logic when encountering a RPAREN
        </member>
        <member name="M:NVelocity.Runtime.Parser.ParserTreeConstants.#ctor">
            <summary>
            private constructor as class is meant to hold constants only.
            Class was orginally an interface in Java, but as C# does not support Fields in an interface and
            the jjtNodeName field, I converted it to a class with no constructor.
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Parser.Token">
            <summary>
            Describes the input token stream.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Parser.Token.Kind">
            <summary>
            An integer that describes the kind of this token.  This numbering
            system is determined by JavaCCParser, and a table of these numbers is
            stored in the file ...Constants.java.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Parser.Token.BeginLine">
            <summary>
            beginLine and beginColumn describe the position of the first character
            of this token; endLine and endColumn describe the position of the
            last character of this token.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Parser.Token.BeginColumn">
            <summary>
            beginLine and beginColumn describe the position of the first character
            of this token; endLine and endColumn describe the position of the
            last character of this token.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Parser.Token.EndLine">
            <summary>
            beginLine and beginColumn describe the position of the first character
            of this token; endLine and endColumn describe the position of the
            last character of this token.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Parser.Token.EndColumn">
            <summary>
            beginLine and beginColumn describe the position of the first character
            of this token; endLine and endColumn describe the position of the
            last character of this token.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Parser.Token.Image">
            <summary> The string image of the token. </summary>
        </member>
        <member name="F:NVelocity.Runtime.Parser.Token.Next">
            <summary>
            A reference to the next regular (non-special) token from the input
            stream.  If this is the last token from the input stream, or if the
            token manager has not read tokens beyond this one, this field is
            set to null.  This is true only if this token is also a regular
            token.  Otherwise, see below for a description of the contents of
            this field.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Parser.Token.SpecialToken">
            <summary>
            This field is used to access special tokens that occur prior to this
            token, but after the immediately preceding regular (non-special) token.
            If there are no such special tokens, this field is set to null.
            When there are more than one such special token, this field refers
            to the last of these special tokens, which in turn refers to the next
            previous special token through its specialToken field, and so on
            until the first special token (whose specialToken field is null).
            The next fields of special tokens refer to other special tokens that
            immediately follow it (without an intervening regular token).  If there
            is no such token, this field is null.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Token.ToString">
            <summary>
            Returns the image.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Token.NewToken(System.Int32)">
            <summary>
            Returns a new Token object, by default. However, if you want, you
            can create and return subclass objects based on the value of ofKind.
            Simply add the cases to the switch for all those special cases.
            For example, if you have a subclass of Token called IDToken that
            you want to create if ofKind is ID, simlpy add something like :
            
            <c>case MyParserConstants.ID : return new IDToken();</c>
            
            to the following switch statement. Then you can cast matchedToken
            variable to the appropriate type and use it in your lexical actions.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Parser.TokenMgrError.LEXICAL_ERROR">
            <summary> Lexical error occured.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Parser.TokenMgrError.STATIC_LEXER_ERROR">
            <summary> An attempt wass made to create a second instance of a static token manager.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Parser.TokenMgrError.INVALID_LEXICAL_STATE">
            <summary> Tried to change to an invalid lexical state.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Parser.TokenMgrError.LOOP_DETECTED">
            <summary> Detected (and bailed out of) an infinite loop in the token manager.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Parser.TokenMgrError.errorCode">
            <summary> Indicates the reason why the exception is thrown. It will have
            one of the above 4 values.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.TokenMgrError.AddEscapes(System.String)">
            <summary> Replaces unprintable characters by their espaced (or unicode escaped)
            equivalents in the given string
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.TokenMgrError.LexicalError(System.Boolean,System.Int32,System.Int32,System.Int32,System.String,System.Char)">
            <summary> Returns a detailed message for the Error when it is thrown by the
            token manager to indicate a lexical error.
            Parameters :
            EOFSeen     : indicates if EOF caused the lexicl error
            curLexState : lexical state in which this error occured
            errorLine   : line number when the error occured
            errorColumn : column number when the error occured
            errorAfter  : prefix that was seen before this error occured
            curchar     : the offending character
            Note: You can customize the lexical error message by modifying this method.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.TokenMgrError.#ctor">
            <summary> You can also modify the body of this method to customize your error messages.
            For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not
            of end-users concern, so you can return something like :
            *
            "Internal Error : Please file a bug report .... "
            *
            from this method for such cases in the release version of your parser.
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Parser.VelocityCharStream">
             <summary>  NOTE : This class was originally an ASCII_CharStream autogenerated
             by Javacc.  It was then modified via changing class name with appropriate
             fixes for CTORS, and mods to readChar().
            
             This is safe because we *always* use Reader with this class, and never a
             InputStream.  This guarantees that we have a correct stream of 16-bit
             chars - all encoding transformations have been done elsewhere, so we
             believe that there is no risk in doing this.  Time will tell :)
             </summary>
             <summary> An implementation of interface CharStream, where the stream is assumed to
             contain only ASCII characters (without unicode processing).
             </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.VelocityCharStream.AdjustBeginLineColumn(System.Int32,System.Int32)">
            <summary> Method to adjust line and column numbers for the start of a token.<br/>
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Resource.Loader.ResourceLoader">
            <summary>
            This is abstract class the all text resource loaders should extend.
            </summary>
            <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a></author>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a></author>
            <version> $Id: ResourceLoader.cs,v 1.3 2003/10/27 13:54:11 corts Exp $</version>
        </member>
        <member name="F:NVelocity.Runtime.Resource.Loader.ResourceLoader.isCachingOn">
            <summary>
            Does this loader want templates produced with it
            cached in the Runtime.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Resource.Loader.ResourceLoader.modificationCheckInterval">
            <summary>
            This property will be passed on to the templates
            that are created with this loader.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Resource.Loader.ResourceLoader.className">
            <summary>
            Class name for this loader, for logging/debuggin
            purposes.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Resource.Loader.ResourceLoader.CommonInit(NVelocity.Runtime.IRuntimeServices,Commons.Collections.ExtendedProperties)">
            <summary>
            This initialization is used by all resource
            loaders and must be called to set up common
            properties shared by all resource loaders
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Resource.Loader.ResourceLoader.Init(Commons.Collections.ExtendedProperties)">
            <summary>
            Initialize the template loader with a
            a resources class.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Resource.Loader.ResourceLoader.GetResourceStream(System.String)">
            <summary>
            Get the InputStream that the Runtime will parse
            to create a template.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Resource.Loader.ResourceLoader.IsSourceModified(NVelocity.Runtime.Resource.Resource)">
            <summary>
            Given a template, check to see if the source of InputStream
            has been modified.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Resource.Loader.ResourceLoader.GetLastModified(NVelocity.Runtime.Resource.Resource)">
            <summary>
            Get the last modified time of the InputStream source
            that was used to create the template. We need the template
            here because we have to extract the name of the template
            in order to locate the InputStream source.
            </summary>
        </member>
        <member name="P:NVelocity.Runtime.Resource.Loader.ResourceLoader.ClassName">
            <summary>
            Return the class name of this resource Loader
            </summary>
        </member>
        <member name="P:NVelocity.Runtime.Resource.Loader.ResourceLoader.CachingOn">
            <summary>
            Set the caching state. If true, then this loader
            would like the Runtime to cache templates that
            have been created with InputStreams provided
            by this loader.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Resource.Loader.AssemblyResourceLoader.Init(Commons.Collections.ExtendedProperties)">
            <summary> 
            Initialize the template loader with a
            a resources class.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Resource.Loader.AssemblyResourceLoader.GetResourceStream(System.String)">
            
             <summary> Get the InputStream that the Runtime will parse
             to create a template.
             </summary>
        </member>
        <member name="M:NVelocity.Runtime.Resource.Loader.AssemblyResourceLoader.IsSourceModified(NVelocity.Runtime.Resource.Resource)">
            <summary> Given a template, check to see if the source of InputStream
            has been modified.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Resource.Loader.AssemblyResourceLoader.GetLastModified(NVelocity.Runtime.Resource.Resource)">
            <summary> Get the last modified time of the InputStream source
            that was used to create the template. We need the template
            here because we have to extract the name of the template
            in order to locate the InputStream source.
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Resource.Loader.FileResourceLoader">
            <summary>
            A loader for templates stored on the file system.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Resource.Loader.FileResourceLoader.paths">
            <summary>
            The paths to search for templates.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Resource.Loader.FileResourceLoader.templatePaths">
            <summary>
            Used to map the path that a template was found on
            so that we can properly check the modification
            times of the files.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Resource.Loader.FileResourceLoader.GetResourceStream(System.String)">
            <summary>
            Get an InputStream so that the Runtime can build a
            template with it.
            </summary>
            <param name="templateName">name of template to get</param>
            <returns>InputStream containing the template
            @throws ResourceNotFoundException if template not found
            in the file template path.
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.Resource.Loader.FileResourceLoader.FindTemplate(System.String,System.String)">
            <summary>
            Try to find a template given a normalized path.
            </summary>
            <param name="path">a normalized path</param>
            <param name="template">filename of template to get</param>
            <returns>InputStream input stream that will be parsed</returns>
        </member>
        <member name="M:NVelocity.Runtime.Resource.Loader.FileResourceLoader.IsSourceModified(NVelocity.Runtime.Resource.Resource)">
            <summary>
            How to keep track of all the modified times
            across the paths.
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Resource.Loader.ResourceLoaderFactory">
            <summary>
            Factory to grab a template loader.
            </summary>
            <author><a href="mailto:jvanzyl@apache.org">Jason van Zyl</a></author>
        </member>
        <member name="M:NVelocity.Runtime.Resource.Loader.ResourceLoaderFactory.getLoader(NVelocity.Runtime.IRuntimeServices,System.String)">
            <summary>
            Gets the loader specified in the configuration file.
            </summary>
            <returns>TemplateLoader</returns>
        </member>
        <member name="T:NVelocity.Runtime.Resource.ContentResource">
             <summary> 
             This class represent a general text resource that
             may have been retrieved from any number of possible
             sources.
             
             Also of interest is Velocity's {@link org.apache.velocity.Template}
             <code>Resource</code>.
             </summary>
             <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a>
             </author>
             <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
             </author>
             <version> $Id: ContentResource.cs,v 1.5 2004/01/02 00:09:23 corts Exp $
            
             </version>
        </member>
        <member name="T:NVelocity.Runtime.Resource.Resource">
            <summary>
            This class represent a general text resource that
            may have been retrieved from any number of possible
            sources.
            </summary>
            <author><a href="mailto:jvanzyl@apache.org">Jason van Zyl</a></author>
            <author><a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a></author>
            <version> $Id: Resource.cs,v 1.5 2004/01/02 00:13:51 corts Exp $</version>
        </member>
        <member name="F:NVelocity.Runtime.Resource.Resource.MILLIS_PER_SECOND">
            <summary>
            The number of milliseconds in a minute, used to calculate the
            check interval.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Resource.Resource.data">
            <summary>
            Resource might require ancillary storage of some kind
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Resource.Resource.encoding">
            <summary>
            Character encoding of this resource
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Resource.Resource.lastModified">
            <summary>
            The file modification time (in milliseconds) for the cached template.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Resource.Resource.modificationCheckInterval">
            <summary>
            How often the file modification time is checked (in milliseconds).
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Resource.Resource.name">
            <summary>
            Name of the resource
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Resource.Resource.nextCheck">
            <summary>
            The next time the file modification time will be checked (in milliseconds).
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Resource.Resource.resourceLoader">
            <summary>
            The template loader that initially loaded the input
            stream for this template, and knows how to check the
            source of the input stream for modification.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Resource.Resource.Process">
            <summary> 
            Perform any subsequent processing that might need
            to be done by a resource. In the case of a template
            the actual parsing of the input stream needs to be
            performed.
            </summary>
            <returns>
            Whether the resource could be processed successfully.
            For a {@link org.apache.velocity.Template} or {@link
            org.apache.velocity.runtime.resource.ContentResource}, this
            indicates whether the resource could be read.
            @exception ResourceNotFoundException Similar in semantics as
            returning <code>false</code>.
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.Resource.Resource.RequiresChecking">
            <summary> Set the modification check interval.
            </summary>
            <summary> Is it time to check to see if the resource
            source has been updated?
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Resource.Resource.Touch">
            <summary>
            'Touch' this template and thereby resetting the nextCheck field.
            </summary>
        </member>
        <member name="P:NVelocity.Runtime.Resource.Resource.Data">
             <summary>
             Set arbitrary data object that might be used
             by the resource.
            
             Get arbitrary data object that might be used
             by the resource.
             </summary>
        </member>
        <member name="P:NVelocity.Runtime.Resource.Resource.Encoding">
            <summary>
            set the encoding of this resource
            for example, "ISO-8859-1"
            
            get the encoding of this resource
            for example, "ISO-8859-1"
            </summary>
        </member>
        <member name="P:NVelocity.Runtime.Resource.Resource.LastModified">
            <summary>
            Return the lastModifed time of this
            template.
            
            Set the last modified time for this
            template.
            </summary>
        </member>
        <member name="P:NVelocity.Runtime.Resource.Resource.Name">
            <summary>
            Set the name of this resource, for example test.vm.
            
            Get the name of this template.
            </summary>
        </member>
        <member name="P:NVelocity.Runtime.Resource.Resource.ResourceLoader">
            <summary>
            Return the template loader that pulled
            in the template stream
            
            Set the template loader for this template. Set
            when the Runtime determines where this template
            came from the list of possible sources.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Resource.ContentResource.#ctor">
            <summary>Default empty constructor
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Resource.ContentResource.Process">
             <summary>
             Pull in static content and store it.
            
             @exception ResourceNotFoundException Resource could not be
             found.
             </summary>
        </member>
        <member name="T:NVelocity.Runtime.Resource.ResourceCache">
             <summary> Interface that defines the shape of a pluggable resource cache
             for the included ResourceManager
             *
             </summary>
             <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
             </author>
             <version> $Id: ResourceCache.cs,v 1.3 2003/10/27 13:54:11 corts Exp $
            
             </version>
        </member>
        <member name="M:NVelocity.Runtime.Resource.ResourceCache.initialize(NVelocity.Runtime.IRuntimeServices)">
             <summary>  initializes the ResourceCache.  Will be
             called before any utilization
             *
             </summary>
             <param name="rs">RuntimeServices to use for logging, etc
            
             </param>
        </member>
        <member name="M:NVelocity.Runtime.Resource.ResourceCache.get(System.Object)">
             <summary>  retrieves a Resource from the
             cache
             *
             </summary>
             <param name="resourceKey">key for Resource to be retrieved
             </param>
             <returns>Resource specified or null if not found
            
             </returns>
        </member>
        <member name="M:NVelocity.Runtime.Resource.ResourceCache.put(System.Object,NVelocity.Runtime.Resource.Resource)">
             <summary>  stores a Resource in the cache
             *
             </summary>
             <param name="resourceKey">key to associate with the Resource
             </param>
             <param name="resource">Resource to be stored
             </param>
             <returns>existing Resource stored under this key, or null if none
            
             </returns>
        </member>
        <member name="M:NVelocity.Runtime.Resource.ResourceCache.remove(System.Object)">
            <summary>  removes a Resource from the cache
            *
            </summary>
            <param name="resourceKey">resource to be removed
            </param>
        </member>
        <member name="M:NVelocity.Runtime.Resource.ResourceCache.enumerateKeys">
            <summary>  returns an Iterator of Keys in the cache
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Resource.ResourceCacheImpl">
             <summary>
             Default implementation of the resource cache for the default
             ResourceManager.  The cache uses a <i>least recently used</i> (LRU)
             algorithm, with a maximum size specified via the
             <code>resource.manager.cache.size</code> property (idenfied by the
             {@link
             org.apache.velocity.runtime.RuntimeConstants#RESOURCE_MANAGER_CACHE_SIZE}
             constant).  This property get be set to <code>0</code> or less for
             a greedy, unbounded cache (the behavior from pre-v1.5).
             *
             </summary>
             <author> <a href="mailto:geirm@apache.org">Geir Magnusson Jr.</a>
             </author>
             <author> <a href="mailto:dlr@finemaltcoding.com">Daniel Rall</a>
             </author>
             <version> $Id: ResourceCacheImpl.cs,v 1.5 2004/12/23 08:14:32 corts Exp $
            
             </version>
        </member>
        <member name="F:NVelocity.Runtime.Resource.ResourceCacheImpl.cache">
            <summary>
            Cache storage, assumed to be thread-safe.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Resource.ResourceCacheImpl.rsvc">
            <summary>
            Runtime services, generally initialized by the
            <code>initialize()</code> method.
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Resource.ResourceFactory">
            <summary>
            Class responsible for instantiating <code>Resource</code> objects,
            given name and type.
            </summary>
            <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a> </author>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a> </author>
            <version> $Id: ResourceFactory.cs,v 1.3 2003/10/27 13:54:11 corts Exp $ </version>
        </member>
        <member name="T:NVelocity.Runtime.Resource.ResourceType">
            <summary> 
            Class to manage the text resource for the Velocity
            Runtime.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Resource.ResourceType.Template">
            <summary>
            A template resources.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Resource.ResourceType.Content">
            <summary>
            A static content resource.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Resource.IResourceManager.Initialize(NVelocity.Runtime.IRuntimeServices)">
            <summary>
            Initialize the ResourceManager.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Resource.IResourceManager.GetResource(System.String,NVelocity.Runtime.Resource.ResourceType,System.String)">
            <summary> 
            Gets the named resource. Returned class type corresponds to specified type
            (i.e. <c>Template</c> to <c>Template</c>).
            </summary>
            <param name="resourceName">The name of the resource to retrieve.</param>
            <param name="resourceType">The type of resource (<code>Template</code>, <code>Content</code>, etc.).</param>
            <param name="encoding">The character encoding to use.</param>
            <returns>Resource with the template parsed and ready.</returns>
            <exception cref="T:NVelocity.Exception.ResourceNotFoundException">
            if template not found from any available source.
            </exception>
            <exception cref="T:NVelocity.Exception.ParseErrorException">
            if template cannot be parsed due to syntax (or other) error.
            </exception>
            <exception cref="T:System.Exception">
            if a problem in parse
            </exception>
        </member>
        <member name="M:NVelocity.Runtime.Resource.IResourceManager.GetLoaderNameForResource(System.String)">
            <summary> 
            Determines is a template exists, and returns name of the loader that
            provides it.  This is a slightly less hokey way to support
            the Velocity.templateExists() utility method, which was broken
            when per-template encoding was introduced.  We can revisit this.
            </summary>
            <param name="resourceName">Name of template or content resource</param>
            <returns>class name of loader than can provide it</returns>
        </member>
        <member name="T:NVelocity.Runtime.Resource.ResourceManagerImpl">
            <summary> 
            Class to manage the text resource for the Velocity Runtime.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Resource.ResourceManagerImpl.RESOURCE_LOADER_IDENTIFIER">
            <summary>
            token used to identify the loader internally
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Resource.ResourceManagerImpl.globalCache">
            <summary>
            Object implementing ResourceCache to
            be our resource manager's Resource cache.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Resource.ResourceManagerImpl.resourceLoaders">
            <summary> 
            The List of templateLoaders that the Runtime will
            use to locate the InputStream source of a template.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Resource.ResourceManagerImpl.sourceInitializerList">
            <summary>
            This is a list of the template input stream source
            initializers, basically properties for a particular
            template stream source. The order in this list
            reflects numbering of the properties i.e.
            &lt;loader-id&gt;.resource.loader.&lt;property&gt; = &lt;value&gt;
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Resource.ResourceManagerImpl.resourceLoaderInitializersActive">
            <summary>
            Each loader needs a configuration object for
            its initialization, this flags keeps track of whether
            or not the configuration objects have been created
            for the resource loaders.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Resource.ResourceManagerImpl.logWhenFound">
            <summary>
            switch to turn off log notice when a resource is found for
            the first time.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Resource.ResourceManagerImpl.Initialize(NVelocity.Runtime.IRuntimeServices)">
            <summary>
            Initialize the ResourceManager.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Resource.ResourceManagerImpl.AssembleResourceLoaderInitializers">
            <summary>
            This will produce a List of Hashtables, each
            hashtable contains the intialization info for
            a particular resource loader. This Hastable
            will be passed in when initializing the
            the template loader.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Resource.ResourceManagerImpl.GetResource(System.String,NVelocity.Runtime.Resource.ResourceType,System.String)">
             <summary> Gets the named resource.  Returned class type corresponds to specified type
             (i.e. <code>Template</code> to <code>Template</code>).
             *
             </summary>
             <param name="resourceName">The name of the resource to retrieve.
             </param>
             <param name="resourceType">The type of resource (<code>Template</code>,
             <code>Content</code>, etc.).
             </param>
             <param name="encoding"> The character encoding to use.
             </param>
             <returns>Resource with the template parsed and ready.
             @throws ResourceNotFoundException if template not found
             from any available source.
             @throws ParseErrorException if template cannot be parsed due
             to syntax (or other) error.
             @throws Exception if a problem in parse
            
             </returns>
        </member>
        <member name="M:NVelocity.Runtime.Resource.ResourceManagerImpl.LoadResource(System.String,NVelocity.Runtime.Resource.ResourceType,System.String)">
            <summary>
            Loads a resource from the current set of resource loaders
            </summary>
            <param name="resourceName">The name of the resource to retrieve.</param>
            <param name="resourceType">The type of resource (<code>Template</code>,
            <code>Content</code>, etc.).
            </param>
            <param name="encoding"> The character encoding to use.</param>
            <returns>Resource with the template parsed and ready.
            @throws ResourceNotFoundException if template not found
            from any available source.
            @throws ParseErrorException if template cannot be parsed due
            to syntax (or other) error.
            @throws Exception if a problem in parse
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.Resource.ResourceManagerImpl.RefreshResource(NVelocity.Runtime.Resource.Resource,System.String)">
             <summary>  Takes an existing resource, and 'refreshes' it.  This
             generally means that the source of the resource is checked
             for changes according to some cache/check algorithm
             and if the resource changed, then the resource data is
             reloaded and re-parsed.
             *
             </summary>
             <param name="resource">resource to refresh
             *
             @throws ResourceNotFoundException if template not found
             from current source for this Resource
             @throws ParseErrorException if template cannot be parsed due
             to syntax (or other) error.
             @throws Exception if a problem in parse
            
             </param>
             <param name="encoding"></param>
        </member>
        <member name="M:NVelocity.Runtime.Resource.ResourceManagerImpl.GetResource(System.String,NVelocity.Runtime.Resource.ResourceType)">
             <summary> Gets the named resource.  Returned class type corresponds to specified type
             (i.e. <code>Template</code> to <code>Template</code>).
             *
             </summary>
             <param name="resourceName">The name of the resource to retrieve.
             </param>
             <param name="resourceType">The type of resource (<code>Template</code>,
             <code>Content</code>, etc.).
             </param>
             <returns>Resource with the template parsed and ready.
             @throws ResourceNotFoundException if template not found
             from any available source.
             @throws ParseErrorException if template cannot be parsed due
             to syntax (or other) error.
             @throws Exception if a problem in parse
             *
             </returns>
             <deprecated>Use
             {@link #GetResource(String resourceName, int resourceType,
             String encoding )}
            
             </deprecated>
        </member>
        <member name="M:NVelocity.Runtime.Resource.ResourceManagerImpl.GetLoaderNameForResource(System.String)">
             <summary>  Determines is a template exists, and returns name of the loader that
             provides it.  This is a slightly less hokey way to support
             the Velocity.templateExists() utility method, which was broken
             when per-template encoding was introduced.  We can revisit this.
             </summary>
             <param name="resourceName">Name of template or content resource
             </param>
             <returns>class name of loader than can provide it
            
             </returns>
        </member>
        <member name="T:NVelocity.Runtime.Visitor.BaseVisitor">
             <summary> This is the base class for all visitors.
             For each AST node, this class will provide
             a bare-bones method for traversal.
             *
             </summary>
             <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a>
             </author>
             <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
             </author>
             <version> $Id: BaseVisitor.cs,v 1.3 2003/10/27 13:54:11 corts Exp $
            
             </version>
        </member>
        <member name="F:NVelocity.Runtime.Visitor.BaseVisitor.context">
            <summary>
            Context used during traversal
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Visitor.BaseVisitor.writer">
            <summary>
            Writer used as the output sink
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Visitor.NodeViewMode">
             <summary> This class is simply a visitor implementation
             that traverses the AST, produced by the Velocity
             parsing process, and creates a visual structure
             of the AST. This is primarily used for
             debugging, but it useful for documentation
             as well.
             *
             </summary>
             <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a>
             </author>
             <version> $Id: NodeViewMode.cs,v 1.3 2003/10/27 13:54:11 corts Exp $
            
             </version>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.IndentString">
            <summary>Indent child nodes to help visually identify
            the structure of the AST.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.ShowNode(NVelocity.Runtime.Parser.Node.INode,System.Object)">
            <summary> Display the type of nodes and optionally the
            first token.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.Visit(NVelocity.Runtime.Parser.Node.SimpleNode,System.Object)">
            <summary>Display a SimpleNode
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.Visit(NVelocity.Runtime.Parser.Node.ASTprocess,System.Object)">
            <summary>Display an ASTprocess node
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.Visit(NVelocity.Runtime.Parser.Node.ASTExpression,System.Object)">
            <summary>Display an ASTExpression node
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.Visit(NVelocity.Runtime.Parser.Node.ASTAssignment,System.Object)">
            <summary>Display an ASTAssignment node ( = )
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.Visit(NVelocity.Runtime.Parser.Node.ASTOrNode,System.Object)">
            <summary>Display an ASTOrNode ( || )
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.Visit(NVelocity.Runtime.Parser.Node.ASTAndNode,System.Object)">
            <summary>Display an ASTAndNode ( &amp;&amp; )
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.Visit(NVelocity.Runtime.Parser.Node.ASTEQNode,System.Object)">
            <summary>Display an ASTEQNode ( == )
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.Visit(NVelocity.Runtime.Parser.Node.ASTNENode,System.Object)">
            <summary>Display an ASTNENode ( != )
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.Visit(NVelocity.Runtime.Parser.Node.ASTLTNode,System.Object)">
            <summary>Display an ASTLTNode ( &lt; )
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.Visit(NVelocity.Runtime.Parser.Node.ASTGTNode,System.Object)">
            <summary>Display an ASTGTNode ( &gt; )
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.Visit(NVelocity.Runtime.Parser.Node.ASTLENode,System.Object)">
            <summary>Display an ASTLENode ( &lt;= )
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.Visit(NVelocity.Runtime.Parser.Node.ASTGENode,System.Object)">
            <summary>Display an ASTGENode ( &gt;= )
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.Visit(NVelocity.Runtime.Parser.Node.ASTAddNode,System.Object)">
            <summary>Display an ASTAddNode ( + )
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.Visit(NVelocity.Runtime.Parser.Node.ASTSubtractNode,System.Object)">
            <summary>Display an ASTSubtractNode ( - )
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.Visit(NVelocity.Runtime.Parser.Node.ASTMulNode,System.Object)">
            <summary>Display an ASTMulNode ( * )
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.Visit(NVelocity.Runtime.Parser.Node.ASTDivNode,System.Object)">
            <summary>Display an ASTDivNode ( / )
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.Visit(NVelocity.Runtime.Parser.Node.ASTModNode,System.Object)">
            <summary>Display an ASTModNode ( % )
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.Visit(NVelocity.Runtime.Parser.Node.ASTNotNode,System.Object)">
            <summary>Display an ASTNotNode ( ! )
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.Visit(NVelocity.Runtime.Parser.Node.ASTNumberLiteral,System.Object)">
            <summary>Display an ASTNumberLiteral node
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.Visit(NVelocity.Runtime.Parser.Node.ASTStringLiteral,System.Object)">
            <summary>Display an ASTStringLiteral node
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.Visit(NVelocity.Runtime.Parser.Node.ASTIdentifier,System.Object)">
            <summary>Display an ASTIdentifier node
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.Visit(NVelocity.Runtime.Parser.Node.ASTMethod,System.Object)">
            <summary>Display an ASTMethod node
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.Visit(NVelocity.Runtime.Parser.Node.ASTReference,System.Object)">
            <summary>Display an ASTReference node
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.Visit(NVelocity.Runtime.Parser.Node.ASTTrue,System.Object)">
            <summary>Display an ASTTrue node
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.Visit(NVelocity.Runtime.Parser.Node.ASTFalse,System.Object)">
            <summary>Display an ASTFalse node
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.Visit(NVelocity.Runtime.Parser.Node.ASTBlock,System.Object)">
            <summary>Display an ASTBlock node
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.Visit(NVelocity.Runtime.Parser.Node.ASTText,System.Object)">
            <summary>Display an ASTText node
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.Visit(NVelocity.Runtime.Parser.Node.ASTIfStatement,System.Object)">
            <summary>Display an ASTIfStatement node
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.Visit(NVelocity.Runtime.Parser.Node.ASTElseStatement,System.Object)">
            <summary>Display an ASTElseStatement node
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.Visit(NVelocity.Runtime.Parser.Node.ASTElseIfStatement,System.Object)">
            <summary>Display an ASTElseIfStatement node
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Visitor.VMReferenceMungeVisitor">
            <summary>
            This class is a visitor used by the VM proxy to change the
            literal representation of a reference in a VM.  The reason is
            to preserve the 'render literal if null' behavior w/o making
            the VMProxy stuff more complicated than it is already.
            </summary>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a></author>
            <version> $Id: VMReferenceMungeVisitor.cs,v 1.3 2003/10/27 13:54:11 corts Exp $</version>
        </member>
        <member name="F:NVelocity.Runtime.Visitor.VMReferenceMungeVisitor.argmap">
            <summary>
            Map containing VM arg to instance-use reference
            Passed in with CTOR
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.VMReferenceMungeVisitor.#ctor(System.Collections.Hashtable)">
            <summary>
            CTOR - takes a map of args to reference
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.VMReferenceMungeVisitor.Visit(NVelocity.Runtime.Parser.Node.ASTReference,System.Object)">
            <summary>
            Visitor method - if the literal is right, will
            set the literal in the ASTReference node
            </summary>
            <param name="node">ASTReference to work on</param>
            <param name="data">Object to pass down from caller</param>
        </member>
        <member name="T:NVelocity.Runtime.IRuntimeLogger">
            <summary>
            Interface for internal runtime logging services that are needed by the
            </summary>
            <author><a href="mailto:geirm@apache.org">Geir Magusson Jr.</a></author>
            <version>$Id: RuntimeLogger.cs,v 1.1 2004/01/02 00:04:50 corts Exp $</version>
        </member>
        <member name="M:NVelocity.Runtime.IRuntimeLogger.Warn(System.Object)">
            <summary>
            Log a warning message.
            </summary>
            <param name="message">message to log</param>
        </member>
        <member name="M:NVelocity.Runtime.IRuntimeLogger.Info(System.Object)">
            <summary>
            Log an info message.
            </summary>
            <param name="message">message to log</param>
        </member>
        <member name="M:NVelocity.Runtime.IRuntimeLogger.Error(System.Object)">
            <summary>
            Log an error message.
            </summary>
            <param name="message">message to log</param>
        </member>
        <member name="M:NVelocity.Runtime.IRuntimeLogger.Debug(System.Object)">
            <summary>
            Log a debug message.
            </summary>
            <param name="message">message to log</param>
        </member>
        <member name="T:NVelocity.Runtime.IRuntimeServices">
             <summary> Interface for internal runtime services that are needed by the
             various components w/in Velocity.  This was taken from the old
             Runtime singleton, and anything not necessary was removed.
            
             Currently implemented by RuntimeInstance.
             </summary>
        </member>
        <member name="M:NVelocity.Runtime.IRuntimeServices.SetProperty(System.String,System.Object)">
            <summary>
            Allows an external system to set a property in
            the Velocity Runtime.
            </summary>
            <param name="key">property key</param>
            <param name="value">property value</param>
        </member>
        <member name="M:NVelocity.Runtime.IRuntimeServices.AddProperty(System.String,System.Object)">
            <summary> Add a property to the configuration. If it already
            exists then the value stated here will be added
            to the configuration entry. For example, if
            *
            resource.loader = file
            *
            is already present in the configuration and you
            *
            addProperty("resource.loader", "classpath")
            *
            Then you will end up with a Vector like the
            following:
            *
            ["file", "classpath"]
            *
            </summary>
            <param name="key">key</param>
            <param name="value">value</param>
        </member>
        <member name="M:NVelocity.Runtime.IRuntimeServices.ClearProperty(System.String)">
            <summary>
            Clear the values pertaining to a particular property.
            </summary>
            <param name="key">key of property to clear</param>
        </member>
        <member name="M:NVelocity.Runtime.IRuntimeServices.GetProperty(System.String)">
             <summary>  Allows an external caller to get a property.  The calling
             routine is required to know the type, as this routine
             will return an Object, as that is what properties can be.
             *
             </summary>
             <param name="key">property to return
            
             </param>
        </member>
        <member name="M:NVelocity.Runtime.IRuntimeServices.Init(System.String)">
            <summary>
            Initialize the Velocity Runtime with the name of
            ExtendedProperties object.
            </summary>
            <param name="configurationFile">Properties</param>
        </member>
        <member name="M:NVelocity.Runtime.IRuntimeServices.Parse(System.IO.TextReader,System.String)">
            <summary>
            Parse the input and return the root of
            AST node structure.
            </summary>
            <remarks>
            In the event that it runs out of parsers in the
            pool, it will create and let them be GC'd
            dynamically, logging that it has to do that.  This
            is considered an exceptional condition.  It is
            expected that the user will set the
            PARSER_POOL_SIZE property appropriately for their
            application.  We will revisit this.
            </remarks>
            <param name="reader">inputstream retrieved by a resource loader</param>
            <param name="templateName">name of the template being parsed</param>
        </member>
        <member name="M:NVelocity.Runtime.IRuntimeServices.Parse(System.IO.TextReader,System.String,System.Boolean)">
            <summary>
            Parse the input and return the root of the AST node structure.
            </summary>
            <param name="reader">inputstream retrieved by a resource loader</param>
            <param name="templateName">name of the template being parsed</param>
            <param name="dumpNamespace">flag to dump the Velocimacro namespace for this template</param>
        </member>
        <member name="M:NVelocity.Runtime.IRuntimeServices.GetTemplate(System.String)">
             <summary> Returns a <code>Template</code> from the resource manager.
             This method assumes that the character encoding of the
             template is set by the <code>input.encoding</code>
             property.  The default is "ISO-8859-1"
             *
             </summary>
             <param name="name">The file name of the desired template.
             </param>
             <returns>    The template.
             @throws ResourceNotFoundException if template not found
             from any available source.
             @throws ParseErrorException if template cannot be parsed due
             to syntax (or other) error.
             @throws Exception if an error occurs in template initialization
            
             </returns>
        </member>
        <member name="M:NVelocity.Runtime.IRuntimeServices.GetTemplate(System.String,System.String)">
             <summary> Returns a <code>Template</code> from the resource manager
             *
             </summary>
             <param name="name">The  name of the desired template.
             </param>
             <param name="encoding">Character encoding of the template
             </param>
             <returns>    The template.
             @throws ResourceNotFoundException if template not found
             from any available source.
             @throws ParseErrorException if template cannot be parsed due
             to syntax (or other) error.
             @throws Exception if an error occurs in template initialization
            
             </returns>
        </member>
        <member name="M:NVelocity.Runtime.IRuntimeServices.GetContent(System.String)">
             <summary> Returns a static content resource from the
             resource manager.  Uses the current value
             if INPUT_ENCODING as the character encoding.
             *
             </summary>
             <param name="name">Name of content resource to get
             </param>
             <returns>parsed ContentResource object ready for use
             @throws ResourceNotFoundException if template not found
             from any available source.
            
             </returns>
        </member>
        <member name="M:NVelocity.Runtime.IRuntimeServices.GetContent(System.String,System.String)">
             <summary> Returns a static content resource from the
             resource manager.
             *
             </summary>
             <param name="name">Name of content resource to get
             </param>
             <param name="encoding">Character encoding to use
             </param>
             <returns>parsed ContentResource object ready for use
             @throws ResourceNotFoundException if template not found
             from any available source.
            
             </returns>
        </member>
        <member name="M:NVelocity.Runtime.IRuntimeServices.GetLoaderNameForResource(System.String)">
             <summary>  Determines is a template exists, and returns name of the loader that
             provides it.  This is a slightly less hokey way to support
             the Velocity.templateExists() utility method, which was broken
             when per-template encoding was introduced.  We can revisit this.
             *
             </summary>
             <param name="resourceName">Name of template or content resource
             </param>
             <returns>class name of loader than can provide it
            
             </returns>
        </member>
        <member name="M:NVelocity.Runtime.IRuntimeServices.GetString(System.String,System.String)">
            <summary>
            String property accessor method with default to hide the
            configuration implementation.
            </summary>
            <param name="key">key property key</param>
            <param name="defaultValue">default value to return if key not
            found in resource manager.
            </param>
            <returns>value of key or default</returns>
        </member>
        <member name="M:NVelocity.Runtime.IRuntimeServices.GetVelocimacro(System.String,System.String)">
            <summary>
            Returns the appropriate VelocimacroProxy object if vmName
            is a valid current Velocimacro.
            </summary>
            <param name="vmName">Name of velocimacro requested</param>
            <param name="templateName">Template Name</param>
            <returns>VelocimacroProxy</returns>
        </member>
        <member name="M:NVelocity.Runtime.IRuntimeServices.AddVelocimacro(System.String,System.String,System.String[],System.String)">
            <summary>
            Adds a new Velocimacro. Usually called by Macro only while parsing.
            </summary>
            <param name="name">name  Name of velocimacro</param>
            <param name="macro">macro  String form of macro body</param>
            <param name="argArray">argArray  Array of strings, containing the
            <c>#macro()</c> arguments.  the 0th is the name.</param>
            <param name="sourceTemplate">Source Template</param>
            <returns>
            True if added, false if rejected for some
            reason (either parameters or permission settings)
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.IRuntimeServices.IsVelocimacro(System.String,System.String)">
            <summary>
            Checks to see if a VM exists
            </summary>
            <param name="vmName">Name of velocimacro</param>
            <param name="templateName">Template Name</param>
            <returns>True if VM by that name exists, false if not</returns>
        </member>
        <member name="M:NVelocity.Runtime.IRuntimeServices.DumpVMNamespace(System.String)">
            <summary>  tells the vmFactory to dump the specified namespace.  This is to support
            clearing the VM list when in inline-VM-local-scope mode
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.IRuntimeServices.GetString(System.String)">
            <summary>
            String property accessor method to hide the configuration implementation.
            </summary>
            <param name="key">property key</param>
            <returns>value</returns>
        </member>
        <member name="M:NVelocity.Runtime.IRuntimeServices.GetInt(System.String)">
            <summary>
            Int property accessor method to hide the configuration implementation.
            </summary>
            <param name="key">property key</param>
            <returns>value</returns>
        </member>
        <member name="M:NVelocity.Runtime.IRuntimeServices.GetInt(System.String,System.Int32)">
            <summary>
            Int property accessor method to hide the configuration implementation.
            </summary>
            <param name="key">property key</param>
            <param name="defaultValue">default value</param>
            <returns>value</returns>
        </member>
        <member name="M:NVelocity.Runtime.IRuntimeServices.GetBoolean(System.String,System.Boolean)">
            <summary>
            Boolean property accessor method to hide the configuration implementation.
            </summary>
            <param name="key">property key</param>
            <param name="def">default value</param>
            <returns>value</returns>
        </member>
        <member name="M:NVelocity.Runtime.IRuntimeServices.GetApplicationAttribute(System.Object)">
            <summary>
            Return the specified application attribute
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NVelocity.Runtime.IRuntimeServices.SetApplicationAttribute(System.Object,System.Object)">
            <summary>
            Sets the specified application attribute.
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="P:NVelocity.Runtime.IRuntimeServices.Configuration">
             Return the velocity runtime configuration object.
            
             @return ExtendedProperties configuration object which houses
                                   the velocity runtime properties.
        </member>
        <member name="P:NVelocity.Runtime.IRuntimeServices.Uberspect">
            Returns the configured class introspection/reflection
            implemenation.
        </member>
        <member name="P:NVelocity.Runtime.IRuntimeServices.Introspector">
            Returns the configured method introspection/reflection
            implemenation.
        </member>
        <member name="T:NVelocity.Runtime.RuntimeConstants">
            <summary>
            This class defines the keys that are used in the
            velocity.properties file so that they can be referenced as a constant
            within Java code.
            </summary>
            <author> <a href="mailto:jon@latchkey.com">Jon S. Stevens</a></author>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a></author>
            <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a></author>
        </member>
        <member name="F:NVelocity.Runtime.RuntimeConstants.RESOURCE_MANAGER_CACHE_CLASS">
            <summary>
            The <code>resource.manager.cache.class</code> property 
            specifies the name of the <see cref="T:NVelocity.Runtime.Resource.ResourceCache"/> implementation to use.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.RuntimeConstants.RESOURCE_MANAGER_DEFAULTCACHE_SIZE">
            <summary>
            The <code>resource.manager.cache.size</code> property 
            specifies the cache upper bound (if relevant).
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.RuntimeConstants.NUMBER_OF_PARSERS">
            <summary>
            The default number of parser instances to create.
            Configurable via the parameter named by the <see cref="F:NVelocity.Runtime.RuntimeConstants.PARSER_POOL_SIZE"/> constant.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.RuntimeConstants.PARSER_POOL_SIZE">
            <summary>
            <see cref="F:NVelocity.Runtime.RuntimeConstants.NUMBER_OF_PARSERS"/>
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.RuntimeConstants.UBERSPECT_CLASSNAME">
            <summary>
            key name for uberspector
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.RuntimeInstance">
             <summary> 
             This is the Runtime system for Velocity. It is the
             single access point for all functionality in Velocity.
             It adheres to the mediator pattern and is the only
             structure that developers need to be familiar with
             in order to get Velocity to perform.
             
             The Runtime will also cooperate with external
             systems like Turbine. Runtime properties can
             set and then the Runtime is initialized.
             
             Turbine for example knows where the templates
             are to be loaded from, and where the velocity
             log file should be placed.
             
             So in the case of Velocity cooperating with Turbine
             the code might look something like the following:
             
             <code>
             Runtime.setProperty(Runtime.FILE_RESOURCE_LOADER_PATH, templatePath);
             Runtime.setProperty(Runtime.RUNTIME_LOG, pathToVelocityLog);
             Runtime.init();
             </code>
             
             <pre>
             -----------------------------------------------------------------------
             N O T E S  O N  R U N T I M E  I N I T I A L I Z A T I O N
             -----------------------------------------------------------------------
             Runtime.init()
            
             If Runtime.init() is called by itself the Runtime will
             initialize with a set of default values.
             -----------------------------------------------------------------------
             Runtime.init(String/Properties)
             
             In this case the default velocity properties are layed down
             first to provide a solid base, then any properties provided
             in the given properties object will override the corresponding
             default property.
             -----------------------------------------------------------------------
             </pre>
             
             </summary>
        </member>
        <member name="F:NVelocity.Runtime.RuntimeInstance.vmFactory">
            <summary>
            VelocimacroFactory object to manage VMs
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.RuntimeInstance.parserPool">
            <summary>
            The Runtime parser pool
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.RuntimeInstance.initialized">
            <summary>
            Indicate whether the Runtime has been fully initialized.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.RuntimeInstance.overridingProperties">
            <summary>
            These are the properties that are laid down over top
            of the default properties when requested.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.RuntimeInstance.configuration">
            <summary>
            Object that houses the configuration options for
            the velocity runtime. The ExtendedProperties object allows
            the convenient retrieval of a subset of properties.
            For example all the properties for a resource loader
            can be retrieved from the main ExtendedProperties object
            using something like the following:
            
            <code>
            ExtendedProperties loaderConfiguration =
            configuration.subset(loaderID);
            </code>
            
            And a configuration is a lot more convenient to deal
            with then conventional properties objects, or Maps.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.RuntimeInstance.introspector">
            <summary>
            Each runtime instance has it's own introspector
            to ensure that each instance is completely separate.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.RuntimeInstance.applicationAttributes">
            <summary>
            Opaque reference to something specificed by the 
            application for use in application supplied/specified
            pluggable components.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.initializeIntrospection">
            <summary>
            Gets the classname for the Uberspect introspection package and
            instantiates an instance.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.setDefaultProperties">
            <summary>
            Initializes the Velocity Runtime with properties file.
            The properties file may be in the file system proper,
            or the properties file may be in the classpath.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.SetProperty(System.String,System.Object)">
            <summary>
            Allows an external system to set a property in
            the Velocity Runtime.
            </summary>
            <param name="key">property key </param>
            <param name="value">property value</param>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.AddProperty(System.String,System.Object)">
            <summary>
            Add a property to the configuration. If it already
            exists then the value stated here will be added
            to the configuration entry.
            <remarks>
            For example, if
            <c>resource.loader = file</c>
            is already present in the configuration and you
            <c>addProperty("resource.loader", "classpath")</c>
            
            Then you will end up with a <see cref="T:System.Collections.IList"/> like the
            following:
            
            <c>["file", "classpath"]</c>
            </remarks>
            </summary>
            <param name="key">key</param>
            <param name="value">value</param>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.ClearProperty(System.String)">
            <summary>
            Clear the values pertaining to a particular
            property.
            </summary>
            <param name="key">key of property to clear</param>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.GetProperty(System.String)">
            <summary>
            Allows an external caller to get a property.
            <remarks>
            The calling routine is required to know the type, as this routine
            will return an Object, as that is what properties can be.
            </remarks>
            </summary>
            <param name="key">property to return</param>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.initializeProperties">
            <summary>
            Initialize Velocity properties, if the default
            properties have not been laid down first then
            do so. Then proceed to process any overriding
            properties. Laying down the default properties
            gives a much greater chance of having a
            working system.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.Init(Commons.Collections.ExtendedProperties)">
            <summary>
            Initialize the Velocity Runtime with a Properties
            object.
            </summary>
            <param name="p">Properties</param>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.Init(System.String)">
            <summary>
            Initialize the Velocity Runtime with the name of
            ExtendedProperties object.
            </summary>
            <param name="configurationFile">Properties</param>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.initializeLogger">
            <summary> Initialize the Velocity logging system.
            *
            @throws Exception
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.initializeDirectives">
             <summary> This methods initializes all the directives
             that are used by the Velocity Runtime. The
             directives to be initialized are listed in
             the RUNTIME_DEFAULT_DIRECTIVES properties
             file.
            
             @throws Exception
             </summary>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.initializeParserPool">
            <summary> Initializes the Velocity parser pool.
            This still needs to be implemented.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.CreateNewParser">
            <summary> Returns a JavaCC generated Parser.
            </summary>
            <returns>Parser javacc generated parser
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.Parse(System.IO.TextReader,System.String)">
            <summary>
            Parse the input and return the root of
            AST node structure.
            <remarks>
            In the event that it runs out of parsers in the
            pool, it will create and let them be GC'd
            dynamically, logging that it has to do that.  This
            is considered an exceptional condition.  It is
            expected that the user will set the
            <c>PARSER_POOL_SIZE</c> property appropriately for their
            application.  We will revisit this.
            </remarks>
            </summary>
            <param name="reader">inputstream retrieved by a resource loader</param>
            <param name="templateName">name of the template being parsed</param>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.Parse(System.IO.TextReader,System.String,System.Boolean)">
            <summary>
            Parse the input and return the root of the AST node structure.
            </summary>
            <param name="reader">inputstream retrieved by a resource loader</param>
            <param name="templateName">name of the template being parsed</param>
            <param name="dumpNamespace">flag to dump the Velocimacro namespace for this template</param>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.GetTemplate(System.String)">
            <summary>
            Returns a <code>Template</code> from the resource manager.
            This method assumes that the character encoding of the
            template is set by the <code>input.encoding</code>
            property.  The default is "ISO-8859-1"
            </summary>
            <param name="name">The file name of the desired template.
            </param>
            <returns>The template.</returns>
            <exception cref="T:NVelocity.Exception.ResourceNotFoundException">
            if template not found from any available source
            </exception>
            <exception cref="T:NVelocity.Exception.ParseErrorException">
            if template cannot be parsed due to syntax (or other) error.
            </exception>
            <exception cref="N:NVelocity.Runtime.Exception">
            if an error occurs in template initialization
            </exception>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.GetTemplate(System.String,System.String)">
            <summary>
            Returns a <code>Template</code> from the resource manager
            </summary>
            <param name="name">The name of the desired template.</param>
            <param name="encoding">Character encoding of the template</param>
            <returns>The template.</returns>
            <exception cref="T:NVelocity.Exception.ResourceNotFoundException">
            if template not found from any available source.
            </exception>
            <exception cref="T:NVelocity.Exception.ParseErrorException">
            if template cannot be parsed due to syntax (or other) error.
            </exception>
            <exception cref="N:NVelocity.Runtime.Exception">
            if an error occurs in template initialization
            </exception>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.GetContent(System.String)">
            <summary>
            Returns a static content resource from the
            resource manager.  Uses the current value
            if <c>INPUT_ENCODING</c> as the character encoding.
            </summary>
            <param name="name">Name of content resource to get</param>
            <returns>ContentResource object ready for use</returns>
            <exception cref="T:NVelocity.Exception.ResourceNotFoundException">
            if template not found from any available source.
            </exception>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.GetContent(System.String,System.String)">
            <summary>
            Returns a static content resource from the
            resource manager.
            </summary>
            <param name="name">Name of content resource to get</param>
            <param name="encoding">Character encoding to use</param>
            <returns>ContentResource object ready for use</returns>
            <exception cref="T:NVelocity.Exception.ResourceNotFoundException">
            if template not found from any available source.
            </exception>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.GetLoaderNameForResource(System.String)">
            <summary>
            Determines is a template exists, and returns name of the loader that
            provides it.  This is a slightly less hokey way to support
            the <c>Velocity.templateExists()</c> utility method, which was broken
            when per-template encoding was introduced.  We can revisit this.
            </summary>
            <param name="resourceName">Name of template or content resource</param>
            <returns>class name of loader than can provide it</returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.showStackTrace">
            <summary>
            Added this to check and make sure that the configuration
            is initialized before trying to get properties from it.
            This occurs when there are errors during initialization
            and the default properties have yet to be layed down.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.Log(NVelocity.Runtime.Log.LogLevel,System.Object)">
            <summary>
            Handle logging.
            </summary>
            <param name="level">log level</param>
            <param name="message">message to log</param>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.Warn(System.Object)">
            <summary>
            Log a warning message.
            </summary>
            <param name="message">message to log</param>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.Info(System.Object)">
            <summary>
            Log an info message.
            </summary>
            <param name="message">message to log</param>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.Error(System.Object)">
            <summary>
            Log an error message.
            </summary>
            <param name="message">message to log</param>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.Debug(System.Object)">
            <summary>
            Log a debug message.
            </summary>
            <param name="message">message to log</param>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.GetString(System.String,System.String)">
            <summary>
            String property accessor method with default to hide the
            configuration implementation.
            </summary>
            <param name="key">key property key</param>
            <param name="defaultValue">default value to return if key not found in resource manager.</param>
            <returns>String  value of key or default</returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.GetVelocimacro(System.String,System.String)">
            <summary>
            Returns the appropriate VelocimacroProxy object if strVMname
            is a valid current Velocimacro.
            </summary>
            <param name="vmName">Name of velocimacro requested</param>
            <param name="templateName">Name of template</param>
            <returns>VelocimacroProxy</returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.AddVelocimacro(System.String,System.String,System.String[],System.String)">
            <summary>
            Adds a new Velocimacro. Usually called by Macro only while parsing.
            </summary>
            <param name="name">Name of velocimacro</param>
            <param name="macro">String form of macro body</param>
            <param name="argArray">Array of strings, containing the #macro() arguments.  the 0th is the name.</param>
            <param name="sourceTemplate">Name of template</param>
            <returns>
            True if added, false if rejected for some
            reason (either parameters or permission settings)
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.IsVelocimacro(System.String,System.String)">
            <summary>
            Checks to see if a VM exists
            </summary>
            <param name="vmName">Name of velocimacro</param>
            <param name="templateName">Name of template</param>
            <returns>
            True if VM by that name exists, false if not
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.DumpVMNamespace(System.String)">
            <summary>
            Tells the vmFactory to dump the specified namespace.
            This is to support clearing the VM list when in 
            <c>inline-VM-local-scope</c> mode.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.GetString(System.String)">
            <summary>
            String property accessor method to hide the configuration implementation
            </summary>
            <param name="key">property key</param>
            <returns>value of key or null</returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.GetInt(System.String)">
            <summary>
            Int property accessor method to hide the configuration implementation.
            </summary>
            <param name="key">property key</param>
            <returns>value</returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.GetInt(System.String,System.Int32)">
            <summary>
            Int property accessor method to hide the configuration implementation.
            </summary>
            <param name="key">property key</param>
            <param name="defaultValue">default value</param>
            <returns>value</returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.GetBoolean(System.String,System.Boolean)">
            <summary>
            Boolean property accessor method to hide the configuration implementation.
            </summary>
            <param name="key">property key</param>
            <param name="def">default value if property not found</param>
            <returns>boolean  value of key or default value</returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.GetApplicationAttribute(System.Object)">
            <summary>
            Return the velocity runtime configuration object.
            </summary>
            <returns>
            ExtendedProperties configuration object which houses
            the velocity runtime properties.
            </returns>
        </member>
        <member name="P:NVelocity.Runtime.RuntimeInstance.Uberspect">
            <summary>
            Return the Introspector for this instance
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.RuntimeSingleton">
             <summary>
             This is the Runtime system for Velocity. It is the
             single access point for all functionality in Velocity.
             It adheres to the mediator pattern and is the only
             structure that developers need to be familiar with
             in order to get Velocity to perform.
             
             The Runtime will also cooperate with external
             systems like Turbine. Runtime properties can
             set and then the Runtime is initialized.
             
             Turbine for example knows where the templates
             are to be loaded from, and where the velocity
             log file should be placed.
             
             So in the case of Velocity cooperating with Turbine
             the code might look something like the following:
             
             <pre>
             RuntimeSingleton.setProperty(RuntimeConstants.FILE_RESOURCE_LOADER_PATH, templatePath);
             RuntimeSingleton.setProperty(RuntimeConstants.RUNTIME_LOG, pathToVelocityLog);
             RuntimeSingleton.init();
             </pre>
             <pre>
             -----------------------------------------------------------------------
             N O T E S  O N  R U N T I M E  I N I T I A L I Z A T I O N
             -----------------------------------------------------------------------
             RuntimeSingleton.init()
            
             If Runtime.init() is called by itself the Runtime will
             initialize with a set of default values.
             -----------------------------------------------------------------------
             RuntimeSingleton.init(String/Properties)
             
             In this case the default velocity properties are layed down
             first to provide a solid base, then any properties provided
             in the given properties object will override the corresponding
             default property.
             -----------------------------------------------------------------------
             </pre>
             </summary>
             <author><a href="mailto:jvanzyl@apache.org">Jason van Zyl</a></author>
             <author><a href="mailto:jlb@houseofdistraction.com">Jeff Bowden</a></author>
             <author><a href="mailto:geirm@optonline.net">Geir Magusson Jr.</a></author>
             <author><a href="mailto:dlr@finemaltcoding.com">Daniel Rall</a></author>
             <version> $Id: RuntimeSingleton.cs,v 1.5 2004/12/27 05:59:46 corts Exp $
            
             </version>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeSingleton.Init">
            <summary>
            This is the primary initialization method in the Velocity
            Runtime. The systems that are setup/initialized here are
            as follows:
            <list type="">
            	<item>Logging System</item>
            	<item>ResourceManager</item>
            	<item>Parser Pool</item>
            	<item>Global Cache</item>
            	<item>Static Content Include System</item>
            	<item>Velocimacro System</item>
            </list>
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeSingleton.SetProperty(System.String,System.Object)">
            <summary>
            Allows an external system to set a property in
            the Velocity Runtime.
            </summary>
            <param name="key">property key</param>
            <param name="value">property value</param>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeSingleton.AddProperty(System.String,System.Object)">
            <summary> Add a property to the configuration. If it already
            exists then the value stated here will be added
            to the configuration entry. For example, if
            
            <code>resource.loader = file</code>
            
            is already present in the configuration and you
            
            <code>addProperty("resource.loader", "classpath")</code>
            
            Then you will end up with an ArrayList like the
            following:
            
            ["file", "classpath"]
            </summary>
            <param name="key">key</param>
            <param name="value">value</param>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeSingleton.ClearProperty(System.String)">
            <summary>
            Clear the values pertaining to a particular property.
            </summary>
            <param name="key">key of property to clear</param>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeSingleton.GetProperty(System.String)">
            <summary>
            Allows an external caller to get a property.  The calling
            routine is required to know the type, as this routine
            will return an Object, as that is what properties can be.
            </summary>
            <param name="key">property to return</param>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeSingleton.Init(Commons.Collections.ExtendedProperties)">
            <summary>
            Initialize the Velocity Runtime with an ExtendedProperties object.
            </summary>
            <param name="p">Properties</param>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeSingleton.Init(System.String)">
            <summary> Initialize the Velocity Runtime with a configuration file.</summary>
            <param name="configurationFile">configuration file</param>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeSingleton.CreateNewParser">
            <summary>
            Returns a JavaCC generated Parser.
            </summary>
            <returns>Parser javacc generated parser</returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeSingleton.Parse(System.IO.TextReader,System.String)">
            <summary> Parse the input and return the root of
            AST node structure.
            </summary>
            <remarks>
            In the event that it runs out of parsers in the
            pool, it will create and let them be GC'd
            dynamically, logging that it has to do that.  This
            is considered an exceptional condition.  It is
            expected that the user will set the
            PARSER_POOL_SIZE property appropriately for their
            application.  We will revisit this.
            </remarks>
            <param name="reader">TextReader retrieved by a resource loader</param>
            <param name="templateName">name of the template being parsed</param>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeSingleton.Parse(System.IO.TextReader,System.String,System.Boolean)">
            <summary>
            Parse the input and return the root of the AST node structure.
            </summary>
            <param name="reader">TextReader retrieved by a resource loader</param>
            <param name="templateName">name of the template being parsed</param>
            <param name="dumpNamespace">flag to dump the Velocimacro namespace for this template</param>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeSingleton.GetTemplate(System.String)">
             <summary> Returns a <code>Template</code> from the resource manager.
             This method assumes that the character encoding of the
             template is set by the <code>input.encoding</code>
             property.  The default is "ISO-8859-1"
             *
             </summary>
             <param name="name">The file name of the desired template.
             </param>
             <returns>    The template.
             @throws ResourceNotFoundException if template not found
             from any available source.
             @throws ParseErrorException if template cannot be parsed due
             to syntax (or other) error.
             @throws Exception if an error occurs in template initialization
            
             </returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeSingleton.GetTemplate(System.String,System.String)">
             <summary> Returns a <code>Template</code> from the resource manager
             *
             </summary>
             <param name="name">The  name of the desired template.
             </param>
             <param name="encoding">Character encoding of the template
             </param>
             <returns>    The template.
             @throws ResourceNotFoundException if template not found
             from any available source.
             @throws ParseErrorException if template cannot be parsed due
             to syntax (or other) error.
             @throws Exception if an error occurs in template initialization
            
             </returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeSingleton.GetContent(System.String)">
             <summary> Returns a static content resource from the
             resource manager.  Uses the current value
             if INPUT_ENCODING as the character encoding.
             *
             </summary>
             <param name="name">Name of content resource to get
             </param>
             <returns>parsed ContentResource object ready for use
             @throws ResourceNotFoundException if template not found
             from any available source.
            
             </returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeSingleton.GetContent(System.String,System.String)">
             <summary> Returns a static content resource from the
             resource manager.
             *
             </summary>
             <param name="name">Name of content resource to get
             </param>
             <param name="encoding">Character encoding to use
             </param>
             <returns>parsed ContentResource object ready for use
             @throws ResourceNotFoundException if template not found
             from any available source.
            
             </returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeSingleton.GetLoaderNameForResource(System.String)">
             <summary>  Determines is a template exists, and returns name of the loader that
             provides it.  This is a slightly less hokey way to support
             the Velocity.templateExists() utility method, which was broken
             when per-template encoding was introduced.  We can revisit this.
             *
             </summary>
             <param name="resourceName">Name of template or content resource
             </param>
             <returns>class name of loader than can provide it
            
             </returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeSingleton.Warn(System.Object)">
            <summary>
            Log a warning message.
            </summary>
            <param name="message">message to log</param>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeSingleton.Info(System.Object)">
            
             <summary>
             Log an info message.
             </summary>
             <param name="message">message to log</param>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeSingleton.Error(System.Object)">
            <summary>
            Log an error message.
            </summary>
            <param name="message">message to log</param>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeSingleton.Debug(System.Object)">
            <summary>
            Log a debug message.
            </summary>
            <param name="message">message to log</param>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeSingleton.getString(System.String,System.String)">
             <summary> String property accessor method with default to hide the
             configuration implementation.
            
             </summary>
             <param name="key">property key
             </param>
             <param name="defaultValue">default value to return if key not
             found in resource manager.
             </param>
             <returns>String  value of key or default
            
             </returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeSingleton.GetVelocimacro(System.String,System.String)">
            <summary>
            Returns the appropriate VelocimacroProxy object if vmName
            is a valid current Velocimacro.
            </summary>
            <param name="vmName">Name of velocimacro requested</param>
            <param name="templateName">Template Name</param>
            <returns>VelocimacroProxy</returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeSingleton.AddVelocimacro(System.String,System.String,System.String[],System.String)">
            <summary>
            Adds a new Velocimacro. Usually called by Macro only while parsing.
            </summary>
            <param name="name">Name of velocimacro</param>
            <param name="macro">String form of macro body</param>
            <param name="argArray">Array of strings, containing the 
            <code>#macro()</code> arguments. The 0th is the name.
            </param>
            <param name="sourceTemplate">Source template</param>
            <returns>True if added, false if rejected for some
            reason (either parameters or permission settings)
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeSingleton.IsVelocimacro(System.String,System.String)">
            <summary>
            Checks to see if a VM exists
            </summary>
            <param name="vmName">Name of velocimacro</param>
            <param name="templateName">Template Name</param>
            <returns>True if VM by that name exists, false if not</returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeSingleton.DumpVMNamespace(System.String)">
            <summary>
            Tells the vmFactory to dump the specified namespace.
            This is to support clearing the VM list when in 
            inline-VM-local-scope mode
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeSingleton.GetString(System.String)">
            <summary>
            String property accessor method to hide the configuration implementation.
            </summary>
            <param name="key">property key</param>
            <returns>Value of key or <c>null</c></returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeSingleton.GetInt(System.String)">
            <summary>
            Int property accessor method to hide the configuration implementation.
            </summary>
            <param name="key">property key</param>
            <returns>value</returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeSingleton.GetInt(System.String,System.Int32)">
            <summary>
            Int property accessor method to hide the configuration implementation.
            </summary>
            <param name="key">property key</param>
            <param name="defaultValue">default value</param>
            <returns>value</returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeSingleton.GetBoolean(System.String,System.Boolean)">
            <summary>
            Boolean property accessor method to hide the configuration implementation.
            </summary>
            <param name="key">property key</param>
            <param name="def">default value if property not found</param>
            <returns>value of key or default value</returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeSingleton.GetApplicationAttribute(System.Object)">
            <summary>
            <seealso cref="M:NVelocity.Runtime.IRuntimeServices.GetApplicationAttribute(System.Object)"/>
            </summary>
            <param name="key">key</param>
            <returns>value</returns>
        </member>
        <member name="P:NVelocity.Runtime.RuntimeSingleton.Configuration">
            <summary>
            Return the velocity runtime configuration object.
            </summary>
            <returns>
            ExtendedProperties configuration object which houses
            the velocity runtime properties.
            </returns>
        </member>
        <member name="P:NVelocity.Runtime.RuntimeSingleton.Introspector">
            <summary>
            Return the Introspector for this RuntimeInstance
            </summary>
            <returns>
            Introspector object for this runtime instance
            </returns>
        </member>
        <member name="P:NVelocity.Runtime.RuntimeSingleton.RuntimeInstance">
            <summary>
            Returns the RuntimeInstance object for this singleton.
            For internal use only.
            </summary>
            <returns>
            The <see cref="P:NVelocity.Runtime.RuntimeSingleton.RuntimeInstance"/> used by this Singleton instance.
            </returns>
        </member>
        <member name="T:NVelocity.Runtime.VelocimacroFactory">
             <summary>  VelocimacroFactory.java
             *
             manages the set of VMs in a running Velocity engine.
             *
             </summary>
             <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
             </author>
             <version> $Id: VelocimacroFactory.cs,v 1.5 2003/10/27 15:37:24 corts Exp $
            
             </version>
        </member>
        <member name="F:NVelocity.Runtime.VelocimacroFactory.rsvc">
            <summary>  runtime services for this instance
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.VelocimacroFactory.vmManager">
            <summary>  VMManager : deal with namespace management
            and actually keeps all the VM definitions
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.VelocimacroFactory.replaceAllowed">
            <summary>  determines if replacement of global VMs are allowed
            controlled by  VM_PERM_ALLOW_INLINE_REPLACE_GLOBAL
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.VelocimacroFactory.addNewAllowed">
            <summary>  controls if new VMs can be added.  Set by
            VM_PERM_ALLOW_INLINE  Note the assumption that only
            through inline defs can this happen.
            additions through autoloaded VMs is allowed
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.VelocimacroFactory.templateLocal">
            <summary>  sets if template-local namespace in used
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.VelocimacroFactory.blather">
            <summary>  controls log output
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.VelocimacroFactory.autoReloadLibrary">
            <summary>  determines if the libraries are auto-loaded
            when they change
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.VelocimacroFactory.macroLibVec">
            <summary>  vector of the library names
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.VelocimacroFactory.libModMap">
            <summary>  map of the library Template objects
            used for reload determination
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.VelocimacroFactory.#ctor(NVelocity.Runtime.IRuntimeServices)">
            <summary>  CTOR : requires a runtime services from now
            on
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.VelocimacroFactory.InitVelocimacro">
            <summary>  initialize the factory - setup all permissions
            load all global libraries.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.VelocimacroFactory.AddVelocimacro(System.String,System.String,System.String[],System.String)">
            <summary>  adds a macro to the factory.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.VelocimacroFactory.CanAddVelocimacro(System.String,System.String)">
             <summary>  determines if a given macro/namespace (name, source) combo is allowed
             to be added
             *
             </summary>
             <param name="name">Name of VM to add
             </param>
             <param name="sourceTemplate">Source template that contains the defintion of the VM
             </param>
             <returns>true if it is allowed to be added, false otherwise
            
             </returns>
        </member>
        <member name="M:NVelocity.Runtime.VelocimacroFactory.LogVMMessageInfo(System.String)">
            <summary>  localization of the logging logic
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.VelocimacroFactory.LogVMMessageWarn(System.String)">
            <summary>  localization of the logging logic
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.VelocimacroFactory.IsVelocimacro(System.String,System.String)">
            <summary>  Tells the world if a given directive string is a Velocimacro
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.VelocimacroFactory.GetVelocimacro(System.String,System.String)">
            <summary>  actual factory : creates a Directive that will
            behave correctly wrt getting the framework to
            dig out the correct # of args
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.VelocimacroFactory.DumpVMNamespace(System.String)">
            <summary>  tells the vmManager to dump the specified namespace
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.VelocimacroFactory.Twonk">
            <summary>  sets permission to have VMs local in scope to their declaring template
            note that this is really taken care of in the VMManager class, but
            we need it here for gating purposes in addVM
            eventually, I will slide this all into the manager, maybe.
            </summary>
            <summary>   sets the permission to add new macros
            </summary>
            <summary>    sets the permission for allowing addMacro() calls to
            replace existing VM's
            </summary>
            <summary>  set output message mode
            </summary>
            <summary> get output message mode
            </summary>
            <summary>  set the switch for automatic reloading of
            global library-based VMs
            </summary>
            <summary>  get the switch for automatic reloading of
            global library-based VMs
            </summary>
            <summary> small continer class to hold the duple
            of a template and modification time.
            We keep the modification time so we can
            'override' it on a reload to prevent
            recursive reload due to inter-calling
            VMs in a library
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.VelocimacroManager">
            <summary> 
            Manages VMs in namespaces.  Currently, two namespace modes are
            supported:
            *
            <ul>
            <li>flat - all allowable VMs are in the global namespace</li>
            <li>local - inline VMs are added to it's own template namespace</li>
            </ul>
            *
            Thanks to <a href="mailto:JFernandez@viquity.com">Jose Alberto Fernandez</a>
            for some ideas incorporated here.
            *
            </summary>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
            </author>
            <author> <a href="mailto:JFernandez@viquity.com">Jose Alberto Fernandez</a>
            </author>
        </member>
        <member name="F:NVelocity.Runtime.VelocimacroManager.namespaceHash">
            <summary>Hash of namespace hashes.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.VelocimacroManager.libraryMap">
            <summary>map of names of library tempates/namespaces</summary>
        </member>
        <member name="M:NVelocity.Runtime.VelocimacroManager.#ctor(NVelocity.Runtime.IRuntimeServices)">
            <summary> Adds the global namespace to the hash.</summary>
        </member>
        <member name="M:NVelocity.Runtime.VelocimacroManager.AddVM(System.String,System.String,System.String[],System.String)">
             <summary> Adds a VM definition to the cache.
             </summary>
             <returns>Whether everything went okay.
            
             </returns>
        </member>
        <member name="M:NVelocity.Runtime.VelocimacroManager.get(System.String,System.String)">
            <summary> gets a new living VelocimacroProxy object by the
            name / source template duple
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.VelocimacroManager.DumpNamespace(System.String)">
             <summary> Removes the VMs and the namespace from the manager.
             Used when a template is reloaded to avoid
             accumulating drek
             </summary>
             <param name="ns">namespace to dump
             </param>
             <returns>boolean representing success
            
             </returns>
        </member>
        <member name="M:NVelocity.Runtime.VelocimacroManager.GetNamespace(System.String)">
            <summary>
            public switch to let external user of manager to control namespace
            usage indep of properties.  That way, for example, at startup the
            library files are loaded into global namespace
            
            returns the hash for the specified namespace.  Will not create a new one
            if it doesn't exist
            </summary>
            <param name="ns"> name of the namespace :) </param>
            <returns>namespace Hashtable of VMs or null if doesn't exist </returns>
        </member>
        <member name="M:NVelocity.Runtime.VelocimacroManager.GetNamespace(System.String,System.Boolean)">
            <summary>
            returns the hash for the specified namespace, and if it doesn't exist
            will create a new one and add it to the namespaces
            </summary>
            <param name="ns"> name of the namespace :)</param>
            <param name="addIfNew"> flag to add a new namespace if it doesn't exist</param>
            <returns>namespace Hashtable of VMs or null if doesn't exist</returns>
        </member>
        <member name="M:NVelocity.Runtime.VelocimacroManager.AddNamespace(System.String)">
            <summary>adds a namespace to the namespaces</summary>
            <param name="ns">name of namespace to add</param>
            <returns>Hash added to namespaces, ready for use</returns>
        </member>
        <member name="M:NVelocity.Runtime.VelocimacroManager.UsingNamespaces(System.String)">
            <summary>determines if currently using namespaces.</summary>
            <param name="ns">currently ignored</param>
            <returns>true if using namespaces, false if not</returns>
        </member>
        <member name="T:NVelocity.Runtime.VelocimacroManager.MacroEntry">
            <summary>  wrapper class for holding VM information
            </summary>
        </member>
        <member name="T:NVelocity.Tool.DataInfo">
             <summary> ToolInfo implementation to handle "primitive" data types.
             It currently supports String, Number, and Boolean data.
             *
             </summary>
             <author> <a href="mailto:nathan@esha.com">Nathan Bubna</a>
             *
             </author>
             <version> $Id: DataInfo.cs,v 1.2 2003/10/27 13:54:12 corts Exp $
            
             </version>
        </member>
        <member name="T:NVelocity.Tool.IToolInfo">
             <summary> Interface to simplify and abstract tool handling.
             *
             Implementations of this class should hold both the context
             key for the tool and sufficient information to return
             an instance of the tool.
             *
             </summary>
             <author> <a href="mailto:nathan@esha.com">Nathan Bubna</a>
             *
             </author>
             <version> $Id: IToolInfo.cs,v 1.2 2003/10/27 13:54:12 corts Exp $
            
             </version>
        </member>
        <member name="M:NVelocity.Tool.IToolInfo.getInstance(System.Object)">
             <returns>the context key for the tool
            
             </returns>
             <returns>the fully qualified classname for the tool
            
             </returns>
             <summary> Returns an instance of the tool.
             *
             Instances returned may be new on each call, pooled, or
             the be same instance every time depending on the
             implementation.  The object passed to this method may
             be used to initialize or create the tool that is returned,
             or it may be null if no such data is required.
             *
             </summary>
             <param name="initData">an object that may be used to initialize the instance
             </param>
             <returns>an instance of the tool
            
             </returns>
        </member>
        <member name="M:NVelocity.Tool.DataInfo.#ctor(System.String,System.String,System.String)">
             <summary> Parses the value string into a recognized type. If
             the type specified is not supported, the data will
             be held and returned as a string.
             *
             </summary>
             <param name="key">the context key for the data
             </param>
             <param name="type">the data type
             </param>
             <param name="value_">the data
            
             </param>
        </member>
        <member name="M:NVelocity.Tool.DataInfo.getInstance(System.Object)">
            <summary> Returns the data. Always returns the same
            object since the data is a constant. Initialization
            data is ignored.
            </summary>
        </member>
        <member name="T:NVelocity.Tool.ToolLoader">
            <summary>
            <p>A view tool that allows template designers to load
            an arbitrary object into the context. Any object
            with a public constructor without parameters can be used
            as a view tool.</p>
            <p>THIS CLASS IS HERE AS A PROOF OF CONCEPT ONLY. IT IS NOT
            INTENDED FOR USE IN PRODUCTION ENVIRONMENTS. USE AT YOUR OWN RISK.</p>
            </summary>
            <author><a href="mailto:sidler@teamup.com">Gabe Sidler</a></author>
            <author><a href="mailto:geirm@apache.org">Geir Magnusson Jr.</a></author>
        </member>
        <member name="M:NVelocity.Tool.ToolLoader.Load(System.String)">
            <summary>
            Creates and returns an object of the specified classname.
            The object must have a valid default constructor.
            </summary>
            <param name="clazz">the fully qualified class name of the object</param>
            <returns>an instance of the specified class or null if the class
            could not be instantiated.</returns>
        </member>
        <member name="T:NVelocity.Util.Introspection.AmbiguousException">
            <summary>  
            Simple distinguishable exception, used when
            we run across ambiguous overloading
            </summary>
        </member>
        <member name="M:NVelocity.Util.Introspection.AmbiguousException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NVelocity.Util.Introspection.AmbiguousException"/> class.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:NVelocity.Util.Introspection.AmbiguousException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NVelocity.Util.Introspection.AmbiguousException"/> class.
            </summary>
            <param name="message">The message.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="M:NVelocity.Util.Introspection.AmbiguousException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NVelocity.Util.Introspection.AmbiguousException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"></see> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"></see> that contains contextual information about the source or destination.</param>
            <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult"></see> is zero (0). </exception>
            <exception cref="T:System.ArgumentNullException">The info parameter is null. </exception>
        </member>
        <member name="T:NVelocity.Util.Introspection.ClassMap">
            <summary>
            A cache of introspection information for a specific class instance.
            Keys <see cref="T:System.Reflection.MethodInfo"/> objects by a concatenation of the
            method name and the names of classes that make up the parameters.
            </summary>
        </member>
        <member name="F:NVelocity.Util.Introspection.ClassMap.methodCache">
            <summary> Cache of Methods, or CACHE_MISS, keyed by method
            name and actual arguments used to find it.
            </summary>
        </member>
        <member name="M:NVelocity.Util.Introspection.ClassMap.#ctor(System.Type)">
            <summary> Standard constructor
            </summary>
        </member>
        <member name="M:NVelocity.Util.Introspection.ClassMap.FindMethod(System.String,System.Object[])">
             <summary>
             Find a Method using the methodKey provided.
            
             Look in the methodMap for an entry.  If found,
             it'll either be a CACHE_MISS, in which case we
             simply give up, or it'll be a Method, in which
             case, we return it.
            
             If nothing is found, then we must actually go
             and introspect the method from the MethodMap.
             </summary>
             <returns>
             the class object whose methods are cached by this map.
             </returns>
        </member>
        <member name="M:NVelocity.Util.Introspection.ClassMap.FindProperty(System.String)">
             <summary>
             Find a Method using the methodKey
             provided.
            
             Look in the methodMap for an entry.  If found,
             it'll either be a CACHE_MISS, in which case we
             simply give up, or it'll be a Method, in which
             case, we return it.
            
             If nothing is found, then we must actually go
             and introspect the method from the MethodMap.
             </summary>
        </member>
        <member name="M:NVelocity.Util.Introspection.ClassMap.PopulateMethodCache">
            <summary>
            Populate the Map of direct hits. These
            are taken from all the public methods
            that our class provides.
            </summary>
        </member>
        <member name="M:NVelocity.Util.Introspection.ClassMap.MakeMethodKey(System.Reflection.MethodInfo)">
            <summary>
            Make a methodKey for the given method using
            the concatenation of the name and the
            types of the method parameters.
            </summary>
        </member>
        <member name="M:NVelocity.Util.Introspection.ClassMap.GetAccessibleMethods(System.Type)">
            <summary>
            Retrieves public methods for a class.
            </summary>
        </member>
        <member name="P:NVelocity.Util.Introspection.ClassMap.CachedClass">
            <summary>
            Class passed into the constructor used to as
            the basis for the Method map.
            </summary>
        </member>
        <member name="T:NVelocity.Util.Introspection.Info">
            <summary>  
            Little class to carry in info such as template name, line and column
            for information error reporting from the uberspector implementations
            *
            </summary>
            <author>  <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
            </author>
            <version>  $Id: Info.cs,v 1.1 2004/12/27 05:55:08 corts Exp $
            
            </version>
        </member>
        <member name="M:NVelocity.Util.Introspection.Info.#ctor(System.String,System.Int32,System.Int32)">
            <param name="source">Usually a template name.
            </param>
            <param name="line">The line number from <code>source</code>.
            </param>
            <param name="column">The column number from <code>source</code>.
            
            </param>
        </member>
        <member name="M:NVelocity.Util.Introspection.Info.ToString">
            <summary> Formats a textual representation of this object as <code>SOURCE
            [line X, column Y]</code>.
            </summary>
        </member>
        <member name="T:NVelocity.Util.Introspection.IntrospectionCacheData">
            <summary>
            Holds information for node-local context data introspection
            information.
            </summary>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a> </author>
            <version> $Id: IntrospectionCacheData.cs,v 1.3 2003/10/27 13:54:12 corts Exp $ </version>
        </member>
        <member name="F:NVelocity.Util.Introspection.IntrospectionCacheData.Thingy">
            <summary>
            Object to pair with class - currently either a Method or
            AbstractExecutor. It can be used in any way the using node
            wishes.
            </summary>
        </member>
        <member name="F:NVelocity.Util.Introspection.IntrospectionCacheData.ContextData">
            <summary>
            Class of context data object associated with the 
            introspection information
            </summary>
        </member>
        <member name="T:NVelocity.Util.Introspection.Introspector">
             <summary> This basic function of this class is to return a Method
             object for a particular class given the name of a method
             and the parameters to the method in the form of an Object[]
            
             The first time the Introspector sees a
             class it creates a class method map for the
             class in question. Basically the class method map
             is a Hastable where Method objects are keyed by a
             concatenation of the method name and the names of
             classes that make up the parameters.
            
             For example, a method with the following signature:
            
             public void method(String a, StringBuffer b)
            
             would be mapped by the key:
            
             "method" + "java.lang.String" + "java.lang.StringBuffer"
            
             This mapping is performed for all the methods in a class
             and stored for
             </summary>
        </member>
        <member name="T:NVelocity.Util.Introspection.IntrospectorBase">
             <summary>
             This basic function of this class is to return a Method
             object for a particular class given the name of a method
             and the parameters to the method in the form of an Object[]
            
             The first time the Introspector sees a
             class it creates a class method map for the
             class in question. Basically the class method map
             is a Hastable where Method objects are keyed by a
             concatenation of the method name and the names of
             classes that make up the parameters.
            
             For example, a method with the following signature:
            
             public void method(String a, StringBuffer b)
            
             would be mapped by the key:
            
             "method" + "java.lang.String" + "java.lang.StringBuffer"
            
             This mapping is performed for all the methods in a class
             and stored for
             </summary>
             <version> $Id: IntrospectorBase.cs,v 1.3 2003/10/27 13:54:12 corts Exp $ </version>
        </member>
        <member name="F:NVelocity.Util.Introspection.IntrospectorBase.classMethodMaps">
            <summary>
            Holds the method maps for the classes we know about, keyed by
            Class object.
            </summary>
        </member>
        <member name="F:NVelocity.Util.Introspection.IntrospectorBase.cachedClassNames">
            <summary>
            Holds the qualified class names for the classes
            we hold in the classMethodMaps hash
            </summary>
        </member>
        <member name="M:NVelocity.Util.Introspection.IntrospectorBase.GetMethod(System.Type,System.String,System.Object[])">
            <summary>
            Gets the method defined by <code>name</code> and
            <code>params</code> for the Class <code>c</code>.
            </summary>
            <param name="c">Class in which the method search is taking place</param>
            <param name="name">Name of the method being searched for</param>
            <param name="parameters">An array of Objects (not Classes) that describe the the parameters</param>
            <returns>The desired <see cref="T:System.Reflection.MethodInfo"/> object.</returns>
        </member>
        <member name="M:NVelocity.Util.Introspection.IntrospectorBase.GetProperty(System.Type,System.String)">
            <summary>
            Gets the method defined by <code>name</code>
            for the Class <code>c</code>.
            </summary>
            <param name="c">Class in which the method search is taking place</param>
            <param name="name">Name of the method being searched for</param>
            <returns>The desired <see cref="T:System.Reflection.PropertyInfo"/> object.</returns>
        </member>
        <member name="M:NVelocity.Util.Introspection.IntrospectorBase.CreateClassMap(System.Type)">
            <summary>
            Creates a class map for specific class and registers it in the
            cache.  Also adds the qualified name to the name->class map
            for later Classloader change detection.
            </summary>
        </member>
        <member name="F:NVelocity.Util.Introspection.Introspector.rlog">
            <summary>  our engine runtime services
            </summary>
        </member>
        <member name="M:NVelocity.Util.Introspection.Introspector.#ctor(NVelocity.Runtime.IRuntimeLogger)">
            <summary>  Recieves our RuntimeServices object
            </summary>
        </member>
        <member name="M:NVelocity.Util.Introspection.Introspector.GetMethod(System.Type,System.String,System.Object[])">
            <summary>
            Gets the method defined by <code>name</code> and
            <code>params</code> for the Class <code>c</code>.
            </summary>
            <param name="c">Class in which the method search is taking place</param>
            <param name="name">Name of the method being searched for</param>
            <param name="parameters">An array of Objects (not Classes) that describe the the parameters</param>
            <returns>The desired Method object.</returns>
        </member>
        <member name="M:NVelocity.Util.Introspection.Introspector.GetProperty(System.Type,System.String)">
            <summary>
            Gets the method defined by <code>name</code>
            for the Class <code>c</code>.
            </summary>
            <param name="c">Class in which the method search is taking place</param>
            <param name="name">Name of the method being searched for</param>
            <returns>The desired <see cref="T:System.Reflection.PropertyInfo"/> object.</returns>
        </member>
        <member name="T:NVelocity.Util.Introspection.IUberspect">
            <summary> 'Federated' introspection/reflection interface to allow the introspection
            behavior in Velocity to be customized.
            *
            </summary>
            <author>  <a href="mailto:geirm@apache.org">Geir Magusson Jr.</a>
            </author>
            <version>  $Id: Uberspect.cs,v 1.1 2004/12/27 05:55:08 corts Exp $
            
            </version>
        </member>
        <member name="M:NVelocity.Util.Introspection.IUberspect.Init">
            <summary>  Initializer - will be called before use
            </summary>
        </member>
        <member name="M:NVelocity.Util.Introspection.IUberspect.GetMethod(System.Object,System.String,System.Object[],NVelocity.Util.Introspection.Info)">
            <summary>  Returns a general method, corresponding to $foo.bar( $woogie )
            </summary>
        </member>
        <member name="M:NVelocity.Util.Introspection.IUberspect.GetPropertyGet(System.Object,System.String,NVelocity.Util.Introspection.Info)">
            <summary> Property getter - returns VelPropertyGet appropos for #set($foo = $bar.woogie)
            </summary>
        </member>
        <member name="M:NVelocity.Util.Introspection.IUberspect.GetPropertySet(System.Object,System.String,System.Object,NVelocity.Util.Introspection.Info)">
            <summary> Property setter - returns VelPropertySet appropos for #set($foo.bar = "geir")
            </summary>
        </member>
        <member name="T:NVelocity.Util.Introspection.IVelMethod">
            <summary>  Method used for regular method invocation
            *
            $foo.bar()
            *
            *
            </summary>
            <author>  <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
            </author>
            <version>  $Id: VelMethod.cs,v 1.1 2004/12/27 05:55:08 corts Exp $
            
            </version>
        </member>
        <member name="M:NVelocity.Util.Introspection.IVelMethod.Invoke(System.Object,System.Object[])">
            <summary>  invocation method - called when the method invocationshould be
            preformed and a value returned
            </summary>
        </member>
        <member name="P:NVelocity.Util.Introspection.IVelMethod.Cacheable">
            <summary>  specifies if this VelMethod is cacheable and able to be
            reused for this class of object it was returned for
            *
            </summary>
            <returns> true if can be reused for this class, false if not
            
            </returns>
        </member>
        <member name="P:NVelocity.Util.Introspection.IVelMethod.MethodName">
            <summary>  returns the method name used
            </summary>
        </member>
        <member name="P:NVelocity.Util.Introspection.IVelMethod.ReturnType">
            <summary>  returns the return type of the method invoked
            </summary>
        </member>
        <member name="T:NVelocity.Util.Introspection.IVelPropertyGet">
            <summary>
            Interface defining a 'getter'.  For uses when looking for resolution of
            property references
            <code>
            $foo.bar
            </code>
            </summary>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a> </author>
            <version> $Id: VelPropertyGet.cs,v 1.1 2004/12/27 05:55:08 corts Exp $ </version>
        </member>
        <member name="M:NVelocity.Util.Introspection.IVelPropertyGet.Invoke(System.Object)">
            <summary>
            invocation method - called when the 'get action' should be
            preformed and a value returned
            </summary>
        </member>
        <member name="P:NVelocity.Util.Introspection.IVelPropertyGet.Cacheable">
            <summary>
            specifies if this VelPropertyGet is cacheable and able to be
            reused for this class of object it was returned for
            </summary>
            <returns>true if can be reused for this class, false if not</returns>
        </member>
        <member name="P:NVelocity.Util.Introspection.IVelPropertyGet.MethodName">
            <summary>
            returns the method name used to return this 'property'
            </summary>
        </member>
        <member name="T:NVelocity.Util.Introspection.IVelPropertySet">
            <summary>  Interface used for setting values that appear to be properties in
            Velocity.  Ex.
            *
            #set($foo.bar = "hello")
            *
            </summary>
            <author>  <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
            </author>
            <version>  $Id: VelPropertySet.cs,v 1.1 2004/12/27 05:55:08 corts Exp $
            
            </version>
        </member>
        <member name="M:NVelocity.Util.Introspection.IVelPropertySet.Invoke(System.Object,System.Object)">
            <summary>  method used to set the value in the object
            *
            </summary>
            <param name="o">Object on which the method will be called with the arg
            </param>
            <param name="arg">value to be set
            </param>
            <returns> the value returned from the set operation (impl specific)
            
            </returns>
        </member>
        <member name="P:NVelocity.Util.Introspection.IVelPropertySet.Cacheable">
            <summary>  specifies if this VelPropertySet is cacheable and able to be
            reused for this class of object it was returned for
            *
            </summary>
            <returns> true if can be reused for this class, false if not
            
            </returns>
        </member>
        <member name="P:NVelocity.Util.Introspection.IVelPropertySet.MethodName">
            <summary>  returns the method name used to set this 'property'
            </summary>
        </member>
        <member name="F:NVelocity.Util.Introspection.MethodMap.methodByNameMap">
            <summary> Keep track of all methods with the same name.</summary>
        </member>
        <member name="M:NVelocity.Util.Introspection.MethodMap.Add(System.Reflection.MethodInfo)">
            <summary> Add a method to a list of methods by name.
            For a particular class we are keeping track
            of all the methods with the same name.
            </summary>
        </member>
        <member name="M:NVelocity.Util.Introspection.MethodMap.Get(System.String)">
            <summary>
            Return a list of methods with the same name.
            </summary>
            <param name="key">key</param>
            <returns> List list of methods</returns>
        </member>
        <member name="M:NVelocity.Util.Introspection.MethodMap.Find(System.String,System.Object[])">
            <summary>
            Find a method.  Attempts to find the
            most specific applicable method using the
            algorithm described in the JLS section
            15.12.2 (with the exception that it can't
            distinguish a primitive type argument from
            an object type argument, since in reflection
            primitive type arguments are represented by
            their object counterparts, so for an argument of
            type (say) java.lang.Integer, it will not be able
            to decide between a method that takes int and a
            method that takes java.lang.Integer as a parameter.
            
            <para>
            This turns out to be a relatively rare case
            where this is needed - however, functionality
            like this is needed.
            </para>
            </summary>
            <param name="methodName">name of method</param>
            <param name="args">the actual arguments with which the method is called</param>
            <returns> the most specific applicable method, or null if no method is applicable.</returns>
            <exception cref="T:NVelocity.Util.Introspection.AmbiguousException">if there is more than one maximally specific applicable method</exception>
        </member>
        <member name="M:NVelocity.Util.Introspection.MethodMap.IsMoreSpecific(System.Reflection.ParameterInfo[],System.Reflection.ParameterInfo[])">
            <summary> Determines which method signature (represented by a class array) is more
            specific. This defines a partial ordering on the method signatures.
            </summary>
            <param name="c1">first signature to compare
            </param>
            <param name="c2">second signature to compare
            </param>
            <returns> MORE_SPECIFIC if c1 is more specific than c2, LESS_SPECIFIC if
            c1 is less specific than c2, INCOMPARABLE if they are incomparable.
            
            </returns>
        </member>
        <member name="M:NVelocity.Util.Introspection.MethodMap.GetApplicables(System.Collections.IList,System.Type[])">
            <summary>
            Returns all methods that are applicable to actual argument types.
            </summary>
            <param name="methods">list of all candidate methods</param>
            <param name="classes">the actual types of the arguments</param>
            <returns> 
            a list that contains only applicable methods (number of 
            formal and actual arguments matches, and argument types are assignable
            to formal types through a method invocation conversion).
            </returns>
            TODO: this used to return a LinkedList -- changed to an ArrayList for now until I can figure out what is really needed
        </member>
        <member name="M:NVelocity.Util.Introspection.MethodMap.IsApplicable(System.Reflection.MethodInfo,System.Type[])">
            <summary>
            Returns true if the supplied method is applicable to actual
            argument types.
            </summary>
        </member>
        <member name="M:NVelocity.Util.Introspection.MethodMap.IsMethodInvocationConvertible(System.Reflection.ParameterInfo,System.Type)">
            <summary>
            Determines whether a type represented by a class object is
            convertible to another type represented by a class object using a
            method invocation conversion, treating object types of primitive
            types as if they were primitive types (that is, a Boolean actual
            parameter type matches boolean primitive formal type). This behavior
            is because this method is used to determine applicable methods for
            an actual parameter list, and primitive types are represented by
            their object duals in reflective method calls.
            </summary>
            <param name="formal">the formal parameter type to which the actual parameter type should be convertible</param>
            <param name="actual">the actual parameter type.</param>
            <returns>
            true if either formal type is assignable from actual type,
            or formal is a primitive type and actual is its corresponding object
            type or an object type of a primitive type that can be converted to
            the formal type.
            </returns>
        </member>
        <member name="M:NVelocity.Util.Introspection.MethodMap.IsStrictMethodInvocationConvertible(System.Reflection.ParameterInfo,System.Reflection.ParameterInfo)">
            <summary>
            Determines whether a type represented by a class object is
            convertible to another type represented by a class object using a
            method invocation conversion, without matching object and primitive
            types. This method is used to determine the more specific type when
            comparing signatures of methods.
            </summary>
            <param name="formal">the formal parameter type to which the actual parameter type should be convertible</param>
            <param name="actual">the actual parameter type.</param>
            <returns>
            true if either formal type is assignable from actual type,
            or formal and actual are both primitive types and actual can be
            subject to widening conversion to formal.
            </returns>
        </member>
        <member name="T:NVelocity.Util.Introspection.Twonk">
            <summary> 
            little class to hold 'distance' information
            for calling params, as well as determine
            specificity
            </summary>
        </member>
        <member name="T:NVelocity.Util.Introspection.UberspectImpl">
            <summary>  Implementation of Uberspect to provide the default introspective
            functionality of Velocity
            *
            </summary>
            <author>  <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
            </author>
            <version>  $Id: UberspectImpl.cs,v 1.1 2004/12/27 05:55:08 corts Exp $
            
            </version>
        </member>
        <member name="T:NVelocity.Util.Introspection.UberspectLoggable">
            <summary>  
            Marker interface to let an uberspector indicate it can and wants to
            log
            *
            Thanks to Paulo for the suggestion
            *
            </summary>
            <author>  <a href="mailto:geirm@apache.org">Geir Magnusson Jr.</a>
            </author>
            <version>  $Id: UberspectLoggable.cs,v 1.1 2004/12/27 05:55:08 corts Exp $
            *
            
            </version>
        </member>
        <member name="P:NVelocity.Util.Introspection.UberspectLoggable.RuntimeLogger">
            <summary>  Sets the logger.  This will be called before any calls to the
            uberspector
            </summary>
        </member>
        <member name="F:NVelocity.Util.Introspection.UberspectImpl.rlog">
            <summary>
            Our runtime logger.
            </summary>
        </member>
        <member name="F:NVelocity.Util.Introspection.UberspectImpl.introspector">
            <summary>
            the default Velocity introspector
            </summary>
        </member>
        <member name="M:NVelocity.Util.Introspection.UberspectImpl.Init">
            <summary>
            init - does nothing - we need to have setRuntimeLogger
            called before getting our introspector, as the default
            vel introspector depends upon it.
            </summary>
        </member>
        <member name="M:NVelocity.Util.Introspection.UberspectImpl.GetMethod(System.Object,System.String,System.Object[],NVelocity.Util.Introspection.Info)">
            <summary>
            Method
            </summary>
        </member>
        <member name="M:NVelocity.Util.Introspection.UberspectImpl.GetPropertyGet(System.Object,System.String,NVelocity.Util.Introspection.Info)">
            <summary>
            Property  getter
            </summary>
        </member>
        <member name="M:NVelocity.Util.Introspection.UberspectImpl.GetPropertySet(System.Object,System.String,System.Object,NVelocity.Util.Introspection.Info)">
            <summary> Property setter
            </summary>
        </member>
        <member name="P:NVelocity.Util.Introspection.UberspectImpl.RuntimeLogger">
            <summary>
            Sets the runtime logger - this must be called before anything
            else besides init() as to get the logger.  Makes the pull
            model appealing...
            </summary>
        </member>
        <member name="T:NVelocity.Util.Introspection.UberspectImpl.VelMethodImpl">
            <summary>
            Implementation of <see cref="T:NVelocity.Util.Introspection.IVelMethod"/>.
            </summary>
        </member>
        <member name="T:NVelocity.Util.Introspection.UberspectImpl.VelGetterImpl">
            <summary>
            Implementation of <see cref="T:NVelocity.Util.Introspection.IVelPropertyGet"/>.
            </summary>
        </member>
        <member name="T:NVelocity.Util.SimplePool`1">
            <summary>
            Simple object pool. Based on ThreadPool and few other classes
            The pool will ignore overflow and return null if empty.
            </summary>
        </member>
        <member name="F:NVelocity.Util.SimplePool`1.max">
            <summary>  max amount of objects to be managed
            set via CTOR
            </summary>
        </member>
        <member name="F:NVelocity.Util.SimplePool`1.current">
            <summary>  index of previous to next
            free slot
            </summary>
        </member>
        <member name="M:NVelocity.Util.SimplePool`1.put(`0)">
            <summary>
            Add the object to the pool, silent nothing if the pool is full
            </summary>
        </member>
        <member name="M:NVelocity.Util.SimplePool`1.get">
            <summary>
            Get an object from the pool, null if the pool is empty.
            </summary>
        </member>
        <member name="M:NVelocity.Util.SimplePool`1.getPool">
            <summary>
            for testing purposes, so we can examine the pool
            </summary>
        </member>
        <member name="P:NVelocity.Util.SimplePool`1.Max">
            <summary>
            Return the size of the pool
            </summary>
        </member>
        <member name="T:NVelocity.Util.StringUtils">
             <summary> This class provides some methods for dynamically
             invoking methods in objects, and some string
             manipulation methods used by torque. The string
             methods will soon be moved into the turbine
             string utilities class.
             *
             </summary>
             <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a>
             </author>
             <author> <a href="mailto:dlr@finemaltcoding.com">Daniel Rall</a>
             </author>
             <version> $Id: StringUtils.cs,v 1.3 2003/10/27 13:54:12 corts Exp $
            
             </version>
        </member>
        <member name="F:NVelocity.Util.StringUtils.EOL">
            <summary> Line separator for the OS we are operating on.
            </summary>
        </member>
        <member name="M:NVelocity.Util.StringUtils.FirstLetterCaps(System.String)">
             <summary> <p>
             Makes the first letter caps and the rest lowercase.
             </p>
             *
             <p>
             For example <code>fooBar</code> becomes <code>Foobar</code>.
             </p>
             *
             </summary>
             <param name="data">capitalize this
             </param>
             <returns>String
            
             </returns>
        </member>
        <member name="M:NVelocity.Util.StringUtils.FileContentsToString(System.String)">
             <summary> Read the contents of a file and place them in
             a string object.
             *
             </summary>
             <param name="file">path to file.
             </param>
             <returns>String contents of the file.
            
             </returns>
        </member>
        <member name="M:NVelocity.Util.StringUtils.NormalizePath(System.String)">
             <summary> Return a context-relative path, beginning with a "/", that represents
             the canonical version of the specified path after ".." and "." elements
             are resolved out.  If the specified path attempts to go outside the
             boundaries of the current context (i.e. too many ".." path elements
             are present), return <code>null</code> instead.
             *
             </summary>
             <param name="path">Path to be normalized
             </param>
             <returns>String normalized path
            
             </returns>
        </member>
        <member name="T:NVelocity.IDuck">
            <summary>
            
            </summary>
        </member>
        <member name="M:NVelocity.IDuck.GetInvoke(System.String)">
            <summary>
            Defines the behavior when a property is read
            </summary>
            <param name="propName">Property name.</param>
            <returns>value back to the template</returns>
        </member>
        <member name="M:NVelocity.IDuck.SetInvoke(System.String,System.Object)">
            <summary>
            Defines the behavior when a property is written
            </summary>
            <param name="propName">Property name.</param>
            <param name="value">The value to assign.</param>
        </member>
        <member name="M:NVelocity.IDuck.Invoke(System.String,System.Object[])">
            <summary>
            Invokes the specified method.
            </summary>
            <param name="method">The method name.</param>
            <param name="args">The method arguments.</param>
            <returns>value back to the template</returns>
        </member>
        <member name="M:NVelocity.SupportClass.CreateNewInstance(System.Type)">
            <summary>
            Creates an instance of a received Type
            </summary>
            <param name="classType">The Type of the new class instance to return</param>
            <returns>An Object containing the new instance</returns>
        </member>
        <member name="T:NVelocity.Template">
            <summary>
            This class is used for controlling all template
            operations. This class uses a parser created
            by JavaCC to create an AST that is subsequently
            traversed by a Visitor.
            
            <code>
            Template template = Velocity.getTemplate("test.wm");
            IContext context = new VelocityContext();
            
            context.Put("foo", "bar");
            context.Put("customer", new Customer());
            
            template.Merge(context, writer);
            </code>
            </summary>
        </member>
        <member name="M:NVelocity.Template.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:NVelocity.Template.Process">
            <summary>
            Gets the named resource as a stream, parses and inits.
            </summary>
            <returns>true if successful</returns>
            <exception cref="T:NVelocity.Exception.ResourceNotFoundException">
            if template not found from any available source.
            </exception>
            <exception cref="T:NVelocity.Exception.ParseErrorException">
            if template cannot be parsed due to syntax (or other) error.
            </exception>
            <exception cref="T:System.Exception">
            some other problem, should only be from initialization of the template AST.
            </exception>
        </member>
        <member name="M:NVelocity.Template.InitDocument">
            <summary> 
            initializes the document.  init() is not longer
            dependant upon context, but we need to let the
            init() carry the template name down throught for VM
            namespace features
            </summary>
        </member>
        <member name="M:NVelocity.Template.Merge(NVelocity.Context.IContext,System.IO.TextWriter)">
            <summary>
            The AST node structure is merged with the
            context to produce the final output.
            
            Throws IOException if failure is due to a file related
            issue, and Exception otherwise
            </summary>
            <param name="context">Conext with data elements accessed by template</param>
            <param name="writer">writer for rendered template</param>
            <exception cref="T:NVelocity.Exception.ResourceNotFoundException">
            if template not found from any available source.
            </exception>
            <exception cref="T:NVelocity.Exception.ParseErrorException">
            if template cannot be parsed due to syntax (or other) error.
            </exception>
            <exception cref="T:System.Exception">
            anything else.
            </exception>
        </member>
        <member name="T:NVelocity.VelocityContext">
            <summary>
            General purpose implemention of the application Context
            interface for general application use.  This class should
            be used in place of the original Context class.
            This context implementation cannot be shared between threads
            without those threads synchronizing access between them, as
            the HashMap is not synchronized, nor are some of the fundamentals
            of AbstractContext.  If you need to share a Context between
            threads with simultaneous access for some reason, please create
            your own and extend the interface Context
            </summary>
        </member>
        <member name="F:NVelocity.VelocityContext.context">
            <summary>
            Storage for key/value pairs.
            </summary>
        </member>
        <member name="M:NVelocity.VelocityContext.#ctor">
            <summary>
            Creates a new instance (with no inner context).
            </summary>
        </member>
        <member name="M:NVelocity.VelocityContext.#ctor(System.Collections.Hashtable)">
            
             <summary>
             Creates a new instance with the provided storage (and no inner context).
             </summary>
        </member>
        <member name="M:NVelocity.VelocityContext.#ctor(NVelocity.Context.IContext)">
            <summary>
            Chaining constructor, used when you want to
            wrap a context in another.  The inner context
            will be 'read only' - put() calls to the
            wrapping context will only effect the outermost
            context
            </summary>
            <param name="innerContext">The <code>Context</code> implementation to wrap.</param>
        </member>
        <member name="M:NVelocity.VelocityContext.#ctor(System.Collections.Hashtable,NVelocity.Context.IContext)">
             <summary>
             Initializes internal storage (never to <code>null</code>), and
             inner context.
             </summary>
             <param name="context">Internal storage, or <code>null</code> to
             create default storage.
             </param>
             <param name="innerContext">Inner context.
            
             </param>
        </member>
        <member name="M:NVelocity.VelocityContext.InternalGet(System.String)">
            <summary>
            retrieves value for key from internal
            storage
            </summary>
            <param name="key">name of value to get</param>
            <returns>value as object</returns>
        </member>
        <member name="M:NVelocity.VelocityContext.InternalPut(System.String,System.Object)">
            <summary>
            stores the value for key to internal
            storage
            </summary>
            <param name="key">name of value to store</param>
            <param name="value">value to store</param>
            <returns>previous value of key as Object</returns>
        </member>
        <member name="M:NVelocity.VelocityContext.InternalContainsKey(System.Object)">
            <summary>
            determines if there is a value for the
            given key
            </summary>
            <param name="key">name of value to check</param>
            <returns>true if non-null value in store</returns>
        </member>
        <member name="M:NVelocity.VelocityContext.InternalGetKeys">
            <summary>
            returns array of keys
            </summary>
            <returns>keys as []</returns>
        </member>
        <member name="M:NVelocity.VelocityContext.InternalRemove(System.Object)">
            <summary>
            remove a key/value pair from the
            internal storage
            </summary>
            <param name="key">name of value to remove</param>
            <returns>value removed</returns>
        </member>
        <member name="M:NVelocity.VelocityContext.Clone">
            <summary>
            Clones this context object.
            </summary>
            <returns>A deep copy of this <code>Context</code>.</returns>
        </member>
    </members>
</doc>
